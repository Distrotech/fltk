# data file for the Fltk User Interface Designer (fluid)
version 3.0000 
header_name {.h} 
code_name {.cxx}
decl {\#include <stdio.h>} {public global
} 

decl {\#include <fltk3/run.h>} {public global
} 

decl {\#include <fltk3/Pixmap.h>} {public global
} 

decl {\#include <fltk3/Group.h>} {public global
} 

decl {\#include <fltk3/Tree.h>} {public global
} 

decl {\#include <fltk3/ask.h>} {public global
} 

decl {\#include <fltk3/message.h>} {public global
} 

decl {\#include <fltk3/FileChooser.h>} {public global
} 

decl {\#include <fltk3/Preferences.h>} {public global
} 

decl {\#include <fltk3/ColorChooser.h>} {public global
} 

decl {int G_cb_counter = 0;} {
  comment {// Global callback event counter} private local
} 

Function {reason_as_name(fltk3::TreeReason reason)} {
  comment {Return an Fl_Tree_Reason as a text string name} open return_type {const char*}
} {
  code {switch ( reason ) {
      case fltk3::TREE_REASON_NONE:       return("none");
      case fltk3::TREE_REASON_SELECTED:   return("selected");
      case fltk3::TREE_REASON_DESELECTED: return("deselected");
      case fltk3::TREE_REASON_OPENED:     return("opened");
      case fltk3::TREE_REASON_CLOSED:     return("closed");
      default:                        return("???");
    }} {}
} 

Function {Button_CB(fltk3::Widget*w, void*data)} {open return_type void
} {
  code {fprintf(stderr, "'%s' button pushed\\n", w->label());} {}
} 

Function {AssignUserIcons()} {
  comment {Assign user icons to the items} open
} {
  code {static const char *L_folder_xpm[] = {
    "11 11 3 1",
    ".  c None",
    "x  c \#d8d833",
    "@  c \#808011",
    "...........",
    ".....@@@@..",
    "....@xxxx@.",
    "@@@@@xxxx@@",
    "@xxxxxxxxx@",
    "@xxxxxxxxx@",
    "@xxxxxxxxx@",
    "@xxxxxxxxx@",
    "@xxxxxxxxx@",
    "@xxxxxxxxx@",
    "@@@@@@@@@@@"};
static fltk3::Pixmap L_folderpixmap(L_folder_xpm);

static const char *L_document_xpm[] = {
    "11 11 3 1",
    ".  c None",
    "x  c \#d8d8f8",
    "@  c \#202060",
    ".@@@@@@@@@.",
    ".@xxxxxxx@.",
    ".@xxxxxxx@.",
    ".@xxxxxxx@.",
    ".@xxxxxxx@.",
    ".@xxxxxxx@.",
    ".@xxxxxxx@.",
    ".@xxxxxxx@.",
    ".@xxxxxxx@.",
    ".@xxxxxxx@.",
    ".@@@@@@@@@."};
static fltk3::Pixmap L_documentpixmap(L_document_xpm);

// Assign user icons to tree items
for ( fltk3::TreeItem *item = tree->first(); item; item=item->next())
    if ( usericon_radio->value() )
        // Assign custom icons
        item->usericon(item->has_children() ? &L_folderpixmap : &L_documentpixmap);
    else
    	// Don't assign custom icons
        item->usericon(0);

tree->redraw();} {}
} 

Function {RebuildTree()} {
  comment {Rebuild the 'example tree' from scratch} open
} {
  code {// REBUILD THE TREE TO MAKE CURRENT "DEFAULT" PREFS TAKE EFFECT
tree->clear();
tree->add("Aaa");
tree->add("Bbb");
tree->add("Ccc");
tree->add("Ddd");
tree->add("Bbb/child-01");
tree->add("Bbb/child-01/111");
tree->add("Bbb/child-01/222");
tree->add("Bbb/child-01/333");
tree->add("Bbb/child-02");
tree->add("Bbb/child-03");
tree->add("Bbb/child-04");

{
    static fltk3::Button *but = 0;
    // Assign an FLTK widget to one of the items
    fltk3::TreeItem *i;
    if ( ( i = tree->find_item("Bbb/child-03") ) != NULL ) {
        if ( !but ) {		// only do this once at program startup
            tree->begin();
            but = new fltk3::Button(1,1,140,1,"ccc button");     // we control w() only
            but->labelsize(10);
	    but->callback(Button_CB);
        }
        i->widget(but);
        tree->end();
    }
}
{
    // Assign an FLTK group to one of the items with widgets
    fltk3::TreeItem *i;
    if ( ( i = tree->find_item("Bbb/child-04") ) != NULL ) {
        static fltk3::Group *grp = 0;
        if ( !grp ) {		// only do this once at program startup
            tree->begin();
              grp = new fltk3::Group(100,100,140,18); // build group.. tree handles position
              grp->color(fltk3::WHITE);
              grp->begin();
                fltk3::Button *abut = new fltk3::Button(grp->x()+0 ,grp->y()+2,65,15,"D1");
                abut->labelsize(10);
		abut->callback(Button_CB);
                fltk3::Button *bbut = new fltk3::Button(grp->x()+75,grp->y()+2,65,15,"D2");
                bbut->labelsize(10);
		bbut->callback(Button_CB);
              grp->end();
              grp->resizable(grp);
            tree->end();
        }
        i->widget(grp);
    }
}

// Add an 'Ascending' node, and create it sorted
tree->sortorder(fltk3::TREE_SORT_NONE);
tree->add("Ascending")->close();
tree->sortorder(fltk3::TREE_SORT_ASCENDING);
tree->add("Ascending/Zzz");
tree->add("Ascending/Xxx");
tree->add("Ascending/Aaa");
tree->add("Ascending/Bbb");
tree->add("Ascending/Yyy");
tree->add("Ascending/Ccc");

// Add a 'Descending' node, and create it sorted
tree->sortorder(fltk3::TREE_SORT_NONE);
tree->add("Descending")->close();
tree->sortorder(fltk3::TREE_SORT_DESCENDING);
tree->add("Descending/Zzz");
tree->add("Descending/Xxx");
tree->add("Descending/Aaa");
tree->add("Descending/Bbb");
tree->add("Descending/Yyy");
tree->add("Descending/Ccc");

// Add 500 items in numerical order
tree->sortorder(fltk3::TREE_SORT_NONE);
for ( int t=0; t<500; t++ ) {
    static char s[80];
    sprintf(s, "500 Items/item %04d", t);
    tree->add(s);
}
tree->close("500 Items");	// close the 500 items by default

AssignUserIcons();

tree->redraw();} {}
} 

Function {EditColor(fltk3::Color val)} {
  comment {Prompt the user to change the specified color} open return_type {fltk3::Color}
} {
  code {uchar r,g,b;
// Get the current color
fltk3::get_color(val,r,g,b);

// Bring up a color chooser to edit it
fltk3::color_chooser("Choose Color",r,g,b);

// Return the new color the user picked
return(fltk3::rgb_color(r,g,b));} {}
} 

Function {} {open
} {
  {fltk3::Window} window {
    label tree open
    xywh {488 270 1015 445} type Double visible
  } {
    {fltk3::Group} tree {
      label Tree
      user_data 1234
      callback {G_cb_counter++; // Increment callback counter whenever tree callback is invoked

fltk3::TreeItem *item = tree->callback_item();
if ( item ) {
  fprintf(stderr, "TREE CALLBACK: label='%s' userdata=%ld reason=%s\\n",
          item->label(),
          (long)(fl_intptr_t)tree->user_data(),
	  reason_as_name(tree->callback_reason()));
} else {
  fprintf(stderr, "TREE CALLBACK: reason=%s item=(no item -- probably multiple items were changed at once)\\n",
          reason_as_name(tree->callback_reason()));
}} open
      tooltip {Test tree} xywh {15 22 280 411} box DOWN_BOX color 55 selection_color 15
      class {fltk3::Tree}
    } {}
    {fltk3::Group} {} {open
      xywh {300 5 705 427}
      code0 {o->resizable(0);}
    } {
      {fltk3::Box} {} {
        label {Tree Globals}
        tooltip {These controls only affect the selected items. If no items are selected, all existing items in tree are modified.} xywh {311 23 335 263} box GTK_DOWN_BOX color 47 labelsize 12 align 1
      }
      {fltk3::ValueSlider} margintop_slider {
        label {margintop()}
        user_data tree
        callback {int val = (int)margintop_slider->value();
tree->margintop(val);
tree->redraw();}
        tooltip {Changes the top margin for the tree widget} xywh {486 31 140 16} type Horizontal labelsize 12 align 4 textsize 12
        code0 {o->value(tree->margintop());}
        code1 {o->range(0.0, 100.0);}
        code2 {o->step(1.0);}
        code3 {o->color(46); o->selection_color(fltk3::RED);}
      }
      {fltk3::ValueSlider} marginleft_slider {
        label {marginleft()}
        user_data tree
        callback {int val = (int)marginleft_slider->value();
tree->marginleft(val);
tree->redraw();}
        tooltip {Changes the left margin for the tree widget} xywh {486 51 140 16} type Horizontal labelsize 12 align 4 textsize 12
        code0 {o->value(tree->marginleft());}
        code1 {o->range(0.0, 100.0);}
        code2 {o->step(1.0);}
        code3 {o->color(46); o->selection_color(fltk3::RED);}
      }
      {fltk3::ValueSlider} openchild_marginbottom_slider {
        label {openchild_marginbottom()}
        user_data tree
        callback {int val = (int)openchild_marginbottom_slider->value();
tree->openchild_marginbottom(val);
tree->redraw();}
        tooltip {Changes the vertical space below an open child tree} xywh {486 71 140 16} type Horizontal labelsize 12 align 4 textsize 12
        code0 {o->value(tree->openchild_marginbottom());}
        code1 {o->range(0.0, 100.0);}
        code2 {o->step(1.0);}
        code3 {o->color(46); o->selection_color(fltk3::RED);}
      }
      {fltk3::Choice} collapseicons_chooser {
        label {Collapse icons}
        callback {static const char *L_open_xpm[] = {
\#ifdef __APPLE__
  "11 11 3 1",
  ".	c \#fefefe",
  "\#	c \#444444",
  "@	c \#000000",
  "\#\#\#\#\#\#\#\#\#\#\#",
  "\#.........\#",
  "\#.........\#",
  "\#....@....\#",
  "\#....@....\#",
  "\#..@@@@@..\#",
  "\#....@....\#",
  "\#....@....\#",
  "\#.........\#",
  "\#.........\#",
  "\#\#\#\#\#\#\#\#\#\#\#"
\#else
    "11 11 2 1",
    ".  c None",
    "@  c \#000000",
    "...@.......",
    "...@@......",
    "...@@@.....",
    "...@@@@....",
    "...@@@@@...",
    "...@@@@@@..",
    "...@@@@@...",
    "...@@@@....",
    "...@@@.....",
    "...@@......",
    "...@......."
\#endif
    };
static fltk3::Pixmap L_openpixmap(L_open_xpm);

static const char *L_close_xpm[] = {
\#ifdef __APPLE__
  "11 11 3 1",
  ".	c \#fefefe",
  "\#	c \#444444",
  "@	c \#000000",
  "\#\#\#\#\#\#\#\#\#\#\#",
  "\#.........\#",
  "\#.........\#",
  "\#.........\#",
  "\#.........\#",
  "\#..@@@@@..\#",
  "\#.........\#",
  "\#.........\#",
  "\#.........\#",
  "\#.........\#",
  "\#\#\#\#\#\#\#\#\#\#\#"
\#else
    "11 11 2 1",
    ".  c None",
    "@  c \#000000",
    "...........",
    "...........",
    "...........",
    "...........",
    "...........",
    "@@@@@@@@@@@",
    ".@@@@@@@@@.",
    "..@@@@@@@..",
    "...@@@@@...",
    "....@@@....",
    ".....@....."
\#endif
    };
static fltk3::Pixmap L_closepixmap(L_close_xpm);

switch ( collapseicons_chooser->value() ) {
    case 0:
        tree->showcollapse(1);
        tree->openicon(0);
        tree->closeicon(0);
        break;
    case 1:
        tree->showcollapse(1);
        tree->openicon(&L_openpixmap);
        tree->closeicon(&L_closepixmap);
        break;
    case 2:
        tree->showcollapse(0);
        break;
}}
        tooltip {Tests Fl_Tree::openicon() and Fl_Tree::closeicon()} xywh {486 96 140 21} down_box BORDER_BOX labelsize 12 textsize 11
      } {
        MenuItem {} {
          label Normal
          xywh {10 10 36 21} labelsize 12
        }
        MenuItem {} {
          label Custom
          xywh {20 20 36 21} labelsize 12
        }
        MenuItem {} {
          label Off
          xywh {30 30 36 21} labelsize 12
        }
      }
      {fltk3::Choice} connectorstyle_chooser {
        label {Line style}
        callback {// CHANGE COLLAPSESTYLE
switch ( connectorstyle_chooser->value() ) {
    case 0: tree->connectorstyle(fltk3::TREE_CONNECTOR_NONE);     break;
    case 1: tree->connectorstyle(fltk3::TREE_CONNECTOR_DOTTED);   break;
    case 2: tree->connectorstyle(fltk3::TREE_CONNECTOR_SOLID);    break;
}}
        tooltip {Tests connectorstyle() bit flags} xywh {486 120 140 21} down_box BORDER_BOX labelsize 12 textsize 11
        code0 {switch (tree->connectorstyle()) { case fltk3::TREE_CONNECTOR_NONE: connectorstyle_chooser->value(0); break; case fltk3::TREE_CONNECTOR_DOTTED: connectorstyle_chooser->value(1); break; case fltk3::TREE_CONNECTOR_SOLID: connectorstyle_chooser->value(2); break; }}
      } {
        MenuItem {} {
          label None
          xywh {40 40 36 21} labelsize 12
        }
        MenuItem {} {
          label Dotted
          xywh {20 20 36 21} labelsize 12
        }
        MenuItem {} {
          label Solid
          xywh {30 30 36 21} labelsize 12
        }
      }
      {fltk3::Choice} selectmode_chooser {
        label {Selection Mode}
        callback {// Set selection mode
switch ( selectmode_chooser->value() ) {
    case 0:  tree->selectmode(fltk3::TREE_SELECT_NONE);   break;	// None
    case 1:  tree->selectmode(fltk3::TREE_SELECT_SINGLE); break;	// Single
    case 2:  tree->selectmode(fltk3::TREE_SELECT_MULTI);  break; 	// Multi
    default: tree->selectmode(fltk3::TREE_SELECT_SINGLE); break;	// Single
}}
        tooltip {Sets how Fl_Tree handles mouse selection of tree items} xywh {486 144 140 21} down_box BORDER_BOX labelsize 12 textsize 11
        code0 {selectmode_chooser->value(1);}
        code1 {cb_selectmode_chooser(selectmode_chooser, (void*)0);}
      } {
        MenuItem {} {
          label None
          xywh {40 40 36 21} labelsize 12
        }
        MenuItem {} {
          label Single
          xywh {50 50 36 21} labelsize 12
        }
        MenuItem {} {
          label Multi
          xywh {60 60 36 21} labelsize 12
        }
      }
      {fltk3::Choice} whenmode_chooser {
        label When
        callback {// Set when mode
switch ( whenmode_chooser->value() ) {
  case 0:  tree->when(fltk3::WHEN_RELEASE);   break;
  case 1:  tree->when(fltk3::WHEN_CHANGED);   break;
  case 2:  tree->when(fltk3::WHEN_NEVER);     break;
  default: tree->when(fltk3::WHEN_RELEASE);   break;
}}
        tooltip {Sets when() the tree's callback is invoked} xywh {486 168 140 21} down_box BORDER_BOX labelsize 12 textsize 11
        code0 {whenmode_chooser->value(1);}
        code1 {cb_whenmode_chooser(whenmode_chooser, (void*)0);}
      } {
        MenuItem {} {
          label Changed
          xywh {50 50 36 21} labelsize 12
        }
        MenuItem {} {
          label Released
          xywh {60 60 36 21} labelsize 12
        }
        MenuItem {} {
          label Never
          xywh {70 70 36 21} labelsize 12
        }
      }
      {fltk3::CheckButton} usericon_radio {
        label {Enable user icons?}
        user_data tree
        callback {AssignUserIcons();} selected
        tooltip {Tests Fl_Tree_Item::usericon()} xywh {486 194 20 16} down_box DOWN_BOX labelsize 12 align 7
        code0 {usericon_radio->value(1);}
      }
      {fltk3::CheckButton} showroot_radio {
        label {Show root?}
        user_data tree
        callback {int onoff = showroot_radio->value();
tree->showroot(onoff);}
        tooltip {Tests tree->showroot();} xywh {486 211 20 16} down_box DOWN_BOX labelsize 12 align 7
        code0 {int onoff = tree->showroot(); showroot_radio->value(onoff);}
      }
      {fltk3::CheckButton} visiblefocus_checkbox {
        label {Visible focus?}
        user_data tree
        callback {int onoff = visiblefocus_checkbox->value();
tree->visible_focus(onoff);}
        tooltip {Toggles the tree's visible_focus() box} xywh {486 228 20 16} down_box DOWN_BOX labelsize 12 align 7
        code0 {int onoff = tree->visible_focus(); visiblefocus_checkbox->value(onoff);}
      }
      {fltk3::Button} selection_color_button {
        label {Selection Color}
        callback {fltk3::Color val = EditColor(tree->selection_color());		// Get color of first item in tree
selection_color_button->color(val);	// update modified color to button
tree->selection_color(val);
tree->redraw();}
        tooltip {Changes the tree widget's selection color. Tests Fl_Tree::selection_color()} xywh {486 251 16 16} box DOWN_BOX labelsize 12 align 7
        code0 {o->color(tree->selection_color());}
      }
      {fltk3::Box} {} {
        label {Test Operations}
        tooltip {These controls only affect the defaults for new items that are created. These test the Fl_Tree_Prefs methods.} xywh {311 312 335 120} box GTK_DOWN_BOX color 47 labelsize 12 align 1
      }
      {fltk3::Box} showitem_box {
        label {show_item()
}
        xywh {331 335 70 82} box GTK_DOWN_BOX labelsize 11 align 1
      }
      {fltk3::Button} {} {
        label Show
        callback {fltk3::TreeItem *item = tree->next_selected_item();
tree->show_item(item);}
        tooltip {Tests show_item() with no position specified.
Makes the selected item visible IF it is off-screen.
No change made if it is not off-screen.} xywh {346 344 40 17} labelsize 11
      }
      {fltk3::Button} {} {
        label Top
        callback {fltk3::TreeItem *item = tree->next_selected_item();
tree->show_item_top(item);}
        tooltip {Test show_item_top().
Scrolls selected item to the top of the display
(only works if scrollbar showing)
To use:
1) open '500 items'
2) select item 0010
3) Hit Top/Mid/Bot} xywh {346 361 40 16} labelsize 11
      }
      {fltk3::Button} {} {
        label Mid
        callback {fltk3::TreeItem *item = tree->next_selected_item();
tree->show_item_middle(item);}
        tooltip {Tests show_item_middle().
Scrolls the selected item to the middle of the display
To use:
  1) open '500 items'
  2) select 'item 0010'
  3) Hit Top/Mid/Bot} xywh {346 377 40 16} labelsize 11
      }
      {fltk3::Button} {} {
        label Bot
        callback {fltk3::TreeItem *item = tree->next_selected_item();
tree->show_item_bottom(item);}
        tooltip {Tests show_item_bottom().
Scrolls the selected item to the bottom of the display
To use:
  1) open '500 items'
  2) select 'item 0010'
  3) Hit Top/Mid/Bot} xywh {346 393 40 16} labelsize 11
      }
      {fltk3::Button} loaddb_button {
        label {Load Database...}
        callback {const char *filename = fltk3::file_chooser("Select a Preferences style Database", "Preferences(*.prefs)", 0L);
if (filename) {
  tree->clear();
  fltk3::Preferences prefs(filename, 0L, 0L);
  tree->load(prefs);
  tree->redraw();
}}
        tooltip {Load the contents of an Fl_Preferences database into the tree view} xywh {431 338 95 16} labelsize 9
      }
      {fltk3::Button} insertabove_button {
        label {Insert Above}
        callback {fltk3::TreeItem *item=tree->first();
while (item) {
    if ( item->is_selected() ) {
        tree->insert_above(item, "AaaAaa");
        tree->insert_above(item, "BbbBbb");
        tree->insert_above(item, "CccCcc");
    }
    item = item->next();
}

tree->redraw();}
        tooltip {Inserts three items above the selected items} xywh {431 358 95 16} labelsize 9
      }
      {fltk3::Button} rebuildtree_button {
        label {Rebuild Tree}
        callback {RebuildTree();}
        tooltip {Rebuilds the tree with defaults} xywh {431 378 95 16} labelsize 9
      }
      {fltk3::Button} showpathname_button {
        label {Show Pathname}
        callback {fltk3::TreeItem *item = tree->first_selected_item();
if ( !item ) { fltk3::message("No item was selected"); return; }

char pathname[256];
switch ( tree->item_pathname(pathname, sizeof(pathname), item) ) {
    case  0: fltk3::message("Pathname for '%s' is: \\"%s\\"", (item->label() ? item->label() : "???"), pathname); break;
    case -1: fltk3::message("item_pathname() returned -1 (NOT FOUND)"); break;
    case -2: fltk3::message("item_pathname() returned -2 (STRING TOO LONG)"); break;
}}
        tooltip {Show the pathname for the selected item. Tests the Fl_Tree::item_pathname() method.} xywh {431 398 95 16} labelsize 9
      }
      {fltk3::Button} clearall_button {
        label {Clear All}
        callback {tree->clear();
tree->redraw();}
        tooltip {Clears all items
Tests Fl_Tree::clear()} xywh {531 338 95 16} labelsize 9
      }
      {fltk3::Button} testcallbackflag_button {
        label {Test Callback Flag}
        callback {fltk3::TreeItem *root = tree->root();
fprintf(stderr, "--- Checking docallback off\\n");
if (!root) return;

//// "OFF" TEST

// open/close: Make sure these methods don't trigger cb
G_cb_counter = 0; tree->close(root, 0);       if ( G_cb_counter ) fltk3::alert("FAILED 'OFF' TEST\\n close(item) triggered cb!");
G_cb_counter = 0; tree->open(root, 0);        if ( G_cb_counter ) fltk3::alert("FAILED 'OFF' TEST\\n open(item) triggered cb!");
G_cb_counter = 0; tree->open_toggle(root, 0); if ( G_cb_counter ) fltk3::alert("FAILED 'OFF' TEST\\n open_toggle(item) triggered cb!");
G_cb_counter = 0; tree->open("ROOT", 0);      if ( G_cb_counter ) fltk3::alert("FAILED 'OFF' TEST\\n open(path) triggered cb!");
G_cb_counter = 0; tree->close("ROOT", 0);     if ( G_cb_counter ) fltk3::alert("FAILED 'OFF' TEST\\n close(path) triggered cb!");
tree->open(root,0);	// leave root open

// select/deselect: Make sure these methods don't trigger cb
G_cb_counter = 0; tree->select(root, 0);        if ( G_cb_counter ) fltk3::alert("FAILED 'OFF' TEST\\n select(item) triggered cb!");
G_cb_counter = 0; tree->deselect(root, 0);      if ( G_cb_counter ) fltk3::alert("FAILED 'OFF' TEST\\n deselect(item) triggered cb!");
G_cb_counter = 0; tree->select_toggle(root, 0); if ( G_cb_counter ) fltk3::alert("FAILED 'OFF' TEST\\n select_toggle(item) triggered cb!");
G_cb_counter = 0; tree->deselect("ROOT", 0);    if ( G_cb_counter ) fltk3::alert("FAILED 'OFF' TEST\\n deselect(path) triggered cb!");
G_cb_counter = 0; tree->select("ROOT", 0);      if ( G_cb_counter ) fltk3::alert("FAILED 'OFF' TEST\\n select(path) triggered cb!");
tree->deselect("ROOT"); // leave deselected

//// "ON" TEST

// open/close: Make sure these methods don't trigger cb
G_cb_counter = 0; tree->close(root, 1);       if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n close(item) cb wasn't triggered!");
G_cb_counter = 0; tree->open(root, 1);        if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n open(item) cb wasn't triggered!");
G_cb_counter = 0; tree->open_toggle(root, 1); if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n open_toggle(item) cb wasn't triggered!");
G_cb_counter = 0; tree->open(root, 1);        if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n open(item)[2] cb wasn't triggered!");
G_cb_counter = 0; tree->close(root, 1);       if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n close(item)[2] cb wasn't triggered!");
G_cb_counter = 0; tree->open("ROOT", 1);      if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n open(path) cb wasn't triggered!");
G_cb_counter = 0; tree->close("ROOT", 1);     if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n close(path) cb wasn't triggered!");
tree->open(root,0);	// leave root open

// select/deselect: Make sure these methods don't trigger cb
G_cb_counter = 0; tree->select(root, 1);        if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n select(item) cb wasn't triggered!");
G_cb_counter = 0; tree->deselect(root, 1);      if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n deselect(item) cb wasn't triggered!");
G_cb_counter = 0; tree->select_toggle(root, 1); if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n select_toggle(item) cb wasn't triggered!");
G_cb_counter = 0; tree->deselect("ROOT", 1);    if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n deselect(path) cb wasn't triggered!");
G_cb_counter = 0; tree->select("ROOT", 1);      if ( !G_cb_counter ) fltk3::alert("FAILED 'ON' TEST\\n select(path) cb wasn't triggered!");
tree->deselect("ROOT"); // leave deselected

//// "default" TEST (should be same as 'on'

// open/close: Make sure these methods don't trigger cb
G_cb_counter = 0; tree->close(root);       if ( !G_cb_counter ) fltk3::alert("FAILED 'DEFAULT' TEST: close(item) cb wasn't triggered!");
G_cb_counter = 0; tree->open(root);        if ( !G_cb_counter ) fltk3::alert("FAILED 'DEFAULT' TEST: open(item) cb wasn't triggered!");
G_cb_counter = 0; tree->open_toggle(root); if ( !G_cb_counter ) fltk3::alert("FAILED 'DEFAULT' TEST: open_toggle(item) cb wasn't triggered!");
G_cb_counter = 0; tree->open("ROOT");      if ( !G_cb_counter ) fltk3::alert("FAILED 'DEFAULT' TEST: open(path) cb wasn't triggered!");
G_cb_counter = 0; tree->close("ROOT");     if ( !G_cb_counter ) fltk3::alert("FAILED 'DEFAULT' TEST: close(path) cb wasn't triggered!");
tree->open(root,0);	// leave root open

// select/deselect: Make sure these methods don't trigger cb
G_cb_counter = 0; tree->select(root);        if ( !G_cb_counter ) fltk3::alert("FAILED 'DEFAULT' TEST\\n select(item) cb wasn't triggered!");
G_cb_counter = 0; tree->deselect(root);      if ( !G_cb_counter ) fltk3::alert("FAILED 'DEFAULT' TEST\\n deselect(item) cb wasn't triggered!");
G_cb_counter = 0; tree->select_toggle(root); if ( !G_cb_counter ) fltk3::alert("FAILED 'DEFAULT' TEST\\n select_toggle(item) cb wasn't triggered!");
G_cb_counter = 0; tree->deselect("ROOT");    if ( !G_cb_counter ) fltk3::alert("FAILED 'DEFAULT' TEST\\n deselect(path) cb wasn't triggered!");
G_cb_counter = 0; tree->select("ROOT");      if ( !G_cb_counter ) fltk3::alert("FAILED 'DEFAULT' TEST\\n select(path) cb wasn't triggered!");
tree->deselect("ROOT"); // leave deselected

fltk3::alert("TEST COMPLETED\\n If you didn't see any error dialogs, test PASSED.");}
        tooltip {Test the 'docallback' argument can disable callbacks.} xywh {531 358 95 16} labelsize 9
      }
      {fltk3::Box} {} {
        label {Selected Items}
        tooltip {These controls only affect the selected items. If no items are selected, all existing items in tree are modified.} xywh {661 23 335 263} box GTK_DOWN_BOX color 47 labelsize 12 align 1
      }
      {fltk3::Choice} all_font_choice {
        label {Label Font}
        callback {// Find first item in tree
fltk3::TreeItem *item = tree->first();
if ( !item ) return;

// Get first item's font.
fltk3::Font val = (fltk3::Font)all_font_choice->value(); // Get font value

// Do selected items
int count = 0;
for ( item=tree->first(); item; item = tree->next(item) ) {
    if ( item->is_selected() ) {
        item->labelfont(val);
        count++;
    }
}

// No items selected? Do all..
if ( ! count ) {
    for ( item=tree->first(); item; item = tree->next(item) ) {
        item->labelfont(val);
    }
}

tree->redraw();}
        tooltip {Changes the font for the selected items's labels. If none selected, all are changed. Tests Fl_Tree_Item::labelfont();} xywh {828 31 140 21} down_box BORDER_BOX labelsize 12 textsize 11
        code0 {o->value((int)tree->item_labelfont());   // get tree's current font, assign to chooser}
      } {
        MenuItem {} {
          label Helvetica
          xywh {30 30 36 21} labelsize 12
        }
        MenuItem {} {
          label {Helvetica Bold}
          xywh {40 40 36 21} labelsize 12
        }
        MenuItem {} {
          label {Helvetica Italic}
          xywh {55 55 36 21} labelsize 12
        }
        MenuItem {} {
          label {Helvetica Bold Italic}
          xywh {60 60 36 21} labelsize 12
        }
        MenuItem {} {
          label Courier
          xywh {70 70 36 21} labelsize 12
        }
        MenuItem {} {
          label {Courier Bold}
          xywh {80 80 36 21} labelsize 12
        }
        MenuItem {} {
          label {Courier Italic}
          xywh {65 65 36 21} labelsize 12
        }
        MenuItem {} {
          label {Courier Bold Italic}
          xywh {70 70 36 21} labelsize 12
        }
        MenuItem {} {
          label Times
          xywh {80 80 36 21} labelsize 12
        }
        MenuItem {} {
          label {Times Bold}
          xywh {90 90 36 21} labelsize 12
        }
        MenuItem {} {
          label {Times Italic}
          xywh {75 75 36 21} labelsize 12
        }
        MenuItem {} {
          label {Times Bold Italic}
          xywh {80 80 36 21} labelsize 12
        }
        MenuItem {} {
          label Symbol
          xywh {90 90 36 21} labelsize 12
        }
        MenuItem {} {
          label Screen
          xywh {100 100 36 21} labelsize 12
        }
        MenuItem {} {
          label {Screen bold}
          xywh {85 85 36 21} labelsize 12
        }
        MenuItem {} {
          label {Zapf Dingbats}
          xywh {90 90 36 21} labelsize 12
        }
      }
      {fltk3::ValueSlider} labelsize_slider {
        label {Label Size}
        user_data tree
        callback {int size = (int)labelsize_slider->value();

// DO SELECTED ITEMS
int count = 0;
fltk3::TreeItem *item;
for ( item=tree->first(); item; item = tree->next(item) ) {
    if ( item->is_selected() ) {
        item->labelsize(size);
        count++;
    }
}

// NO ITEMS SELECTED? DO ALL
if ( ! count ) {
    for ( item=tree->first(); item; item = tree->next(item) ) {
        item->labelsize(size);
    }
}

tree->redraw();}
        tooltip {Changes the font size of the selected items's labels. If none selected, all are changed. Tests Fl_Tree_Item::labelsize();} xywh {828 55 140 16} type Horizontal labelsize 12 align 4 textsize 12
        code0 {o->value(tree->item_labelsize());}
        code1 {o->range(5.0, 200.0);}
        code2 {o->step(1.0);}
        code3 {o->color(46); o->selection_color(fltk3::RED);}
      }
      {fltk3::Button} all_labelfgcolor_button {
        label {Label FG Color}
        callback {// Find first item in tree
fltk3::TreeItem *item = tree->first();
if ( !item ) return;

// Get first item's color
fltk3::Color val = EditColor(item->labelfgcolor());		// Get color of first item in tree
all_labelfgcolor_button->color(val);			// update modified color to button

// Do selected items
int count = 0;
for ( item=tree->first(); item; item = tree->next(item) ) {
    if ( item->is_selected() ) {
        item->labelfgcolor(val);
        count++;
    }
}

// No items selected? Do all..
if ( ! count ) {
    for ( item=tree->first(); item; item = tree->next(item) ) {
        item->labelfgcolor(val);
    }
}

tree->redraw();}
        tooltip {Changes the label fg color for the selected items. If none selected, all are changed. Tests Fl_Tree_Item::labelfgcolor();} xywh {828 81 16 16} box DOWN_BOX labelsize 12 align 7
        code0 {o->color(tree->item_labelfgcolor());}
      }
      {fltk3::Button} all_labelbgcolor_button {
        label {Label BG Color}
        callback {// Find first item in tree
fltk3::TreeItem *item = tree->first();
if ( !item ) return;

// Get first item's color
fltk3::Color val = EditColor(item->labelbgcolor());		// Get color of first item in tree
all_labelbgcolor_button->color(val);			// update modified color to button

// Do selected items
int count = 0;
for ( item=tree->first(); item; item = tree->next(item) ) {
    if ( item->is_selected() ) {
        item->labelbgcolor(val);
        count++;
    }
}

// No items selected? Do all..
if ( ! count ) {
    for ( item=tree->first(); item; item = tree->next(item) ) {
        item->labelbgcolor(val);
    }
}

tree->redraw();}
        tooltip {Changes the label bg color for the selected items. If none selected, all are changed. Tests Fl_Tree_Item::labelbgcolor();} xywh {828 99 16 16} box DOWN_BOX labelsize 12 align 7
        code0 {o->color(tree->item_labelbgcolor());}
      }
      {fltk3::ValueSlider} connectorwidth_slider {
        label {Connector Width}
        user_data tree
        callback {tree->connectorwidth((int)connectorwidth_slider->value());}
        tooltip {Tests Fl_Tree::connectorwidth()} xywh {828 126 140 16} type Horizontal labelsize 12 align 4 textsize 12
        code0 {o->value(tree->connectorwidth());}
        code1 {o->range(1.0, 100.0);}
        code2 {o->step(1.0);}
        code3 {o->color(46); o->selection_color(fltk3::RED);}
      }
      {fltk3::LightButton} deactivate_toggle {
        label { Deactivate}
        callback {int onoff = deactivate_toggle->value() ? 0 : 1;

fltk3::TreeItem *item;
int count = 0;
for ( item=tree->first(); item; item = tree->next(item) ) {
    if ( item->is_selected() ) {
        item->activate(onoff);
        ++count;
    }
}

if ( count == 0 ) {
    for ( item=tree->first(); item; item = tree->next(item) ) {
        item->activate(onoff);
    }
}

tree->redraw();}
        tooltip {Toggle the deactivation state of the selected items.
If none are selected, all are set.} xywh {734 154 95 16} selection_color 1 labelsize 9
      }
      {fltk3::LightButton} bold_toggle {
        label { Bold Font}
        callback {int face = bold_toggle->value() ? fltk3::HELVETICA_BOLD : fltk3::HELVETICA;

// DO SELECTED ITEMS
int count = 0;
fltk3::TreeItem *item;
for ( item=tree->first(); item; item = tree->next(item) ) {
    if ( item->is_selected() ) {
        item->labelfont(face);
        count++;
    }
}

// NO ITEMS SELECTED? DO ALL
if ( ! count ) {
    for ( item=tree->first(); item; item = tree->next(item) ) {
        item->labelfont(face);
    }
}

tree->redraw();}
        tooltip {Toggles bold font for selected items
If nothing selected, all are changed} xywh {734 174 95 16} selection_color 1 labelsize 9
      }
      {fltk3::Button} showselected_button {
        label {Show Selected}
        callback {fprintf(stderr, "--- SELECTED ITEMS\\n");
for ( fltk3::TreeItem *item = tree->first_selected_item();
      item;
      item = tree->next_selected_item(item) ) {
  fprintf(stderr, "\\t%s\\n", item->label() ? item->label() : "???");
}}
        tooltip {Clears the selected items} xywh {829 154 95 16} labelsize 9
      }
      {fltk3::Button} clearselected_button {
        label {Remove Selected}
        callback {fltk3::TreeItem *item=tree->first();
while (item) {
    if ( item->is_selected() ) {
    	if ( tree->remove(item) == -1 ) break;
    	item = tree->first();
    } else {
        item = item->next();
    }
}

tree->redraw();}
        tooltip {Removes the selected items} xywh {829 174 95 16} labelsize 9
      }
      {fltk3::Button} selectall_button {
        label {Select All}
        callback {tree->select_all(0);
tree->redraw();}
        tooltip {Selects all items in the tree} xywh {689 201 95 16} labelsize 9
      }
      {fltk3::Button} deselectall_button {
        label {Deselect All}
        callback {tree->deselect_all(0);
tree->redraw();}
        tooltip {Deselects all items in the tree} xywh {689 221 95 16} labelsize 9
      }
      {fltk3::LightButton} bbbselect_toggle {
        label { Select Bbb}
        callback {// Toggle select of just the Bbb item (not children)
fltk3::TreeItem *bbb = tree->find_item("/Bbb");
if ( !bbb) {
  fltk3::alert("FAIL: Couldn't find item '/Bbb'???");
  return;
}
int onoff = bbbselect_toggle->value();
if ( onoff ) tree->select(bbb);		// select /Bbb
else         tree->deselect(bbb);	// deselect /Bbb}
        tooltip {Toggle selection of just the /Bbb item
(Not children)} xywh {784 201 95 16} selection_color 1 labelsize 9
      }
      {fltk3::LightButton} bbbselect2_toggle {
        label { Select Bbb+}
        callback {// Toggle select of just the Bbb item and its immediate children
fltk3::TreeItem *bbb = tree->find_item("/Bbb");
if ( !bbb) {
  fltk3::alert("FAIL: Couldn't find item '/Bbb'???");
  return;
}
int onoff = bbbselect2_toggle->value();
if ( onoff ) tree->select_all(bbb);		// select /Bbb and its children
else         tree->deselect_all(bbb);	// deselect /Bbb and its children}
        tooltip {Toggle selection of the /Bbb item and its children} xywh {784 221 95 16} selection_color 1 labelsize 9
      }
      {fltk3::LightButton} bbbchild02select_toggle {
        label { Toggle child-02}
        callback {// Toggle select of just the /Bbb/child-02 item
const char *pathname = "/Bbb/child-02";
int onoff = bbbchild02select_toggle->value();
int err = 0;
if ( onoff ) err = tree->select(pathname);
else         err = tree->deselect(pathname);

if ( err == -1 ) {
  fltk3::alert("FAIL: Couldn't find item '%s'",pathname);
  return;
}}
        tooltip {Toggle the single item "/Bbb/child-02" using the item's "pathname".} xywh {784 241 95 16} selection_color 1 labelsize 9
      }
      {fltk3::LightButton} rootselect_toggle {
        label {Select ROOT}
        callback {// Toggle select of ROOT item and its children
fltk3::TreeItem *item = tree->find_item("/ROOT");
if ( !item) {
  fltk3::alert("FAIL: Couldn't find item '/ROOT'???");
  return;
}
int onoff = rootselect_toggle->value();
if ( onoff ) tree->select(item);	// select /ROOT and its children
else         tree->deselect(item);	// deselect /ROOT and its children}
        tooltip {Toggle selection of the ROOT item} xywh {879 201 95 16} selection_color 1 labelsize 9
      }
      {fltk3::LightButton} rootselect2_toggle {
        label {Select ROOT+}
        callback {// Toggle select of ROOT item and its children
fltk3::TreeItem *item = tree->find_item("/ROOT");
if ( !item) {
  fltk3::alert("FAIL: Couldn't find item '/ROOT'???");
  return;
}
int onoff = rootselect2_toggle->value();
if ( onoff ) tree->select_all(item);	// select /ROOT and its children
else         tree->deselect_all(item);	// deselect /ROOT and its children}
        tooltip {Toggle selection of the ROOT item and all children} xywh {879 221 95 16} selection_color 1 labelsize 9
      }
      {fltk3::Box} {} {
        label {New Item Defaults}
        tooltip {These controls only affect the defaults for new items that are created. These test the Fl_Tree_Prefs methods.} xywh {661 312 335 120} box GTK_DOWN_BOX color 47 labelsize 12 align 1
      }
      {fltk3::Button} item_labelfgcolor_button {
        label item_labelfgcolor
        callback {fltk3::Color val = EditColor(tree->item_labelfgcolor());	// Let user edit the color
tree->item_labelfgcolor(val);				// apply modified color to tree
item_labelfgcolor_button->color(val);			// update modified color to button}
        tooltip {Sets the *default* label foreground color for new items created. Does NOT affect existing items.} xywh {828 327 16 16} box DOWN_BOX labelsize 12 align 7
        code0 {o->color(tree->item_labelfgcolor());}
      }
      {fltk3::Button} item_labelbgcolor_button {
        label item_labelbgcolor
        callback {fltk3::Color val = EditColor(tree->item_labelbgcolor());	// Let user edit the color
tree->item_labelbgcolor(val);				// apply modified color to tree
item_labelbgcolor_button->color(val);			// update modified color to button}
        tooltip {Sets the *default* label background color for new items created. Does NOT affect existing items.} xywh {828 345 16 16} box DOWN_BOX labelsize 12 align 7
        code0 {item_labelbgcolor_button->color(tree->item_labelbgcolor());}
      }
      {fltk3::Choice} item_font_choice {
        label {Item label font}
        callback {fltk3::Font val = (fltk3::Font)item_font_choice->value(); // get chooser's current font value
tree->item_labelfont(val);			  // change font in tree}
        tooltip {Sets the default font used for new items created. Does NOT affect existing items.} xywh {828 371 140 21} down_box BORDER_BOX labelsize 12 textsize 12
        code0 {o->value((int)tree->item_labelfont());   // get tree's current font, assign to chooser}
      } {
        MenuItem {} {
          label Helvetica
          xywh {20 20 36 21} labelsize 12
        }
        MenuItem {} {
          label {Helvetica Bold}
          xywh {30 30 36 21} labelsize 12
        }
        MenuItem {} {
          label {Helvetica Italic}
          xywh {45 45 36 21} labelsize 12
        }
        MenuItem {} {
          label {Helvetica Bold Italic}
          xywh {50 50 36 21} labelsize 12
        }
        MenuItem {} {
          label Courier
          xywh {60 60 36 21} labelsize 12
        }
        MenuItem {} {
          label {Courier Bold}
          xywh {70 70 36 21} labelsize 12
        }
        MenuItem {} {
          label {Courier Italic}
          xywh {55 55 36 21} labelsize 12
        }
        MenuItem {} {
          label {Courier Bold Italic}
          xywh {60 60 36 21} labelsize 12
        }
        MenuItem {} {
          label Times
          xywh {70 70 36 21} labelsize 12
        }
        MenuItem {} {
          label {Times Bold}
          xywh {80 80 36 21} labelsize 12
        }
        MenuItem {} {
          label {Times Italic}
          xywh {65 65 36 21} labelsize 12
        }
        MenuItem {} {
          label {Times Bold Italic}
          xywh {70 70 36 21} labelsize 12
        }
        MenuItem {} {
          label Symbol
          xywh {80 80 36 21} labelsize 12
        }
        MenuItem {} {
          label Screen
          xywh {90 90 36 21} labelsize 12
        }
        MenuItem {} {
          label {Screen bold}
          xywh {75 75 36 21} labelsize 12
        }
        MenuItem {} {
          label {Zapf Dingbats}
          xywh {80 80 36 21} labelsize 12
        }
      }
      {fltk3::ValueSlider} item_labelsize_slider {
        label item_labelsize
        user_data tree
        callback {tree->item_labelsize((int)item_labelsize_slider->value());}
        tooltip {Sets the default labelsize used for new items. Does NOT affect existing items.} xywh {828 396 140 16} type Horizontal labelsize 12 align 4 textsize 12
        code0 {o->value((int)tree->item_labelsize());}
        code1 {o->range(1.0, 50.0);}
        code2 {o->step(1.0);}
        code3 {o->color(46); o->selection_color(fltk3::RED);}
      }
    }
    {fltk3::Box} resizer_box {
      xywh {0 263 15 14}
    }
  }
  code {// Initialize Tree
tree->root_label("ROOT");
RebuildTree();
/*tree->show_self();*/} {}
  code {// FLTK stuff

//fltk3::scheme("gtk+");

window->resizable(tree);
window->size_range(window->w(), window->h(), 0, 0);

     if ( tree->when() == fltk3::WHEN_CHANGED ) whenmode_chooser->value(0);
else if ( tree->when() == fltk3::WHEN_RELEASE ) whenmode_chooser->value(1);
else if ( tree->when() == fltk3::WHEN_NEVER   ) whenmode_chooser->value(2);} {}
} 
