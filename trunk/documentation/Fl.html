<html><head><link href="fltk.css" rel="stylesheet" type="text/css">
<title>class Fl</title></head><body>

<h1>class Fl</h1>

This appendix describes all of the <b><tt>fltk::foo()</tt></b>
functions.  These functions mostly are concerned with event handling
and waiting for events. <b><tt>fltk::</tt></b> should be considered a
C++ "namespace". However it is implemented as a class with no
instance variables and only static methods, in order to work with
older C++ compilers that do not handle namespaces.

<center>
<table width=90%>
<tr><td align=left valign=top>
<ul>
<li><a href="#add_check">add_check</a></li>
<li><a href="#add_fd">add_fd</a></li>
<li><a href="#add_handler">add_handler</a></li>
<li><a href="#add_idle">add_idle</a></li>
<li><a href="#add_timeout">add_timeout</a></li>
<li><a href="#awake">awake</a></li>
<li><a href="#belowmouse">belowmouse</a></li>
<li><a href="#check">check</a></li>
<li><a href="#compose">compose</a></li>
<li><a href="#compose_reset">compose_reset</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#damage">damage</a></li>
<li><a href="#display">display</a></li>
</ul>
</td><td align=left valign=top>
<ul>
<li><a href="#dnd">dnd</a></li>
<li><a href="#error">error</a></li>
<li><a href="#event">event</a></li>
<li><a href="#event_button">event_button</a></li>
<li><a href="#event_clicks">event_clicks</a></li>
<li><a href="#event_dx">event_dx</a></li>
<li><a href="#event_dy">event_dy</a></li>
<li><a href="#event_inside">event_inside</a></li>
<li><a href="#event_is_click">event_is_click</a></li>
<li><a href="#event_key">event_key</a></li>
<li><a href="#event_length">event_length</a></li>
<li><a href="#event_state">event_state</a></li>
<li><a href="#event_text">event_text</a></li>
</ul>
</td><td align=left valign=top>
<ul>
<li><a href="#event_x">event_x</a></li>
<li><a href="#event_x_root">event_x_root</a></li>
<li><a href="#event_y">event_y</a></li>
<li><a href="#event_y_root">event_y_root</a></li>
<li><a href="#fatal">fatal</a></li>
<li><a href="#first_window">first_window</a></li>
<li><a href="#first_window_a">first_window_a</a></li>
<li><a href="#flush">flush</a></li>
<li><a href="#focus">focus</a></li>
<li><a href="#get_key_state">get_key_state</a></li>
<li><a href="#get_mouse">get_mouse</a></li>
<li><a href="#gl_visual">gl_visual</a></li>
<li><a href="#has_check">has_check</a></li>
</ul>
</td><td align=left valign=top>
<ul>
<li><a href="#has_idle">has_idle</a></li>
<li><a href="#has_timeout">has_timeout</a></li>
<li><a href="#info">info</a></li>
<li><a href="#key_name">key_name</a></li>
<li><a href="#lock">lock</a></li>
<li><a href="#modal">modal</a></li>
<li><a href="#next_window">next_window</a></li>
<li><a href="#own_colormap">own_colormap</a></li>
<li><a href="#paste">paste</a></li>
<li><a href="#pushed">pushed</a></li>
<li><a href="#ready">ready</a></li>
<li><a href="#redraw">redraw</a></li>
<li><a href="#remove_check">remove_check</a></li>
</ul>
</td><td align=left valign=top>
<ul>
<li><a href="#remove_fd">remove_fd</a></li>
<li><a href="#remove_idle">remove_idle</a></li>
<li><a href="#remove_timeout">remove_timeout</a></li>
<li><a href="#repeat_timeout">repeat_timeout</a></li>
<li><a href="#run">run</a></li>
<li><a href="#test_shortcut">test_shortcut</a></li>
<li><a href="#thread_message">thread_message</a></li>
<li><a href="#unlock">unlock</a></li>
<li><a href="#version">version</a></li>
<li><a href="#visual">visual</a></li>
<li><a href="#wait">wait</a></li>
<li><a href="#warning">warning</a></li>
</ul>
</td></tr>
</table>
</center>

<p>FLTK also provides a number of global functions with
<tt>fltk::xyz</tt> names. The majority of these are concerned with
drawing or graphics state, and are described in the <a
href="drawing.html">Drawing</a> appendix. The others are a set of
modal popup utility functions for asking questions described in the <a
href="utility.html">Utility</a> appendix.

<h2><a name=startup>Startup functions</a></h2>

<h4><a name="version">float fltk::version()</a></h4>

Returns the version number of fltk. This can be compared to the value
of the <tt>fltk::VERSION</tt> macro to see if the shared library of fltk your
program linked with is up to date.

<p>The FLTK version number is stored in a number of compile-time 
constants: 

<ul>
<li><tt>fltk::MAJOR_VERSION</tt> - The major release number, currently 2.</li>
<li><tt>fltk::MINOR_VERSION</tt> - The minor release number, currently 0.</li>
<li><tt>fltk::PATCH_VERSION</tt> - The patch release number, currently 1.</li>
<li><tt>fltk::VERSION</tt> - A combined floating-point version number
of the form M.mmpp where M is the major number, mm is the minor
number, and pp is the patch number, currently 2.0001. </li>
</ul>

<h4><a name="display">void fltk::display(const char *)</a></h4>

Sets the X display to use for all windows.  Actually this just sets
the environment variable $DISPLAY to the passed string, so this only
works before you show() the first window or otherwise open the display,
and does nothing useful under WIN32. 

<h4><a name="visual">int fltk::visual(int)</a></h4>

This call may be useful on multi-visual X servers to change from the
default to a more useful color mode. You must call this before you
show() any windows. The integer argument is an 'or' of the following:

<ul>

<li><tt>fltk::INDEX</tt> indicates that a colormapped visual is ok. This
call will normally fail if a TrueColor visual cannot be found.

<li><tt>fltk::RGB</tt> this value is zero and may be passed to indicate
that <tt>fltk::INDEX</tt> is not wanted.

<li><tt>fltk::RGB8</tt> indicates that the TrueColor visual must have at
least 8 bits of red, green, and blue (Windows calls this "millions of
colors").

<li><tt>fltk::DOUBLE</tt> indicates that hardware accelerated double
buffering is wanted. This will make <a
href="Fl_Double_Window.html">fltk::DoubleBufferWindow</a> work better.

</ul>

This returns true if the system has the capabilities by default or 
FLTK suceeded in turing them on.  Your program will still work even if 
this returns false (it just won't look as good). On non-X systems
this just returns true or false indicating if the system supports the
passed values.

<h4><a name="gl_visual">int fltk::gl_visual(int)</a></h4>

This does the same thing as <a
href="#visual"><tt>fltk::visual(int)</tt></a> but also requires OpenGL
drawing to work. Doing this on X will reduce colormap flashing at the
edges of <a href="Fl_Gl_Window.html"><tt>fltk::GlWindow</tt></a>s when
they are inside regular windows.

<p>See <a href="Fl_Gl_Window.html#mode"><tt>fltk::GlWindow</tt></a>
for a list of additional values for the argument.</p>

<p><i>This function seems to have been renamed</i> <tt>fltk::gl_visual(int)</tt>.

<h4><a name="own_colormap">void fltk::own_colormap()</a></h4>

Makes FLTK use its own colormap.  This may make FLTK display better 
and will reduce conflicts with other programs that want lots of colors. 
However the colors may flash as you move the cursor between windows. 

<p>This does nothing if the current visual is not colormapped.</p>

<h4><a name="screenInfo">const fltk::ScreenInfo& fltk::screenInfo()</a></h4>

Return a structure of information describing the current state of the
screen. Currently this structure contains the following (this may be
added to in the future):

<ul>
<li><tt>int x</tt> left edge of work area
<li><tt>int y</tt> top edge of work area
<li><tt>int w</tt> width of work area
<li><tt>int h</tt> height of work area
<li><tt>int width</tt> full screen width in pixels
<li><tt>int height</tt> full screen height in pixels
<li><tt>int depth</tt> bits per pixel
<li><tt>float dpi_x</tt> pixels per inch horizontally
<li><tt>float dpi_y</tt> pixels per inch vertically
</ul>

<h2><a name=waiting>Waiting for events</a></h2>

<h4><a name="wait">int fltk::wait()</a></h4>

Same as <a href="#wait"><tt>fltk::wait(infinity)</tt></a>.  Call this repeatedly to "run"
your program.  You can also check what happened each time after this
returns, which is quite useful for managing program state.

<h4>int fltk::wait(float time)</h4>

Waits until "something happens", or the given time interval passes.
<i>It can return much sooner than the time if something happens.</i>

<P>What this really does is call all idle callbacks, all elapsed
timeouts, call <a href="#flush"><tt>fltk::flush()</tt></a> to get the screen to update, and
then wait some time (zero if there are idle callbacks, the shortest of
all pending timeouts, or the given time), for any events from the user
or any <a href="#add"><tt>fltk::add_fd()</tt></a> callbacks.  It then handles the events
and calls the callbacks and then returns.

<P>The return value is non-zero if there are any visible windows (this
may change in future versions of fltk).

<P>The return value is whatever the select() system call returned.
This will be negative if there was an error (this will happen on Unix
if a signal happens), zero if the timeout occurred, and positive if
any events or fd's came in.

<p>On Win32 the return value is zero if nothing happened and
<i>time</i> is 0.0.  Otherwise 1 is returned.

<h4><a name="check">int fltk::check()</a></h4>

Same as <a href="#wait"><tt>fltk::wait(0)</tt></a>.  Calling this during a big calculation
will keep the screen up to date and the interface responsive:

<pre>while (!calculation_done()) {
 calculate();
 fltk::check();
 if (user_hit_abort_button()) break;
}</pre>

<h4><a name="ready">int fltk::ready()</a></h4>

This is similar to <a href="#check"><tt>fltk::check()</tt></a> except this does <I>not</I>
call <a href="#flush"><tt>fltk::flush()</tt></a> and thus does not draw anything, and does
not read any events or call any callbacks.  This returns true if <a
href="#check"><tt>fltk::check()</tt></a> would do anything (it will
continue to return true until you call <a href="#check"><tt>fltk::check()</tt></a> or
<a href="#wait"><tt>fltk::wait()</tt></a>).

<p>This is useful if your program is in a state where such callbacks
are illegal, or because the expense of redrawing the screen is much
greater than the expense of your calculation.

<pre>while (!calculation_done()) {
 calculate();
 if (fltk::ready()) {
   do_expensive_cleanup();
   fltk::check();
   if (user_hit_abort_button()) break;
 }
}</pre>

<h4><a name="run">int fltk::run()</a></h4>

Calls <a href="#wait"><tt>fltk::wait()</tt></a> as long as any windows are
not closed. When all the windows are hidden by <a
href="Fl_Window.html#hide"><tt>fltk::Window::hide()</tt></a> (which is
normally called by the user closing them with the close box) this will
return with zero. A program can also exit by having a callback call
<tt>exit()</tt> or <tt>abort()</tt>.

<p>Most fltk programs will end
<tt>main()</tt> with <tt>return fltk::run();</tt>.

<h4><a name="modal">void fltk::modal(fltk::Widget*, bool grab=false);
<br>fltk::Widget* fltk::modal();
<br>bool fltk::grab();
<br>void fltk::exit_modal();
<br>bool fltk::exit_modal_flag();
</a></h4>

First thing: much of the time <a
href="Fl_Window.html#exec"><tt>fltk::Window::exec()</tt></a> will do what
you want, so try using that.

<p>This function sets the passed widget as the "modal widget". All
user events are directed to it or a child of it, preventing the user
from messing with other widgets. The modal widget does not have to be
visible or even a child of an fltk::Window for this to work (but if it
not visible, fltk::event_x() and fltk::event_y() are meaningless, use
fltk::event_x_root() and fltk::event_y_root()).

<p><tt>fltk::exit_modal()</tt> sets the
<tt>fltk::exit_modal_flag()</tt>. This may be used by user callbacks to
cancel modal state. The flag is also set by the destruction or hiding
of the modal widget, and on Windows by other applications taking the
focus when <i>grab</i> is on.

<p>The calling code then loops calling <a
href="#wait"><tt>fltk::wait()</tt></a> until fltk::exit_modal_flag() is set
or you otherwise decide to get out of the modal state. It is the
calling code's responsibility to monitor this flag and restore the
modal widget to it's previous value when it turns on.

<p><tt>fltk::modal()</tt> returns the current modal widget, or null if
there isn't one, and <tt>fltk::grab()</tt> returns the current value of
grab (this is always false if the modal widget is null). It is useful
to test these in timeouts and file descriptor callbacks in order to
block actions that should not happen while the modal window is up. You
also need these in order to save and restore the modal state.

<p><i>grab</i> indicates that the modal widget should get events from
anywhere on the screen. This is done by messing with the window
system.  If <tt>fltk::exit_modal()</tt> is called in response to an
fltk::PUSH event (rather than waiting for the drag or release event) fltk
will "repost" the event so that it is handled after modal state is
exited. This may also be done for keystrokes in the future.
On both X and WIN32 <i>grab</i> will not work unless you have some
visible window because the system interface needs a visible window id.
On X be careful that your program does not enter an infinite loop 
while <tt>grab()</tt> is on, it will lock up your screen!</i>

<h4><a name="add_timeout">void fltk::add_timeout(float t, void (*cb)(void*),void*v=0)</a></h4>

Add a one-shot timeout callback.  The function will be called by
<a href="#wait"><tt>fltk::wait()</tt></a> at <i>t</i> seconds after this function is called.
The optional <tt>void*</tt> argument is passed to the callback.

<h4><a name="repeat_timeout">void fltk::repeat_timeout(float t, void (*cb)(void*),void*v=0)</a></h4>

Inside a timeout callback you can call this to add another timeout.
Rather than the time being measured from "now", it is measured from
when the system call elapsed that caused this timeout to be called.  This
will result in far more accurate spacing of the timeout callbacks, it
also has slightly less system call overhead.  (It will also use all
your machine time if your timeout code and fltk's overhead take more
than <i>t</i> seconds, as the real timeout will be reduced to zero).

<p>It is undefined what this does if called from outside a timeout
callback.

<P>This code will print &quot;TICK&quot; each second on stdout, with a
fair degree of accuracy:

<pre>void callback(void*) {
  printf(&quot;TICK\n&quot;);
  fltk::repeat_timeout(1.0,callback);
}

main() {
  fltk::add_timeout(1.0,callback);
  for (;;) fltk::wait();
}</pre>

<h4><a name="has_timeout">int fltk::has_timeout(void (*cb)(void*), void* = 0)</a></h4>

Returns true if the timeout exists and has not been called yet.

<h4><a name="remove_timeout">void fltk::remove_timeout(void (*cb)(void*), void* = 0)</a></h4>

Removes a timeout callback. It is harmless to remove a timeout
callback that no longer exists.

<h4><a name="add_check">void fltk::add_check(void (*cb)(void*),void*v=0)</a></h4>

Fltk will call this callback just before it flushes the display and
waits for events.  This is different than an idle callback because it
is only called once, then fltk calls the system and tells it not to
return until an event happens.

<p>This can be used by code that wants to monitor the
application's state, such as to keep a display up to date. The
advantage of using a check callback is that it is called only when no
events are pending. If events are coming in quickly, whole blocks of
them will be processed before this is called once. This can save
significant time and avoid the application falling behind the events.

<p>Sample code:

<pre>bool state_changed; // anything that changes the display turns this on

void callback(void*) {
  if (!state_changed) return;
  state_changed = false;
  do_expensive_calculation();
  widget->redraw();
}

main() {
  fltk::add_check(1.0,callback);
  return fltk::run();
}</pre>

<h4><a name="has_check">int fltk::has_check(void (*cb)(void*), void* = 0)</a></h4>

Returns true if the check exists and has not been called yet.

<h4><a name="remove_check">void fltk::remove_check(void (*cb)(void*), void* = 0)</a></h4>

Removes a check callback. It is harmless to remove a check
callback that does not exist.

<h4><a name="add_fd">void fltk::add_fd(int fd, void (*cb)(int, void*), void* = 0)
<br>void fltk::add_fd(int fd, int when, void (*cb)(int, void*), void* = 0)</a></h4>

Add file descriptor <tt>fd</tt> to listen to.  When the <tt>fd</tt>
becomes ready for reading <a href="#wait"><tt>fltk::wait()</tt></a> will
call the callback and then return.  The callback is passed the
<tt>fd</tt> and the arbitrary <tt>void*</tt> argument.

<P>The second version takes a <tt>when</tt> bitfield to indicate when
the callback should be done. You can or these together to make the
callback be called for multiple conditions:

<ul>
<li><tt>fltk::READ</tt> - Call the callback when there is data to be read.</li>
<li><tt>fltk::WRITE</tt> - Call the callback when data can be written without blocking.</li>
<li><tt>fltk::EXCEPT</tt> - Call the callback if an exception occurs on the file.</li>
</ul>

<p>Under UNIX <i>any</i> file descriptor can be monitored (files,
devices, pipes, sockets, etc.) Due to limitations in Microsoft
Windows, WIN32 applications can only monitor sockets (? and is the
<i>when</i> value ignored?)

<h4><a name="remove_fd">void fltk::remove_fd(int fd, int when = -1)</a></h4>

Remove <i>all</i> the callbacks (ie for all different <i>when</i>
values) for the given file descriptor. It is harmless to call this if
there are no callbacks for the file descriptor. If <i>when</i> is
given then those bits are removed from each callback for the file
descriptor, and the callback removed only if all of the bits turn off.

<h4><a name="add_idle">fltk::add_idle(void (*cb)(void*), void*)</a></h4>

Adds a callback function that is called every time by
<a href="#wait"><tt>fltk::wait()</tt></a> and also makes it act as though the timeout is
zero (this makes <a href="#wait"><tt>fltk::wait()</tt></a> return immediately, so if it is
in a loop it is called repeatedly, and thus the idle fucntion is
called repeatedly).  The idle function can be used to get background
processing done.

<P>You can have multiple idle callbacks. To remove an idle callback use <a
href="#remove_idle"><tt>fltk::remove_idle()</tt></a>.

<P><a href="#wait"><tt>fltk::wait()</tt></a> and <a
href="#check"><tt>fltk::check()</tt></a> call idle callbacks, but
<a href="#ready"><tt>fltk::ready()</tt></a> does not.

<P>The idle callback can call any FLTK functions, including <a
href="#wait"><tt>fltk::wait()</tt></a>, <a
href="#check"><tt>fltk::check()</tt></a>, and <a
href="#ready"><tt>fltk::ready()</tt></a>.  Fltk will not recursively call
the idle callback.

<h4><a name="has_idle">int fltk::has_idle(void (*cb)(void*), void* = 0)</a></h4>

Returns true if the specified idle callback is currently installed.

<h4><a name="remove_idle">void fltk::remove_idle(void (*cb)(void*), void* = 0)</a></h4>

Removes the specified idle callback, if it is installed.

<h2><a name=flredraw>Redrawing</a></h2>

<h4><a name="damage">int fltk::damage()</a></h4>

True if any <a
href="Fl_Widget.html#redraw"><tt>fltk::Widget::redraw()</tt></a> calls have
been done since the last <a href="#flush"><tt>flush()</tt></a>.

<h4><a name="redraw">void fltk::redraw()</a></h4>

Redraws all widgets. This is a good idea if you have made global
changes to the styles.

<h4><a name="flush">void fltk::flush()</a></h4>

Causes all the windows that need it to be redrawn and graphics forced 
out through the pipes.  This is what <tt>wait()</tt> does before 
looking for events. 

<h4><a name="first_window">fltk::Window *fltk::first_window()</a></h4>

Returns the id of some visible() window. If there is more than one,
the last one to receive an event is returned. This is useful for
setting the <a href="Fl_Window.html#child_of">fltk::Window::child_of()</a>
for dialog boxes that are used in multiple places in your program, and
is used by <a href="Fl_Window.html#exec">fltk::Window::exec()</a> if no
other parent is specified.

<h4><a name="first_window_a">void fltk::first_window(fltk::Window*)</a></h4>

If this window is visible, this removes it from wherever it is in the
list and inserts it at the top, as though it received an event. This
can be used to change the parent of dialog boxes run by <a
href="Fl_Window.html#exec">fltk::Window::exec()</a> or <a
href="utility.html#ask">fltk::ask()</a>.

<h4><a name="next_window">fltk::Window *fltk::next_window(fltk::Window *)</a></h4>

Returns the next visible() top-level window, returns NULL after the
last one.  You can use this and first_window() to iterate through all
the visible windows.

<h2><a name=events>Events</a></h2>

<h4><a name="event">int fltk::event()</a></h4>

Returns the most recent event handled, such as <tt>fltk::PUSH</tt> or
<tt>fltk::KEY</tt>. This is useful so callbacks can find out why
they were called.

<h4><a name="event_x">int fltk::event_x()</a>
<br><a name="event_y">int fltk::event_y()</a></h4>

Returns the mouse position of the event relative to the <tt>fltk::Window</tt>
it was passed to. 

<h4><a name="event_dx">int fltk::event_dx()</a>
<br><a name="event_dy">int fltk::event_dy()</a></h4>

For <tt>fltk::MOUSEWHEEL</tt> events this is how many clicks the user
moved in the x and y directions (currently dx is always zero).

<h4><a name="event_x_root">int fltk::event_x_root()
<br><a name="event_y_root">int fltk::event_y_root()</a></a></h4>

Returns the mouse position on the screen of the event.  To find the 
absolute position of an <tt>fltk::Window</tt> on the screen, use the 
difference between <tt>event_x_root(),event_y_root()</tt> and <tt>
event_x(),event_y()</tt>. 

<h4><a name="event_clicks">int fltk::event_clicks()
<br>void fltk::event_clicks(int)</a></h4>

Returns the number of times the last mouse button or keyboard key
was pushed while <a href="#event_is_click">fltk::event_is_click()</a>
was true.

<p>For a normal <tt>fltk::PUSH</tt> this is zero, if the user
"double-clicks" this is one, and it is N-1 for each subsequent
click. This is also used to see if the keyboard is repeating, if the
most recent <tt>fltk::KEY</tt> was caused by a repeating key this is
non-zero, and is N-1 for N repeats of the key.

<p>Setting this value with <tt>fltk::event_clicks(n)</tt> can be used to
make callbacks think things were (or were not) double-clicked.

<h4><a name="event_is_click">int fltk::event_is_click()
<br>void fltk::event_is_click(0)</a></h4>

This is true if the time and mouse movement since the last
<tt>fltk::PUSH</tt> or <tt>fltk::KEY</tt> is short enough that the user is
intending to "click". After enough time or after enough mouse movement
this turns off.

<p>The main use of this is to decide whether to increment <a
href="#event_clicks">fltk::event_clicks()</a> when the user
clicks the mouse. But you can also test this on a <tt>fltk::RELEASE</tt>
or <tt>fltk::KEYUP</tt> event to decide if the user clicked quickly,
versus holding the mouse or key down.

<p>You can set this to zero with <tt>fltk::event_is_click(0)</tt>, this
can be used to prevent the next mouse click from being considered a
double click. It is not possible to set this true because the saved
time and position are inaccessible.

<h4><a name="event_button">int fltk::event_button()</a></h4>

Returns which mouse button was last pushed or released. You can use
numerical constants or these values:

<ul>
<li><tt>fltk::LEFT_MOUSE</tt> 1</li>
<li><tt>fltk::MIDDLE_MOUSE</tt> 2</li>
<li><tt>fltk::RIGHT_MOUSE</tt> 3</li>
</ul>

<h4><a name="event_state">ulong fltk::event_state()
<br>bool fltk::event_state(ulong)</a></h4>

This is a bitfield of what shift states were on and what mouse buttons 
were held down during the most recent event.  The second version 
returns true if any of the passed bits are turned on.  The legal 
bits are: 

<UL>
<LI><TT>fltk::SHIFT</TT> - One of the shift keys is down. </LI>
<LI><TT>fltk::CAPS_LOCK</TT> - The caps lock is on. </LI>
<LI><TT>fltk::CTRL</TT> - One of the ctrl keys is down. </LI>
<LI><TT>fltk::ALT</TT> - One of the alt keys is down. </LI>
<LI><TT>fltk::NUM_LOCK</TT> - The num lock is on. </LI>
<LI><TT>fltk::WIN</TT> - One of the Windows keys is down. </LI>
<LI><TT>fltk::SCROLL_LOCK</TT> - The scroll lock is on. </LI>
<LI><TT>fltk::BUTTON1</TT> - Mouse button 1 is pushed. </LI>
<LI><TT>fltk::BUTTON2</TT> - Mouse button 2 is pushed. </LI>
<LI><TT>fltk::BUTTON3</TT> - Mouse button 3 is pushed. </LI>
<LI><TT>fltk::BUTTONS</TT> - Any mouse button is pushed. </LI>
<LI><TT>fltk::BUTTON(n)</TT> - Mouse button n is pushed. </LI>
</UL>

X servers do not agree on shift states, so fltk::NUM_LOCK, fltk::WIN, and
fltk::SCROLL_LOCK may not work.  The values were selected to match the
XFree86 server on Linux.  In addition there is a bug in the way X
works so that the shift state is not correctly reported until the
first event <I>after</I> the shift key is pressed or released.

<h4><a name="event_key">int fltk::event_key()</a></h4>

Returns which key on the keyboard was last pushed. <tt>fltk::FOCUS</tt>
events produced by the system, and mouse button events, set this to
values that cannot be confused with keys, to allow a widget to
determine if the focus is being changed due to a keystroke and what
keystroke that was.

<p>Keys are identified by the <I>unshifted</I> values. FLTK defines a 
set of symbols that should work on most modern machines for every key 
on the keyboard:</p>

<ul>

<li><tt>'a'</tt> through <tt>'z'</tt>,
<tt>'0'</tt> through <tt>'9'</tt>,
<tt>'`'</tt>,
<tt>'-'</tt>,
<tt>'='</tt>,
<tt>'['</tt>,
<tt>']'</tt>,
<tt>'\\'</tt>,
<tt>';'</tt>,
<tt>'\''</tt>,
<tt>','</tt>,
<tt>'.'</tt>,
<tt>'/'</tt> -
All keys on the main keyboard producing a printable ASCII
character use the value of that ASCII character (as though shift,
ctrl, and caps lock were not on).

<li><tt>fltk::Space</tt> - The space key, same as <tt>'&nbsp;'</tt> or 32.
<li><tt>fltk::BackSpace</tt> - The backspace key.</li>
<li><tt>fltk::Tab</tt> - The tab key.</li>
<li><tt>fltk::Enter</tt> - The enter key.</li>
<li><tt>fltk::Pause</tt> - The pause key.</li>
<li><tt>fltk::Scroll_Lock</tt> - The scroll lock key.</li>
<li><tt>fltk::Escape</tt> - The escape key.</li>
<li><tt>fltk::Home</tt> - The home key.</li>
<li><tt>fltk::Left</tt> - The left arrow key.</li>
<li><tt>fltk::Up</tt> - The up arrow key.</li>
<li><tt>fltk::Right</tt> - The right arrow key.</li>
<li><tt>fltk::Down</tt> - The down arrow key.</li>
<li><tt>fltk::Page_Up</tt> - The page-up key.</li>
<li><tt>fltk::Page_Down</tt> - The page-down key.</li>
<li><tt>fltk::End</tt> - The end key.</li>
<li><tt>fltk::Print</tt> - The print (or print-screen) key.</li>
<li><tt>fltk::Insert</tt> - The insert key.</li>
<li><tt>fltk::Menu</tt> - The menu key.</li>
<li><tt>fltk::Num_Lock</tt> - The num lock key.</li>
<li><tt>fltk::KP(c)</tt> - One of the keypad numbers, for instance
<tt>fltk::KP('5')</tt> is the 5 key</li>
<li><tt>fltk::KP_Enter</tt> - Same as <tt>fltk::KP('\r')</tt>, the enter key on the keypad.</li>
<li><tt>fltk::KP_Last</tt> - All keypad keys are in the range <tt>fltk::KP(0),fltk::KP_Last</tt></li>
<li><tt>fltk::F(n)</tt> - A numbered function key, for instance
<tt>fltk::F(2)</tt> is the F2 key.</li>
<li><tt>fltk::F_Last</tt> - All function keys are in the range <tt>fltk::F(0),fltk::F_Last</tt></li>
<li><tt>fltk::Shift_L</tt> - The lefthand shift key.</li>
<li><tt>fltk::Shift_R</tt> - The righthand shift key.</li>
<li><tt>fltk::Control_L</tt> - The lefthand control key.</li>
<li><tt>fltk::Control_R</tt> - The righthand control key.</li>
<li><tt>fltk::Caps_Lock</tt> - The caps lock key.</li>
<li><tt>fltk::Alt_L</tt> - The left alt key.</li>
<li><tt>fltk::Alt_R</tt> - The right alt key.</li>
<li><tt>fltk::Win_L</tt> - The left Windows key.</li>
<li><tt>fltk::Win_R</tt> - The right Windows key.</li>
<li><tt>fltk::Delete</tt> - The delete key.</li>
<li>On X systems any unrecognized keys are reported as their X keysym
value.</li>
</ul>

<h4><a name="event_key_state">bool fltk::event_key_state(int key)</a></h4>

<p>Returns true if the given key was held down (or pressed)
<I>during</I> the last event.  This is constant until the next event
is read from the server. The possible values for the key are listed
above.

<p>On Win32 <tt>fltk::event_key_state(fltk::KP_Enter)</tt> does not work.

<h4><a name="event_text">char *fltk::event_text()</a></h4>

Returns the ASCII text (in the future this may be UTF-8) produced by 
the last <tt>fltk::KEY</tt> or <tt>fltk::PASTE</tt> or possibly other 
event.  A zero-length string is returned for any keyboard function keys 
that do not produce text. This pointer points at a static buffer and is 
only valid until the next event is processed. 

<p>Under X this is the result of calling <tt>XLookupString()</tt>.</p>

<h4><a name="event_length">char *fltk::event_length()</a></h4>

Returns the length of the text in <a
href="#event_text"><tt>fltk::event_text()</tt></a>.  There will always be
a nul at this position in the text.  However there may be a nul before
that if the keystroke translates to a nul character or you paste a nul
character.

<h4><a name="event_inside">int fltk::event_inside(int x, int y, int w, int h)</a></h4>

Returns non-zero if the current <a
href="#event_x"><tt>fltk::event_x()</tt></a>
and <a href="#event_y"><tt>fltk::event_y()</tt></a>
put it inside the passed box.  You should always call this rather than
doing your own comparison so you are consistent about edge effects.

<h4><a name="test_shortcut">int fltk::test_shortcut(int shortcut)</a></h4>

Test the current event, which must be an <tt>fltk::KEY</tt> or <tt>
fltk::SHORTCUT</tt>, against a shortcut value (described in <a
href="Fl_Widget.html#shortcut"><tt>fltk::Button</tt></a>).
Returns non-zero if there is a match.  Not to be confused with <a
href="Fl_Widget.html#test_shortcut"><tt>fltk::Widget::test_shortcut()</tt></a>.

<h4><a name="key_name">const char* fltk::key_name(int shortcut)</a></h4>

Unparse a key name (as returned by <a
href="#event_key"><tt>fltk::event_key()</tt></a>) or a shortcut value
(as used by <a href="Fl_Widget.html#shortcut"><tt>fltk::Button</tt></a>
or <a href="Fl_Menu_Item.html"><tt>Fl_Menu_Item</tt></a>) into a
human-readable string like "Alt+N".  If the shortcut is zero an empty
string is returned. <i>The return value points at a static buffer that
is overwritten with each call.</i>

<h4><a name="compose">int fltk::compose(int&amp; del)</a></h4>

<p>Use of this function is very simple.  Any text editing widget should
call this for each <tt>fltk::KEY</tt> event.

<p>If <tt>true</tt> is returned, then it has modified the <a
href="#event_text"><tt>fltk::event_text()</tt></a> and <a
href="#event_length"><tt>fltk::event_length()</tt></a> to a set of
<i>bytes</i> to insert (it may be of zero length!).  It will also set
the <i>del</i> parameter to the number of <i>bytes</i> to the left of
the cursor to delete, this is used to delete the results of the
previous call to fltk::compose().

<p>If <tt>false</tt> is returned, the keys should be treated as
function keys.  You could insert the text anyways, if you don't know
what else to do, <i>del</i> is set to zero and the <a
href="#event_text"><tt>fltk::event_text()</tt></a> and <a
href="#event_length"><tt>fltk::event_length()</tt></a> are left unchanged,
length is zero for any function keys.

<p>Though the current implementation returns immediately, future
versions may take quite awhile, as they may pop up a window or do
other user-interface things to allow characters to be selected.

<h4><a name="compose_reset">int fltk::compose_reset()</a></h4>

<p>If the user moves the cursor, be sure to call fltk::compose_reset().
The next call to fltk::compose() will start out in an initial state.  In
particular it will not set "del" to non-zero.  This call is very fast
so it is ok to call it many times and in many places.

<h4><a name="get_key_state">int fltk::get_key_state(int)</a></h4>

<p>Returns true if the given key is held down <I> now</I>.  Under X
this requires a round-trip to the server and is <I> much</I> slower
than <a href="#event_key_state"><tt>fltk::event_key_state(int)</tt></a>.</p>

<p>On Win32 <tt>fltk::get_key_state(fltk::KP_Enter)</tt> does not work.

<h4><a name="get_mouse">void fltk::get_mouse(int &amp;x, int &amp;y)</a></h4>

Return where the mouse is on the screen by doing a round-trip query to
the server.  You should use <a
href="#event_x_root"><tt>fltk::event_x_root()</tt></a> and <a
href="#event_y_root"><tt>fltk::event_y_root()</tt></a> if possible, but
this is necessary if you are not sure if a mouse event has been
processed recently (such as to position your first window).  If the
display is not open, this will open it.

<h4><a name="add_handler">void fltk::add_handler(int (*f)(int))</a></h4>

Install a function to parse unrecognized events.  If FLTK cannot 
figure out what to do with an event, it calls each of these functions 
(most recent first) until one of them returns non-zero.  If none of 
them returns non zero then the event is ignored.

<p>Currently there are only two uses for this:

<p>1. If there is a keystroke that no widgets are interested in, this
is called with <tt>fltk::SHORTCUT</tt>. You can use this to implement
global shortcut keys.

<p>2. On X, if FLTK does not recognize an X event or the window id the
event is sent to, this is called with zero. You can then use <a
href="x.html#xevent">system specific code</a> to access the event
data and figure out what to do. (this is not done on Win32 due to the
<i>enormous</i> number of bogus events sent, it was much to slow to
search the handler list for every one).

<p>Ignore any other values this is called with. We have not figured
out what the rules for these are yet.

<h4><a name="belowmouse">fltk::Widget* fltk::belowmouse() const</a></h4>

Get the widget that is below the mouse. This is the last widget to
respond to an <tt>fltk::ENTER</tt> event as long as the mouse is still
pointing at it. This is for highlighting buttons and bringing up
tooltips. It is not used to send <tt>fltk::PUSH</tt> or <tt> fltk::MOVE</tt>
directly, for several obscure reasons, but those events typically go
to this widget.

<h4>void fltk::belowmouse(fltk::Widget*)</a></h4>

<p>Change the <a href="#belowmouse"><tt>fltk::belowmouse()</tt></a>
widget, the previous one and all parents (that don't contain the new
widget) are sent <tt>fltk::LEAVE</tt> events.  Changing this does
<I>not</I> send <tt>fltk::ENTER</tt> to this or any widget, because
sending <tt>fltk::ENTER</tt> is supposed to <I>test</I> if the widget
wants the mouse (by it returning non-zero from <tt>handle()</tt>).</p>

<h4><a name="pushed">fltk::Widget* fltk::pushed() const;</a></h4>

Get the widget that is being pushed. <tt>fltk::DRAG</tt> or <tt>
fltk::RELEASE</tt> (and any more <tt>fltk::PUSH</tt>) events will be sent to 
this widget. This is null if no mouse button is being held down, or if
no widget responded to the <tt>fltk::PUSH</tt> event.

<h4>void fltk::pushed(fltk::Widget*)</a></h4>

<p>Change the <a href="#pushed"><tt>fltk::pushed()</tt></a> widget, the
previous one and all parents (that don't contain the new widget) are
sent <tt>fltk::RELEASE</tt> events.  Changing this does <I>not</I> send
<tt>fltk::PUSH</tt> to this or any widget, because sending
<tt>fltk::PUSH</tt> is supposed to <I>test</I> if the widget wants the
mouse (by it returning non-zero from <tt> handle()</tt>).</p>

<h4><a name="focus">fltk::Widget* fltk::focus() const;</a></h4>

Returns the widgets that will receive <tt>fltk::KEY</tt>
events. This is NULL if the application does not have focus now, or if
no widgets accepted focus.

<h4>void fltk::focus(fltk::Widget *)</a></h4>

Change <a href="#focus"><tt>fltk::focus()</tt></a> to the given widget,
the previous widget and all parents (that don't contain the new
widget) are sent <tt>fltk::UNFOCUS</tt> events, the new widget and all
parents that don't contain the old widget are sent <tt>fltk::FOCUS</tt>
events. <tt>fltk::focus()</tt> is set whether or not the applicaton has the
focus or if the widgets accept the focus. You may want to use <a
href="Fl_Widget.html#take_focus">fltk::Widget::take_focus()</a> instead, it
will test first.

<h2><a name=copypaste>Copy, Paste, and Drag &amp; Drop</a></h2>

<h4><a name="copy">void fltk::copy(const char *stuff, int len, bool clipboard=false)</a></h4>

Change the current selection.  The block of text is 
copied to an internal buffer by FLTK (be careful if doing this in 
response to an <tt>fltk::PASTE</tt> as this <I>may</I> be the same buffer 
returned by <tt>event_text()</tt>).

<p>The block of text may be retrieved (from this program or whatever
program last set it) with <a href="#paste"><tt>fltk::paste()</tt></a>.

<p>There are actually two buffers. If <i>clipboard</i> is true then
the text goes into the user-visible selection that is moved around
with cut/copy/paste commands (on X this is the CLIPBOARD
selection). If <i>clipboard</i> is false then the text goes into a
less-visible buffer used for temporarily selecting text with the mouse
and for drag & drop (on X this is the XA_PRIMARY selection).

<p><I>Copying the buffer every time the selection is changed is 
obviously wasteful, especially for large selections.  An interface will 
probably be added in a future version to allow the selection to be made 
by a callback function.  The current interface will be emulated on top 
of this.</I>

<h4><a name="paste">void fltk::paste(fltk::Widget *receiver, bool clipboard = false)</a></h4>

This is what a widget does when a "paste" command (like Ctrl+V or the
middle mouse click) is done to it.  Cause an <a
href="events.html#PASTE"><tt>fltk::PASTE</tt></a> event to be sent to
the <i>receiver</i> with the contents of the current selection in the
<a href="#event_text"><tt>fltk::event_text()</tt></a>. The selection can
be set by <a href="#copy"><tt>fltk::copy()</tt></a>.

<p>There are actually two buffers. If <i>clipboard</i> is true then
the text is from the user-visible selection that is moved around
with cut/copy/paste commands (on X this is the CLIPBOARD
selection). If <i>clipboard</i> is false then the text goes into a
less-visible buffer used for temporarily selecting text with the mouse
and for drag & drop (on X this is the XA_PRIMARY selection).

<p>The reciever should be prepared to be called <I>directly</I> by
this, or for it to happen <I>later</I>, or possibly <I>not at all</I>.
This allows the window system to take as long as necessary to retrieve
the paste buffer (or even to screw up completely) without complex and
error-prone synchronization code most toolkits require.

<h4><a name="dnd">bool fltk::dnd()</a></h4>

Drag and drop the data set by the most recent <a
href="#copy"><tt>fltk::copy()</tt></a> (with the <i>clipboard</i>
argument false). Returns true if the data was dropped on something
that accepted it.

<p>By default only blocks of text are dragged. You can use <a
href="x.html#dnd">system-specific variables</a> to change the type of
data.

<h2><a name=fmultithread>Multithreading</a></h2>

<h4><a name="lock">void fltk::lock();</a></h4>

Blocks the current thread until it can safely access FLTK widgets and
data. Child threads should call this method prior to updating any
widgets or accessing data. The main thread must call
<tt>fltk::lock()</tt> to initialize the threading support in FLTK before
calling <a href="#wait"><tt>fltk::wait()</tt></a> or <a
href="#run"><tt>fltk::run()</tt></a>.

<p>Child threads must call <a href="#unlock"><tt>fltk::unlock()</tt></a>
when they are done accessing FLTK. They may want to call <a
href="#awake"><tt>fltk::awake()</tt></a> first if the display needs to
change.

<p>This is a "recursive lock". If you call <tt>fltk::lock()</tt> more
than once, the subsequent calls return immediately. But you must call
<tt>fltk::unlock()</tt> the same number of times as you called
<tt>fltk::lock()</tt> before the lock is released.

<p>When the <a href="#wait"><tt>wait()</tt></a> method is waiting for
input or timeouts, child threads are given access to FLTK. Similarly,
when the main thread receives events and needs to do processing, it
will wait until all child threads have called <a
href=#unlock><tt>unlock()</tt></a> before processing the events and
doing callbacks.

<p>See the file <tt>&lt;fltk/Threads.h&gt;</tt> for a simple
portable recursive lock object you can use in your own code for
locking other objects. However there is no requirement that you use
this, you can use pthreads or any other library that is compatable
with your system.

<h4><a name="unlock">void fltk::unlock();</a></h4>

Releases the lock that was set using the <a
href="#lock"><tt>fltk::lock()</tt></a> method. Child threads should call
this method as soon as they are finished accessing FLTK. If some other
thread is waiting for <tt>fltk::lock()</tt> to return, it will get
control.

<h4><a name="awake">void fltk::awake(void* message = 0);</a></h4>

Make the main thread (the one that is calling <a
href="#wait"><tt>fltk::wait()</tt></a>) wake up. The main purpose of
this is to get the main thread to redraw the screen, but it will
also cause <a href="#wait"><tt>fltk::wait()</tt></a> to return so the
program's code can do something.

<p>Due to obscure race problems you must call this <i>after</i> you
call <a href="#unlock"><tt>fltk::unlock()</tt></a>. If you call this
while things are locked both the X and Win32 implementations can deadlock.

<p>The <i>message</i> argument can be retrieved by the other thread
using <a href="#thread_message"><tt>fltk::thread_message()</tt></a>.

<h4><a name="thread_message">void* thread_message();</a></h4>

Returns an argument sent to an <a href="#awake"><tt>fltk::awake()</tt></a>
call, or returns null if none. <i>The current implementation
only has a one-entry queue and only returns the most recent value!</i>

<h2><a name=errors>Errors</a></h2>

<h4><a name="warning">void (*fltk::warning)(const char *, ...)</a>
<br><a name="error">void (*fltk::error)(const char *, ...)</a>
<br><a name="fatal">void (*fltk::fatal)(const char *, ...)</a></h4>

FLTK will call these to print messages when unexpected conditions 
occur.

<p><tt>fltk::warning</tt> means that there was a recoverable problem,
the display may be messed up but the user can probably keep working.
(all X protocol errors call this).

<p><tt>fltk::error</tt> means there is a recoverable error, but the
display is so messed up it is unlikely the user can continue (very
little calls this now).

<p><tt>fltk::fatal</tt> must not return, as FLTK is in an unusable
state, however your version may be able to use <tt>longjmp</tt> or an
exception to continue, as long as it does not call FLTK again.</p>

<p>The default versions on Unix print messages to stderr, while on
Windows they use <tt>MessageBox()</tt>. <tt>fltk::error</tt> and
<tt>fltk::fatal</tt> call <tt>abort()</tt>. You can override the
behavior by setting the function pointers to your own routines.

</body></html>
