<HTML><BODY>
<HR break>
<H2><A name=Fl_Valuator>class Fl_Valuator</A></H2>
<HR>
<H3>Class Hierarchy</H3>
<UL>
<PRE>
<A href=Fl_Widget.html#Fl_Widget>Fl_Widget</A>
   |
   +----<B>Fl_Valuator</B>
           |
           +----<A href=Fl_Adjuster.html#Fl_Adjuster>Fl_Adjuster</A>, <A href=Fl_Counter.html#Fl_Counter>Fl_Counter</A>, <A href=Fl_Dial.html#Fl_Dial>Fl_Dial</A>, <A href=Fl_Roller.html#Fl_Roller>Fl_Roller</A>,
                <A href=Fl_Slider.html#Fl_Slider>Fl_Slider</A>, <A href=Fl_Value_Input.html#Fl_Value_Input>Fl_Value_Input</A>, <A href=Fl_Value_Output.html#Fl_Value_Output>Fl_Value_Output</A>,
</PRE>
</UL>
<H3>Include Files</H3>
<UL>
<PRE>
#include &lt;fltk/Fl_Valuator.h&gt;
</PRE>
</UL>
<H3>Description</H3>
 The <TT>Fl_Valuator</TT> class controls a single floating-point value 
and provides a consistent interface to set the <a
 href=#Fl_Valuator.value>value()</a>, <a
 href=#Fl_Valuator.range>range()</a>, and <a href=#Fl_Valuator.step>step()</a>, 
and insures that callbacks are done the same for every object. 
<P>There are probably more of these classes in FLTK than any others: </P>
<P ALIGN=CENTER><IMG src=valuators.gif></P>
<P>In the above diagram each box surrounds an actual subclass.  These 
are further differentiated by setting the <A href=Fl_Widget.html#type><TT>
type()</TT></A> of the widget to the symbolic value labeling the 
widget.  The ones labelled &quot;0&quot; are the default versions with a <TT>
type(0)</TT>.  For consistency the symbol <TT>FL_VERTICAL</TT> is 
defined as zero.</P>
<H3>Methods</H3>
<CENTER>
<TABLE width=90%>
<TR><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Valuator.Fl_Valuator>Fl_Valuator</A></LI>
<LI><A href=#Fl_Valuator.~Fl_Valuator>~Fl_Valuator</A></LI>
<LI><A href=#Fl_Valuator.clamp>clamp</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Valuator.format>format</A></LI>
<LI><A href=#Fl_Valuator.increment>increment</A></LI>
<LI><A href=#Fl_Valuator.linesize>linesize</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Valuator.maximum>maximum</A></LI>
<LI><A href=#Fl_Valuator.minimum>minimum</A></LI>
<LI><A href=#Fl_Valuator.pagesize>pagesize</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Valuator.range>range</A></LI>
<LI><A href=#Fl_Valuator.round>round</A></LI>
<LI><A href=#Fl_Valuator.set_changed>set_changed</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Valuator.step>step</A></LI>
<LI><A href=#Fl_Valuator.value>value</A></LI>
</UL>
</TD></TR>
</TABLE>
</CENTER>
<H4><A name=Fl_Valuator.Fl_Valuator>Fl_Valuator::Fl_Valuator(int x, int 
y, int w, int h, const char *label = 0)</A></H4>
 Creates a new <TT>Fl_Valuator</TT> widget using the given position, 
size, and label string. The default boxtype is <TT>FL_NO_BOX</TT>. 
<H4><A name=Fl_Valuator.~Fl_Valuator>virtual Fl_Valuator::~Fl_Valuator()</A>
</H4>
 Destroys the valuator. 
<H4><A name=Fl_Valuator.value>double Fl_Valuator::value() const
<BR> int Fl_Valuator::value(double)</A></H4>
 Get or set the current value.  The new value is <I>not</I> clamped or 
otherwise changed before storing it. Use <TT>clamp()</TT> or <TT>round()</TT>
 to modify the value before calling this if you want.  If the new value 
is different than the current one the object is redrawn.  The initial 
value is zero. 
<H4><A name=Fl_Valuator.minimum>double Fl_Valuator::minimum() const
<BR> void Fl_Valuator::minimum(double)</A></H4>
 Gets or sets the minimum value for the valuator. 
<H4><A name=Fl_Valuator.maximum>double Fl_Valuator::maximum() const
<BR> void Fl_Valuator::maximum(double)</A></H4>
 Gets or sets the maximum value for the valuator. 
<H4><A name=Fl_Valuator.range>void Fl_Valuator::range(double min, 
double max);</A></H4>
 Sets the minimum and maximum values for the valuator. When the user 
manipulates the widget, the value is limited to this range.  This 
clamping is done <I>after</I> rounding to the <a href=#Fl_Valuator.step>step</a> value (this makes a 
difference if the range is not a multiple of the step). 
<P>The minimum may be greater than the maximum.  This has the effect of 
&quot;reversing&quot; the object so the larger values are in the opposite 
direction.  This also switches which end of the filled sliders is 
filled. </P>
<P>Some widgets consider this a &quot;soft&quot; range.  This means they will 
stop at the range, but if the user releases and grabs the control again 
and tries to move it further, it is allowed. </P>
<P>The range may affect the display. You must <TT>redraw()</TT> the 
widget after changing the range. </P>

<H4><A name=Fl_Valuator.step>double Fl_Valuator::step() const
<BR> void Fl_Valuator::step(double)</A></H4>

Get or set the step value.  As the user moves the mouse the value is 
rounded to the nearest multiple of the step value.  This is done <I>
before</I> clamping it to the range.  For many widgets this is also
the amount the widget changes when the user drags the mouse 1 pixel.

<p>For most widgets the default step is zero.  If the widget needs a
non-zero value (for instance to calculate the linesize() or how far the
mouse dragged the value) it acts as though step() is 1/100 the
distance between the minimum and maximum.

<H4><A name=Fl_Valuator.linesize>int Fl_Valuator::linesize() const
<BR>void Fl_Valuator::linesize(int)</A></H4>

The linesize is the number of <a href=#Fl_Valuator.step>step()</a> that the valuator moves in
response to an arrow key.  The default value is 1.

<H4><A name=Fl_Valuator.pagesize>int Fl_Valuator::pagesize() const
<BR>void Fl_Valuator::pagesize(int)</A></H4>

The pagesize is the number of <a href=#Fl_Valuator.step>step()</a> that the valuator moves in
response to a page up/down key, or shift-arrow key.  The default value
is 10.

<H4><A name=Fl_Valuator.format>int Fl_Valuator::format(char*)</A>
</H4>

Format the passed value to show enough digits so that for the current
<a href=#Fl_Valuator.step>step</a> value.  If the step has been set to
zero then it does a <TT>%g</TT> format.  The characters are written
into the passed buffer (which must be long enough, 40 characters is
safe).

<H4><A name=Fl_Valuator.round>double Fl_Valuator::round(double)</A></H4>

Round the passed value to the nearest <a
href=#Fl_Valuator.step>step</a> increment.  Does nothing if step is
zero.

<H4><A name=Fl_Valuator.clamp>double Fl_Valuator::clamp(double)</A></H4>

Clamp the passed value to the valuator range and returns it.

<H4><A name=Fl_Valuator.increment>double Fl_Valuator::increment(double,int n)</A></H4>

Adds <TT>n</TT> times the <a href=#Fl_Valuator.step>step</a> value to
the passed value and returns it.
