<html><head><title>Fl_Browser</title></head><body bgcolor = white>

<hr break>
<a name=Fl_Browser><h2>class Fl_Browser</h2></a>
<hr>

<h3>Class Hierarchy</h3>

<ul><pre>

<A href=Fl_Widget.html>Fl_Widget</A>
   |
   +----<a href=Fl_Group.html>Fl_Group</a>
           |
           +----<a href=Fl_Menu_.html>Fl_Menu_</A>
                   |
                   +----<B>Fl_Browser</B>
                           |
                           +----<A href=Fl_Multi_Browser.html>Fl_Multi_Browser</A>
</pre></ul>

<h3>Include Files</h3>

<ul><pre>
#include &lt;fltk/Fl_Browser.h&gt;
</pre></ul>

<h3>Description</h3>

The <tt>Fl_Browser</tt> widget displays a scrolling vertical list of text
widgets, possibly with a hierachial arrangement.

<p><center><img src=browser.gif></center>

<p>The items may be created as child widgets (usually the same widgets
as are used to create menus: <a href=Fl_Item.html>Fl_Item</a> widgets,
or <a href=Fl_Item_Group.html>Fl_Item_Group</a> widgets to make a
hierarchy). Alternatively you can build simple text lists by using the
<a href=Fl_Menu_.html#add>add()</a> method, which will create the
child widgets for you (and even create a hierarchy if you put slashes
in the text). You can also us an <a href=Fl_List.html>Fl_List</a>
which allows you to control the storage by dynamically creating a
"fake" widget for the browser to use to draw each item.

<p>All the functions used to add, remove, or modify items in the list
are defined by the base class <a href=Fl_Menu_.html>Fl_Menu_</a>. See
that for much more information.

<p>For a simple constant list you can populate the list by calling
<tt>browser-><a href=Fl_Menu_.html#add>add</a>("text of item")</tt>
once for each item.  If you give the browser a callback you can find
out what item was selected with <tt>browser-><a
href=#value>value()</a>;</tt>, the first item is zero (this is
different from older versions of fltk that started at 1!), and will be
negative if no item is selected. You can
change the selected item with <tt>browser-><a
href=#value>value(n)</a></tt>.

<p>The subclass <a href=Fl_Multi_Browser.html>Fl_Multi_Browser</a>
lets the user select more than one item at the same time.

<h4>Callbacks</h4>

You can control when callbacks are done with the <a
href="Fl_Widget.html#when"><tt>when()</tt></a> method. The following
values are useful, the default value is <tt>FL_WHEN_RELEASE</tt>.

<ul>

<li><tt>FL_WHEN_NEVER</tt> - Callback is never done. <a
href="Fl_Widget.html#changed"><tt>changed()</tt></a> can be used to
see if the user has modified the browser.</li>

<li><tt>FL_WHEN_CHANGED</tt> - Callback is done whenever the user
changes the current item. If they drag the mouse through items the
callback is done for each one, and the callback is done for each
keystroke that changes the selected item.</li>

<li><tt>FL_WHEN_RELEASE</tt> - Callback is done when the user releases
the mouse and the selected item has changed, and on any keystroke that
changes the item.</li>

<li><tt>FL_WHEN_RELEASE_ALWAYS</tt> - Callback is done when the user
releases the mouse even if the current item has not changed, and on
any arrow keystroke even when at the top or bottom of the browser. You
must use this if you want to detect the user double-clicking an item.</li>

<li><tt>FL_WHEN_ENTER_KEY</tt> - Callback is only done if the user
hits the Enter key and some item is selected. In the current version
the callback is also done if the user double-clicks a non-parent item.</li>

</ul>

<h3>Methods</h3>

<center>
<table width=90%>
<tr><td align=left valign=top>

<li><a href="#Fl_Browser">Fl_Browser</a></li>
<li><a href="#~Fl_Browser">~Fl_Browser</a></li>
<li><a href="#box_height">box_height</a></li>
<li><a href="#box_width">box_width</a></li>
<li><a href="#column_widths">column_widths</a></li>
<li><a href="#current_index">current_index</a></li>
<li><a href="#current_level">current_level</a></li>
<li><a href="#current_position">current_position</a></li>
<li><a href="#focus_index">focus_index</a></li>
<li><a href="#focus_level">focus_level</a></li>
<li><a href="#focus_position">focus_position</a></li>
<li><a href="#format_char">format_char</a></li>
<li><a href="#goto_focus">goto_focus</a></li>

</td><td align=left valign=top>

<li><a href="#goto_index">goto_index</a></li>
<li><a href="#goto_position">goto_position</a></li>
<li><a href="#goto_top">goto_top</a></li>
<li><a href="#height">height</a></li>
<li><a href="#hscrollbar">hscrollbar</a></li>
<li><a href="#indented">indented</a></li>
<li><a href="#item_is_parent">item_is_parent</a></li>
<li><a href="#item_is_visible">item_is_visible</a></li>
<li><a href="#make_item_visible">make_item_visible</a></li>
<li><a href="#next">next</a></li>
<li><a href="#next_visible">next_visible</a></li>
<li><a href="#previous_visible">previous_visible</a></li>
<li><a href="#scrollbar">scrollbar</a></li>

</td><td align=left valign=top>

<li><a href="#set_focus">set_focus</a></li>
<li><a href="#set_item_opened">set_item_opened</a></li>
<li><a href="#set_item_visible">set_item_visible</a></li>
<li><a href="#topline">topline</a></li>
<li><a href="#topline">topline</a></li>
<li><a href="#type">type</a></li>
<li><a href="#value">value</a></li>
<li><a href="#value">value</a></li>
<li><a href="#width">width</a></li>
<li><a href="#xposition">xposition</a></li>
<li><a href="#xposition">xposition</a></li>
<li><a href="#yposition">yposition</a></li>
<li><a href="#yposition">yposition</a></li>

</td></tr>
</table>
</center>

<a name=Fl_Browser><h4>Fl_Browser::Fl_Browser(int, int, int, int, const char * = 0)</h4></a>

The constructor makes an empty browser. 

<a name=~Fl_Browser><h4>Fl_Browser::~Fl_Browser(void)</h4></a>

The destructor deletes all the list items (because they are child
Fl_Widgets of an Fl_Group) and destroys the browser. 

<a name=type><h4>void Fl_Browser::type(char);</h4></a>

The bits of the type() are used to control what scrollbars are allowed
to be visible and is also used by subclasses to change
functionality. The default value is
<tt>Fl_Browser::BOTH</tt>. Disabling the scrollbar does not stop the
browser from scrolling, the user can still move it by moving the focus
with the arrow keys or by dragging the mouse.

<ul>
<li><tt>Fl_Browser::HORIZONTAL</tt> Allow a horizontal scrollbar but
it turns off if the data will fit.

<li><tt>Fl_Browser::VERTICAL</tt> Allow a vertical scrollbar but it
turns off if the data will fit.

<li><tt>Fl_Browser::BOTH</tt> Same as <tt>Fl_Browser::HORIZONTAL |
Fl_Browser::VERTICAL</tt>

<li><tt>Fl_Browser::ALWAYS_ON</tt> Force the scrollbars to stay on
even if the data does fit.

<li><tt>Fl_Browser::HORIZONTAL_ALWAYS</tt> Same as
<tt>Fl_Browser::ALWAYS_ON | Fl_Browser::HORIZONTAL</tt>

<li><tt>Fl_Browser::VERTICAL_ALWAYS</tt> Same as <tt>Fl_Browser::ALWAYS_ON |
Fl_Browser::VERTICAL</tt>

<li><tt>Fl_Browser::BOTH_ALWAYS</tt> Same as <tt>
Fl_Browser::ALWAYS_ON | Fl_Browser::HORIZONTAL |
Fl_Browser::VERTICAL</tt>

<li><tt>Fl_Browser::MULTI</tt> This bit is turned on by the <a
href=Fl_Multi_Browser.html>Fl_Multi_Browser</a> and must be left on
for it to work correctly.

</ul>

<a name=width><h4>int width() const</h4></a>

The width of the longest item in the browser, measured in pixels. If
this is changed (by adding or deleting items or opening or closing a
parent item) then <a href=Fl_Widget.html#layout>layout()</a> must be
called before this is correct.

<a name=height><h4>int height() const</h4></a>

The height of all the visible items in the browser, measured in
pixels. If this is changed (by adding or deleting items or opening or
closing a parent item) then <a
href=Fl_Widget.html#layout><tt>layout()</tt></a> must be called before
this is correct.

<a name=box_width><h4>int box_width() const</h4></a>

The width of the display area of the browser in pixels, this is <a
href=Fl_Widget.html#w><tt>w()</tt></a> minus the edges of the <a
href=Fl_Widget.html#box><tt>box()</tt></a> minus the width
of the vertical scrollbar, if visible. If this is changed (by resizing
the widget, adding or deleting items or opening or closing a parent
item such that the scrollbar visibility changes) then <a
href=Fl_Widget.html#layout>layout()</a> must be called before this is
correct.

<a name=box_height><h4>int box_height() const</h4></a>

The height of the display area of the browser in pixels, this is <a
href=Fl_Widget.html#h><tt>h()</tt></a> minus the edges of the <a
href=Fl_Widget.html#box><tt>box()</tt></a> minus the height
of the horizontal scrollbar, if visible. If this is changed (by resizing
the widget, adding or deleting items or opening or closing a parent
item such that the scrollbar visibility changes) then <a
href=Fl_Widget.html#layout>layout()</a> must be called before this is
correct.

<a name=xposition><h4>int xposition() const</h4></a>

Current horizontal scrolling pozition. Normally zero.

<a name=xposition><h4>void xposition(int);</h4></a>

Set the horizontal scrolling to a certain value.

<a name=yposition><h4>int yposition() const</h4></a>

Current vertical scrolling position. This is the location, in pixels,
of the top of the visible display, relative to the pixel position of
the top of the first item.

<a name=yposition><h4>void yposition(int);</h4></a>

Set the vertical scrolling to a certain value.

<a name=indented><h4>bool indented() const
<br>void indented(bool v)</h4></a>

Turn this on to for space to be reserved for open/close boxes drawn to
the left of top-level items. You usually want this for a hierarchial
browser. This should be off for a flat browser, or to emulate Windows
Explorer where "my computer" does not have an open/close to the left
of it. The default value is <tt>false</tt>.

<h4><a name=scrollbar>Fl_Scrollbar scrollbar;</a>
<br><a name=hscrollbar>Fl_Scrollbar hscrollbar;</a></h4>

The scrollbars are accessable as instance variables. You can alter
their width or other attributes to customize the browser to your liking.

<a name=goto_top><h4>Fl_Widget* goto_top();</h4></a>

Because of the hierarchial structure it is difficult to identify an
item in the browser. Instead of passing an identifier to all the calls
that can modify an item, the browser provides several calls to set the
"current" item and then calls to modify the current item.

<p>This call sets the current item to the very first <i>visible</i>
item in the browser. It returns the widget for that item, or null if
the browser is empty.

<p>If you have invisible items in the browser you should use <a
href="#goto_index"><tt>goto_index(0)</tt></a> if you want to go to the
first item even if it is invisible.

<a name=goto_focus><h4>Fl_Widget* goto_focus()</h4></a>

<p>Set the current item to the "focus" (the item with the dotted square
in an <tt>Fl_Multi_Browser</tt>, and the selected item in a normal
<tt>Fl_Browser</tt>.

<a name=goto_position><h4>Fl_Widget* goto_position(int y);</h4></a>

<p>Set the current item to one at or before <i>y</i> pixels from top
of the first item.

<a name=goto_index><h4>Fl_Widget* goto_index(const int* indexes, int level);</h4></a>

<p>Go to a nested item. <i>indexes</i> must contain <i>level</i>+1
index numbers. The first number indicates the top-level item number,
the second indicates the child number of that parent, and so on. This
sets the current item to the given item. If the values are out of
range then null is returned, otherwise the widget for that item.

<h4>Fl_Widget* goto_index(int);
<br>Fl_Widget* goto_index(int,int);
<br>Fl_Widget* goto_index(int,int,int);
<br>Fl_Widget* goto_index(int,int,int,int);
<br>Fl_Widget* goto_index(int,int,int,int,int);</a></h4>

These are the same as passing the number of arguments minus one as the
<i>level</i> and the arguments as the index array to <a
href="#goto_index"><tt>goto_index()</tt></a>. Passing a negative number
as the first argument will set it to a special "no item" state where
<tt>select_only_this()</tt> will do <tt>deselect()</tt>

<a name=item><h4>Fl_Widget* item();</h4></a>

This is in fact a method on the base <a
href="Fl_Menu_.html">Fl_Menu_</a> class. This returns the widget that
was jumped to by the last <a href="#goto_index">goto_index()</a> or
other similar call.

<a name=item_is_visible><h4>bool item_is_visible() const;</h4></a>

Return true if the item would be visible to the user if the browser
was scrolled to the correct location. This means that the
<tt>FL_INVISIBLE</tt> flag is not set on it, and all parents of it are
open and visible as well.

<a name=item_is_parent><h4>bool item_is_parent() const;</h4></a>

Return true if the current item is a parent. Notice that it may have
zero children.
  
<a name=next><h4>Fl_Widget* next();</h4></a>

Move the current item to the next item. If if is a parent it moves to
the first child. If not a parent, it moves to the next child of it's
parent. If it is the last child it moves to the parent's
brother. Repeatedly calling this will visit every child of the browser.
This returns the widget. If the current widget is the last one this
returns null, but the current widget remains on the last one.

<a name=next_visible><h4>Fl_Widget* next_visible();</h4></a>

Move the current item to the next visible item. Invisible items are
either hidden because their parent is closed or because they had <a
href=Fl_Widget.html#hide><tt>hide()</tt></a> called on them.

<a name=previous_visible><h4>Fl_Widget* previous_visible();</h4></a>

Move the current item to the previous visible item. Invisible items are
either hidden because their parent is closed or because they had <a
href=Fl_Widget.html#hide><tt>hide()</tt></a> called on them.

<a name=set_focus><h4>bool set_focus();</h4></a>

Change the focus (the selected item, or in an <a
href="Fl_Multi_Browser.html">Fl_Multi_Browser</a> the item that has a
dotted box around it, and the current item selected with <a
href="#goto_index"><tt>goto_index()</tt></a>. This calls <a
href="#make_item_visible">make_item_visible()</a>.

<a name=make_item_visible><h4>void make_item_visible(enum = NOSCROLL)</h4></a>

<p>This makes the current item visible to the user.

<p>First it turns off the <tt>FL_INVISIBLE</tt> flag on the current
item, and turns off the <tt>FL_INVISIBLE</tt> flag and opens (turning
on the <tt>FL_VALUE</tt> flag) all parent items. These flag changes
cause <a href="Fl_List.html#flags_changed">flags_changed()</a> to be
called on any <a href="Fl_List.html">Fl_List</a> that you have
assigned to the browser.

<p>The browser is then scrolled by calling <a
href="#yposition"><tt>yposition()</tt></a> so the item is visible. The
optional argument tells how to scroll. If not specified (or the
default value of <tt>Fl_Browser::NOSCROLL</tt> is given) then the
browser is scrolled as little as possible to show the item. If it is
<tt>Fl_Browser::TOP</tt> then the item is put at the top of the
browser. If it is <tt>Fl_Browser::MIDDLE</tt> then the item is
centered vertically in the browser. If it is
<tt>Fl_Browser::BOTTOM</tt> then the item is put at the bottom of the
browser.

<p>This does nothing if the current item is null.

<a name=damage_item><h4>void damage_item();</h4></a>

Tell the browser to redraw the current item. Do this if you know it
has changed appearance. This is better than redrawing the entire
browser because it will blink a lot less.

<a name=set_item_opened><h4>bool set_item_opened(bool value);</h4></a>

If the current item is a parent, set the open state (the
<tt>FL_VALUE</tt> flags) to the given <i>value</i> and redraw the
browser correctly. Returns true if the state was actually changed,
returns false if it was already in that state.

<a name=set_item_visible><h4>bool set_item_visible(bool value);</h4></a>

Turn off or on the <tt>FL_INVISIBLE</tt> flag on the given item and
redraw the browser if necessary. Returns true if the state was
actually changed, returns false if it was already in that state.

<a name=current_level><h4>int current_level() const;</h4></a>

Return the nesting level of the current item (how many parents it has).

<a name=current_index><h4>const int& current_index() const;</h4></a>

Return an array of <tt><a
href=current_level>current_level()</a>+1</tt> indexes saying which
child at each level includes the current item.

<a name=current_position><h4>int current_position() const</h4></a>

Return the y position, in pixels, of the top edge of the current
item. You may also want the height, which is in <tt>item()->height()</tt>.

<a name=focus_level><h4>int focus_level() const</h4></a>

Return the nesting level of the focus (how many parents it has). The
focus is the selected item the user sees.

<a name=focus_index><h4>const int& focus_index() const</h4></a>

Return an array of <tt><a
href=focus_level>focus_level()</a>+1</tt> indexes saying which
child at each level includes the focus.

<a name=focus_position><h4>int focus_position() const</h4></a>

Return the y position, in pixels, of the top edge of the focus item.

<a name=value><h4>void value(int v)</h4></a>

Same as <tt><a href=#goto_index>goto_index(v)</a>;<a
href=#set_focus>set_focus()</a>;</tt>, to change the current item in a
non-hierarchial browser.

<a name=value><h4>int value() const;</h4></a>

Returns <tt><a href=#focus_index>focus_index(v)</a>[0]</tt>, to
get the current item in a non-hierarchial browser.

<a name=format_char><h4>char format_char() const;
<br>void format_char(char c);</h4></a>

Sent to the <a href=drawing.html><tt>fl_draw()</tt></a> function to
control the interpretation of leading symbol characters. This defaults
to <tt>'@'</tt>.

<a name=column_widths><h4>const int *column_widths() const;
<br>void column_widths(const int *pWidths)</h4></a>

Sets the horizontal locations that each <tt>'\t'</tt> character in an
item should start printing text at. These are measured from the left
edge of the browser, including any area for the open/close + glyphs.

<a name=topline><h4>int topline() const</h4></a>

Return the index of the top-level item that is at the top of the browser.

<a name=topline><h4>void topline(int line)</h4></a>

Same as <tt><a href=#goto_index>goto_index(line)</a>; <a
href=#make_item_visible>make_item_visible(TOP)</a>;</tt>.

<hr>

<p>This is the description of '@' commands, it should be moved to the
fl_draw() documentation:

<p>A string of formatting codes at the start of 
each column are stripped off and used to modify how the rest of the 
line is printed: 

<ul>
<li><code>@.</code> Print rest of line, don't look for more '@' signs </li>
<li><code>@@</code> Print rest of line starting with '@' </li>
<li><code>@l</code> Use a <BIG>large</BIG> (24 point) font </li>
<li><code>@m</code> Use a <BIG>medium large</BIG> (18 point) font </li>
<li><code>@s</code> Use a <SMALL>small</SMALL> (11 point) font </li>
<li><code>@b</code> Use a <B>bold</B> font (adds FL_BOLD to font) </li>
<li><code>@i</code> Use an <I>italic</I> font (adds FL_ITALIC to font) </li>
<li><code>@f</code> or <code>@t</code> Use a <code>fixed-pitch</code>
 font (sets font to FL_COURIER) </li>
<li><code>@c</code> Center the line horizontally </li>
<li><code>@r</code> Right-justify the text </li>
<li><code>@B0, @B1, ... @B255</code> Fill the backgound with 
fl_color(n) </li>
<li><code>@C0, @C1, ... @C255</code> Use fl_color(n) to draw the text </li>
<li><code>@F0, @F1, ... </code> Use fl_font(n) to draw the text </li>
<li><code>@S1, @S2, ... </code> Use point size n to draw the text </li>
<li><code>@u</code> or <code>@_</code> Underline the text. </li>
<li><code>@-</code> draw an engraved line through the middle. </li>
</UL>

Notice that the <code>@.</code> command can be used to reliably 
terminate the parsing.  To print a random string in a random color, use <TT>
sprintf(&quot;@C%d@.%s&quot;, color, string)</TT> and it will work even if the 
string starts with a digit or has the format character in it. 

</body></html>
