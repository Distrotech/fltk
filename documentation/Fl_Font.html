<head><title>Fl_Font</title></head><body>

<h1>typedef Fl_Font</h1>

The font used by <a
href=Fl_Widget.html#labelfont>Fl_Widget::label_font()</a> and other
parts of fltk is a typedef for a ponter to the structure
<tt>Fl_Font_</tt>.

<p>The following Fl_Font values are predefined:</p>

<ul>
<li><tt>FL_HELVETICA</tt>
<li><tt>FL_HELVETICA_BOLD</tt>
<li><tt>FL_HELVETICA_ITALIC</tt>
<li><tt>FL_HELVETICA_BOLD_ITALIC</tt>
<li><tt>FL_COURIER</tt>
<li><tt>FL_COURIER_BOLD</tt>
<li><tt>FL_COURIER_ITALIC</tt>
<li><tt>FL_COURIER_BOLD_ITALIC</tt>
<li><tt>FL_TIMES</tt>
<li><tt>FL_TIMES_BOLD</tt>
<li><tt>FL_TIMES_ITALIC</tt>
<li><tt>FL_TIMES_BOLD_ITALIC</tt>
<li><tt>FL_SYMBOL</tt>
<li><tt>FL_SCREEN</tt>
<li><tt>FL_SCREEN_BOLD</tt>
<li><tt>FL_ZAPF_DINGBATS</tt> (Wingdings font on Win32!)
</ul>

<h2>Methods</h2>

<h4>Fl_Font_* Fl_Font_::bold;
<br>Fl_Font_* Fl_Font_::italic;</h4>

Pointers to the bold and italic versions of this font.  If this font
has no bold or italic version (usually because it aready is bold or
italic, but possibly because the other font is missing from the
server), then these are circular pointers to this.

<h4>const char* Fl_Font_::system_name()</h4>

Returns a string that identifies the font in a system-specific
manner.  About all that can be said about it is that it is different
for every font (two different fonts may return the same name()).  This
string is not portable, even between different machines running the
same operating system.

<h4>const char* Fl_Font_::name(int* attributes = 0)</h4>

Returns the name of the font.  The return value points to a static
buffer that is overwritten each call (so copy the string if you want
to keep it).

<P>The integer pointed to by <tt>attributes</tt> is set to zero,
<tt>FL_BOLD</tt> or <tt>FL_ITALIC</tt> or <tt>FL_BOLD|FL_ITALIC</tt>.
If this pointer is null then the attributes are indicated by adding
"bold" or "italic" to the name.

<h4>int Fl_Font_::encodings(const char** &amp;array) const;</h4>

Sets <i>array</i> to point at a list of encoding names.  The return
value is the length of this array.  Each string identifies an
"encoding" that is supported by this font.  These strings may be
passed to the <a href=drawing.html#fl_font><TT>fl_font()</TT></a> to
select what characters the first 256 codes print.  If fltk cannot
figure out the encodings it returns a zero-length array, in which case
you should only pass <tt>fl_encoding</tt> to <tt>fl_font()</tt>.  The
returned array points at a static buffer that is overwritten each
call, so you want to copy it if you plan to keep it.

<h4>int Fl_Font_::sizes(int *&amp;array) const;</h4>

Sets <i>array</i> to point at a list of sizes.  The return value is the
length of this array.  The sizes are sorted from smallest to largest
and indicate what sizes can be given to <a
href=drawing.html#fl_font><TT>fl_font()</TT></a> that will be matched
exactly (<TT>fl_font()</TT> will pick the closest size for other
sizes).  A zero in the first location of the array indicates a
scalable font, where any size works, although the array may list sizes
that work &quot;better&quot; than others.  The returned array points
at a static buffer that is overwritten each call, so you want to copy
it if you plan to keep it.

<h4>Fl_Font fl_font(const char* name, int attributes = 0);</h4>

Find a font with the given "nice" name.  You can get bold and italic
by either putting "Bold" or "Italic" in the name, or by passing them
as the attributes.  Case is ignored and fltk will accept some
variations in the font name.

<p>The current implementation calls <tt>fl_list_fonts()</tt> and then
does a binary search for the font in it.  This can make the first call
pretty slow, especially on X.

<h4>int fl_list_fonts(Fl_Font*& arrayp);</h4>

This allocates and fills in an array containing every font on the
server.  The location <i>arrayp</i> is set to a pointer to this array,
and the length of the array is the return value.  Each entry is a
"base" font, there may be bold, italic, and bold+italic version of
each font pointed to by the <code>bold</code> or <code>italic</code>
pointers in them.

<p>Subsequent calls to this function returns the same array again.
Currently there is no way to update the list from any changes to the
set of fonts on the server.

</body></html>
