<html><head><title>FLTK X-Specific Interface</title></head><body bgcolor=white>

<h1>System-Specific Interfaces</h1>

<h2>X11/Unix</h2>

<h4><tt>#include &lt;fltk/x.h&gt;</tt></h4>

On X you can include this file to access FLTK's X-specific functions. 
Be warned that some of the structures and calls in it are subject to 
change in future version of FLTK.  Try to avoid doing this so your code 
is portable. 

<a name=add_handler><h4>void Fl::add_handler(int (*f)(int))</h4></a>

Installs a function to parse unrecognized events.  If FLTK cannot
figure out what to do with an event, it calls each of these functions
(most recent first) until one of them returns non-zero.  If none of
them returns non-zero then the event is ignored.  The argument is the
event number (like <tt>FL_PUSH</tt>).  For keystrokes it will be
<tt>FL_SHORTCUT</tt>.

<p>Besides events that all widgets ignored, FLTK calls this for X
events that it does not recognize, or that contain a window id that
FLTK does not know about. In this case the argument is zero.  You can
look at the X event with the <a href=#fl_xevent><tt>fl_xevent</tt></a>
variable.

<a name=fl_xevent><h4>extern XEvent* fl_xvent</h4></a>

The most recent X event. 

<a name=fl_event_time><h4>extern ulong fl_event_time</h4></a>

This is the time stamp from the most recent X event that reported it 
(not all do).  Many X calls (like cut and paste) need this value. 

<a name=fl_handle><h4>int fl_handle(const XEvent &amp;)</h4></a>

This allows you to "feed" X events to fltk, in cases where you cannot
give fltk control over any file descriptors. Fltk will figure out what
the event is and call widgets normally and also the
<tt>Fl::add_handler()</tt> functions. The return value is true if a
widget accepted the event or one of the <tt>add_handler()</tt>
function returned true.

<p>Besides feeding events your code should call <a href=Fl.html#flush>
<tt>Fl::flush()</tt></a> periodically so that FLTK redraws its
windows.

<p>This function will call any widget callbacks from the widget code.
It will not return until they complete, for instance if it pops up a
modal window with <a href=utility.html#fl_ask><tt>fl_ask()</tt></a>,
it will not return until the user clicks yes or no.

<a name=display><h4>int Fl::display(const char*)</h4></a>

Set which X display to use.  This actually does <tt>
putenv(&quot;DISPLAY=...&quot;)</tt> so that child programs will
display on the same screen if called with <tt>exec()</tt>.  This must
be done before <tt>fl_open_display</tt> is called.  This call is
provided under WIN32 but it has no effect.

<a name=fl_open_display><h4>void fl_open_display()</h4></a>

Opens the display.  Does nothing if it is already open.  You should
call this if you wish to do X calls and there is a chance that your
code will be called before the first <tt>show()</tt> of a window.
This is called automatically <tt>by Fl_Window::show()</tt>.

<p>This may call <tt>Fl::abort()</tt> if there is an error opening the 
display.

<h4>void fl_open_display(Display*)</h4>

You can make fltk "open" a display that has already been opened,
perhaps by another GUI library.  Calling this will set
<tt>fl_display</tt> to the passed display and also read information
fltk needs from it. <i>Don't call this if the display is already open!</i>

<a name=fl_display><h4>extern Display* fl_display</h4></a>

The open X display.  This is needed as an argument to most Xlib calls. 
Don't attempt to change it!  This is <tt>NULL</tt> before
<tt>fl_open_display</tt> is called.

<a name=fl_message_window><h4>extern Window fl_message_window</h4></a>

This dummy 1x1 window is created by <tt>fl_open_display()</tt> and is
never destroyed.  You can use it to communicate with the window
manager or other programs.

<a name=fl_screen><h4>extern int fl_screen</h4></a>

Which screen number to use.  This is set by <tt>fl_open_display()</tt>
to the default screen.  You can change it by setting this to a 
different value immediately afterwards.

<a name=fl_visual><h4>extern XVisualInfo* fl_visual
<br><a name=fl_colormap>extern Colormap fl_colormap</h4></a>

The visual and colormap that FLTK will use for all windows.  These are 
set by <tt>fl_open_display()</tt> to the default visual and colormap. 
You can change them before calling <tt>show()</tt> on the first 
window.  Typical code for changing the default visual is: 

<UL><PRE>Fl::args(argc, argv); // do this first so $DISPLAY is set
fl_open_display();
fl_visual = find_a_good_visual(fl_display, fl_screen);
if (!fl_visual) Fl::abort(&quot;No good visual&quot;);
fl_colormap = make_a_colormap(fl_display, fl_visual-&gt;visual, fl_visual-&gt;depth);
// it is now ok to show() windows:
window-&gt;show(argc, argv);</PRE></UL>

You may also want to call <a
href=Fl.html#visual>Fl::visual()</a>, which is a portable
interface to get a full color and/or double buffered visual.

<a name=fl_xid><h4>Window fl_xid(const Fl_Window*)</h4></a>

Returns the XID for a window, or zero if not <tt>shown()</tt>. 

<a name=fl_find><h4>Fl_Window* fl_find(ulong xid)</h4></a>

Returns the <tt>Fl_Window</tt> that corresponds to the given XID, or
<tt>NULL</tt> if not found.  This uses a cache so it is slightly
faster than iterating through the windows yourself.

<a name=fl_window><h4>extern Window fl_window;
<br><a name=fl_gc>extern GC fl_gc;</h4></a>

These variables are set before <tt>Fl_Widget::draw()</tt>
is called, or by <a href=Fl_Window.html#make_current><tt>
Fl_Window::make_current()</tt></a>.  They are needed by most Xlib
drawing calls, a typical call is like this:

<ul><pre>XDrawSomething(fl_display, fl_window, fl_gc, ...);</pre></ul>

<p>Notice that <tt>fl_window</tt> is the X window id number.  Other
information such as the position or size of the X window can be found
by looking at <a href=Fl_Window.html#make_current><tt>
Fl_Window::current()</tt></a>, which returns a pointer to the <tt>
Fl_Window</tt> being drawn.

<a name=fl_clip_region><h4>Region fl_clip_region();</h4></a>

Return the current clip region, or <tt>NULL</tt> if we are currently
clipping to the entire window. Notice that this will be destroyed by
the next change to the clipping, copy it if you want to keep it.

<h4>void fl_clip_region(Region);</h4>

Replace the current clip region with this one, or make there be no
clipping if <tt>NULL</tt> is passed. The old clip region is destroyed.

<a name=fl_xpixel><h4>unsigned long fl_xpixel(Fl_Color i)</h4></a>

Returns the X pixel number used to draw the given FLTK color index or
RGB color. This is the X pixel that <a
href=drawing.html#fl_color><tt>fl_color(i)</tt> </a> would use.

<a name=fl_xfont><h4>extern XFontStruct* fl_xfont</h4></a>

Points at the font selected by the most recent <a
href=drawing.html#fl_font><tt>fl_font()</tt></a>.  This is not
necessarily the current font of <tt>fl_gc</tt>, which is not set
until <a href=drawing.html#fl_draw><tt>fl_draw()</tt></a> is called.

<a name=fl_close_display><h4>void fl_close_display()</h4></a>

This closes the X connection.  You do <I>not</I> need to call this to 
exit, and in fact it is faster to not do so!  It may be useful to call 
this if you want your program to continue without the X connection. You 
cannot open the display again, and probably cannot call any FLTK 
functions. 

<a name=xclass><h4>static void Fl_Window::xclass(const char*)
<br>static const char* Fl_Window::xclass() const</h4></a>

This string is used to set the <tt>XA_WM_CLASS</tt> property of all
the windows fltk creates.  The default value is "fltk".  Many window
managers can use this string to select an icon.  <a
href=Fl.html#args><tt>Fl::args(...)</tt></a> will set this to
the name of the program.

<p>This call is provided on WIN32 for compatability, but the value is
ignored.

<a name=icon><h4>void Fl_Window::icon(char*)</h4></a>

Sets the icon for the window to the passed pointer.  You will need to 
cast the icon <tt>Pixmap</tt> to a <tt>char*</tt> when calling this 
method. To set the icon using a bitmap compiled with your application 
use:

<UL><PRE>#include &quot;icon.xbm&quot;

Pixmap p = XCreateBitmapFromData(fl_display, DefaultRootWindow(fl_display),
                                 icon_bits, icon_width, icon_height);

window-&gt;icon((char*)p);</PRE></UL>

<p>This only works if called <i>before</i> it is shown using the
<tt>Fl_Window::show()</tt> method.

<a name=dnd><h3>Drag & Drop information</h3></a>

The <tt>fl_dnd_*</tt> variables allow your fltk program to use the
Xdnd protocol to manipulate files and interact with file managers. You
can ignore these if you just want to drag & drop blocks of text.  I
have little information on how to use these, I just tried to clean up
the Xlib interface and present the variables nicely.

<a name=fl_dnd_source_window><h4>Window fl_dnd_source_window</h4></a>

The id of the window being dragged from.

<a name=fl_dnd_source_action><h4>Atom fl_dnd_source_action</h4></a>

The action the source program wants to perform. Due to oddities in the
Xdnd design this variable is <i>not</i> set on the <a
href="events.html#FL_DND_ENTER"><tt>FL_DND_ENTER</tt></a> event,
instead it is set on each <a
href=events.html#FL_DND_DRAG><tt>FL_DND_DRAG</tt></a> event, and it
may change each time.

<p>To print the string value of the <tt>Atom</tt> use this code:

<ul><pre>char* x = XGetAtomName(fl_display, fl_dnd_source_action);
puts(x);
XFree(x);</pre></ul>

<p>You can set this before calling <a
href="Fl.html#dnd"><tt>Fl::dnd()</tt></a> to communicate a different
action. See <a
href=#fl_dnd_source_types><tt>fl_dnd_source_types</tt></a>, which you
must also set.

<a name=fl_dnd_action><h4>Atom fl_dnd_action</h4></a>

The program can set this before returning non-zero for an <a
href="events.html#FL_DND_DRAG"><tt>FL_DND_DRAG</tt></a> event to
indicate what it will do to the object. Fltk presets this to
<tt>XdndActionCopy</tt> so that is returned if you don't set it.

<a name=fl_dnd_source_types><h4>Atom *fl_dnd_source_types</h4></a>

Zero-terminated list of atoms describing the formats of the source
data. This is set on the <a
href="events.html#FL_DND_ENTER"><tt>FL_DND_ENTER</tt></a> event.  The
following code will print them all as text, a typical value is
<tt>"text/plain;charset=UTF-8"</tt> (gag).

<ul><pre>for (int i = 0; fl_dnd_source_types[i]; i++) {
  char* x = XGetAtomName(fl_display, fl_dnd_source_types[i]);
  puts(x);
  XFree(x);
}</pre></ul>

<p>You can set this and <a
href=#fl_dnd_source_action><tt>fl_dnd_source_action</tt></a> before calling <a
href="Fl.html#dnd"><tt>Fl::dnd()</tt></a> to change information about
the source. You must set both of these, if you don't fltk will default
to <tt>"text/plain"</tt> as the type and <tt>XdndActionCopy</tt> as
the action. To set this change it to point at your own array. Only the
first 3 types are sent. Also, fltk has no support for reporting back
what type the target requested, so all your types must use the same
block of data.

<a name=fl_dnd_type><h4>Atom fl_dnd_type</h4></a>

The program can set this when returning non-zero for an <a
href="events.html#FL_DND_RELEASE"><tt>FL_DND_RELEASE</tt></a> event to
indicate the translation wanted. Fltk presets this to
<tt>"text/plain"</tt> so that is returned if you don't set it
(supposedly it should be limited to one of the
values in <tt>fl_dnd_source_types</tt>, but <tt>"text/plain"</tt>
appears to always work).

<a name=windows><h3>Using a Subclass of Fl_Window for Special X Stuff</h3></a>

FLTK can manage an X window on a different screen, visual and/or 
colormap, you just can't use FLTK's drawing routines to draw into it. 
But you can write your own <tt>draw()</tt> method that uses Xlib 
(and/or OpenGL) calls only. 

<p>To do this, you need to make a subclass of <a href=Fl_Window.html#Fl_Window>
<tt>Fl_Window</tt></a> and override some of these virtual functions: </P>

<h4>virtual void Fl_Window::create()</h4>

Creates the X window, and perhaps other data such as colormaps needed
by this window.  To create the X window you must call
<tt>Fl_X::create()</tt>.  Do not map the window, fltk does that for you.

<p>An example:

<UL><PRE>void MyWindow::create() {
  fl_open_display();	// necessary if this is first window
  // we only calcualte the necessary visual & colormap once:
  static XVisualInfo* visual;
  static Colormap colormap;
  static int background;
  if (!visual) {
    visual = figure_out_visual();
    colormap = XCreateColormap(fl_display, RootWindow(fl_display,fl_screen),
			        vis-&gt;visual, AllocNone);
    XColor xcol; xcol.red = 1; xcol.green = 2; xcol.blue = 3;
    XAllocColor(fl_display, colormap, &xcol);
    background = xcol.pixel;
  }
  Fl_X::create(this, visual, colormap, background);
}</PRE></UL>

<h4>void Fl_X::create(Fl_Window*, XVisualInfo*, Colormap, int background=-1)</h4>

This function calls XCreateWindow and sets things up so that
<tt>fl_xid(window)</tt> returns the created window id.  This also does
a lot of other ugly X stuff, including setting the label, resize
limitations, etc.  The background is a pixel to use for X's automatic
fill color, use -1 to indicate that no background filling should be
done.

<h4>virtual void Fl_Window::flush()</h4>

This virtual function is called by <tt>Fl::flush()</tt> to update the
window. For FLTK's own windows it does this by setting the global
variables <tt>fl_window</tt> and <tt>fl_gc</tt> and then calling the
<tt>draw()</tt> method.  For your own windows you might just want to
put all the drawing code in here.

<p>X <tt>Expose</tt> events (and calls to <tt>expose()</tt> of the
window or any widget inside it) turn on the
<tt>FL_DAMAGE_EXPOSE</tt> bit in <tt>damage()</tt>, and the regions of
all of them are are accumulated into an X region
that you can get from <tt>Fl_X::i(this)-&gt;region</tt>. This is set
to <tt>NULL</tt> if the entire window is damaged. The undocumented function
<tt>fl_clip_region(XRegion)</tt> will initialize the FLTK clip stack
with a region or <tt>NULL</tt> for no clipping.  You must set region
to <tt>NULL</tt> afterwards as <tt>fl_clip_region()</tt> now owns it
and will delete it when done.

<p>Any other bits set in <tt>damage()</tt> indicate calls to
<tt>redraw()</tt> were done. Notice that the damaged items may be
outside the <tt>Fl_X::i(this)-&gt;region</tt>.

<p>If <tt>damage() == FL_DAMAGE_EXPOSE</tt> then only X expose
events have happened.  This may be useful if you have an undamaged
image (such as a backing buffer) around.

<p>Here is a sample where an undamaged image is kept somewhere: </P>

<ul><pre>void MyWindow::flush() {
  if (damage() == FL_DAMAGE_EXPOSE) {
    fl_clip_region(Fl_X::i(this)-&gt;region);
    Fl_X::i(this)-&gt;region = 0;
    copy_image(backing_store_pixmap, fl_xid(this));
  } else {
    fl_window = backing_store_pixmap;
    fl_gc = backing_store_gc;
    this->draw();
    copy_image(backing_store_pixmap, fl_xid(this));
  }
}</pre></ul>

<h4>virtual void Fl_Window::destroy()</h4>

Destroy the window server copy of the window.  Usually you will 
destroy contexts, pixmaps, or other resources used by the window, and 
then call <tt>Fl_Window::hide()</tt> to get rid of the main window 
identified by <tt>xid()</tt>.

<ul><pre>void MyWindow::destroy() {
  if (backing_store_pixmap) {
    XFreePixmap(fl_display, backing_store_pixmap);
    backing_store_pixmap = 0;
  }
  Fl_Window::destroy(); // you must call this
}</pre></ul>

<h4>virtual void Fl_Window::~Fl_Window()</h4>

Because of the way C++ works, if you override <tt>destroy()</tt> you
<I>must</I> override the destructor as well (otherwise only the base
class <tt>destroy()</tt> is called):

<ul><pre>MyWindow::~MyWindow() {
  destroy();
}</pre></ul>

</body></html>
