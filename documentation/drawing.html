<html>
<head><title>Drawing Things in FLTK</title></head>
<body bgcolor=white>
<h1><a name=drawing>D - Drawing Things in FLTK</a></h1>

 This chapter covers the drawing functions that are provided with FLTK. 

<H2>When Can You Draw Things in FLTK?</H2>

There are only certain places you can execute drawing code in FLTK. 
Calling these functions at other places will result in undefined 
behavior! 

<UL>

<LI>The most common is inside the virtual method <A
href=subclassing.html#draw><TT> Fl_Widget::draw()</TT></A>.  To write
code here, you must subclass one of the existing <TT>Fl_Widget</TT>
classes and implement your own version of <TT>draw()</TT>. </LI>

<LI>You can also write <a href=Fl_Boxtype.html>boxtypes</A> and <A
href=Fl_Labeltype.html> labeltypes</A>.  These are small structures
with functions in them that rae called by existing
<TT>Fl_Widget::draw()</TT> methods.  Pointers to these
structures are stored in the widget's <TT>box()</TT> ,
<TT>labeltype()</TT>, and possibly other properties. </LI>

<li>You can write <a href=Fl_Image.html>Fl_Image</a> classes, which
can then be put into the <a
href=Fl_Widget.html#image>Fl_Widget::image()</a> and be called by
existing <TT>Fl_Widget::draw()</TT> methods.

<LI>You can call <A href=Fl_Window.html#make_current><TT>
Fl_Window::make_current()</TT></A> to do incremental update of a 
widget. Use <A href=Fl_Widget.html#window><TT>
Fl_Widget::window()</TT></A> to  find the window.</LI>

</UL>

<H2>FLTK Drawing Functions</H2>

To use the drawing functions you must first include the <TT>
&lt;FL/fl_draw.H&gt;</TT> header file.  FLTK provides the following types of 
drawing functions: 

<UL>
<LI><A href=#clipping>Clipping</A></LI>
<LI><A href=#colors>Colors</A></LI>
<LI><A href=#lines>Line dashes and thickness</A></LI>
<LI><A href=#fast>Fast Shapes</A></LI>
<LI><A href=#complex>Complex Shapes</A></LI>
<LI><A href=#text>Text</A></LI>
<LI><A href=#images>Images</A></LI>
<LI><A href=#overlay>Overlay</A></LI>
</UL>
<H3><A name=clipping>Clipping</A></H3>

You can limit all your drawing to a region by calling <TT>
fl_clip</TT>, and put the drawings back by using <TT>fl_pop_clip</TT>.
Fltk may also set up clipping before draw() is called to limit the
drawing to the region of the window that is damaged.

<p>When drawing you can also test the current clip region with
<tt>fl_not_clipped()</tt> and <tt>fl_clip_box()</tt>.  By using these
to skip over complex drawings that are clipped you can greatly speed
up your program's redisplay.

<p>The clip region is measured in pixels (it is unaffected by the current 
transformation matrix). 

<H4>void fl_clip(int x, int y, int w, int h)</H4>

Pushes the <i>intersection</i> of the current region and this
rectangle onto the clip stack.

<H4>void fl_clip_out(int x, int y, int w, int h)</H4>

Remove the rectangle from the current clip region, thus making it a
more complex shape.  This does not push the stack, it just replaces
the top of it.  <i>This does not work on X or Win32 unless
<tt>fl_clip()</tt> has been called at least once.</i>

<H4>void fl_push_no_clip()</H4>

Pushes an empty clip region on the stack so nothing will be clipped.
This lets you draw outside the current clip region.  <i>You should not
use this :-)</i>

<H4>void fl_pop_clip()</H4>

Restore the previous clip region. <I>You must call
<TT>fl_pop_clip()</TT> exactly once for every time you call
<TT>fl_clip()</TT>.  If you return to FLTK with the clip stack not
empty unpredictable results occur.</I>

<H4>int fl_not_clipped(int x, int y, int w, int h)</H4>

Return non-zero if the intersection of the rectangle and the current
clip region is non-zero.  If this returns zero you don't have to draw
anything in that rectangle.  <I>Under X this returns 1 if the
interesection is equal to the rectangle, and 2 if the intersection is
only part of the rectangle.</i>

<H4>int fl_clip_box(int x, int y, int w, int h, int &amp;X, int
&amp;Y, int &amp;W, int &amp;H)</H4>

Find the smallest rectangle that surrounds the intersection of the
rectangle <TT>x,y,w,h</TT> with the current clip region.  This
"bounding box" is returned in <TT>X,Y,W,H</TT>.  The return value is
non-zero if the bounding box is different than the rectangle.  If the
intersection is empty then <TT>W</TT> and <TT>H</TT> are set to zero.

<p>This can be used to limit complex pixel operations (like drawing
images) to the smallest rectangle needed to update the visible area.

<H3><A name=colors>Colors</A></H3>

<H4><a name=fl_color>void fl_color(<a href=Fl_Color.html>Fl_Color</a>)</H4>

Set the color for all subsequent drawing operations. <TT><a
href=Fl_Color.html>Fl_Color</a></TT> is a typedef for a 32-bit integer
containing r,g,b bytes and an "index" byte.  The index is used if
r,g,b is zero.

<P>For 8-bit X colormapped displays, a color cell will be allocated
out of <TT> fl_colormap</TT> the first time you use an "indexed"
color. If the colormap fills up then a least-squares algorithm is used
to find the closest color.  RGB colors are found by using the closest
entry in the color cube, which may not be all that close.  (On Windows
the system dithering is used for all colors, which looks lousy, but
Windows does not have the defective X behavior and thus you usually
are not forced to set the screen to 8-bit mode).

<H4><a href=Fl_Color.html>Fl_Color</a> fl_color()</H4>

Returns the last <TT>fl_color()</TT> that was set.  This can be used 
for state save/restore.

<H4>void fl_color(uchar r, uchar g, uchar b)</H4>

Same as <tt>fl_color(fl_rgb(r,g,b))</tt>.

<h3><A name=lines>Line dashes and thickness</a></h3>

<h4><a name=fl_line_style>
void fl_line_style(int style, int width=0, char* dashes=0)</h4>

Set how to draw lines (the "pen").  If you change this it is your
responsibility to set it back to the default with
<tt>fl_line_style(0)</tt>.

<p><i>style</i> is a bitmask in which you 'or' the following values.  If
you don't specify a dash type you will get a solid line.  If you don't
specify a cap or join type you will get a system-defined default of
whatever value is fastest.

<ul>
<li><tt>FL_SOLID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------</tt>
<li><tt>FL_DASH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - - - -</tt>
<li><tt>FL_DOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .......</tt>
<li><tt>FL_DASHDOT&nbsp;&nbsp;&nbsp; - . - .</tt>
<li><tt>FL_DASHDOTDOT - .. -</tt>
<li><tt>FL_CAP_FLAT</tt>
<li><tt>FL_CAP_ROUND</tt>
<li><tt>FL_CAP_SQUARE</tt> (extends past end point 1/2 line width)
<li><tt>FL_JOIN_MITER</tt> (pointed)
<li><tt>FL_JOIN_ROUND</tt>
<li><tt>FL_JOIN_BEVEL</tt> (flat)
</ul>

<p><i>width</i> is the number of pixels thick to draw the lines.  Zero
results in the system-defined default, which on both X and Windows is
somewhat different and nicer than 1.

<p><i>dashes</i> is a pointer to an array of dash lengths, measured in
pixels.  The first location is how long to draw a solid portion, the
next is how long to draw the gap, then the solid, etc.  It is
terminated with a zero-length entry.  A null pointer or a zero-length
array results in a solid line.  Odd array sizes are not supported and
result in undefined behavior.  <i>The dashes array does not work on
Windows 95/98, use the dash styles instead.</i>

<H3><A name=fast>Fast Shapes</A></H3>
 These are used to draw almost all the FLTK widgets.  They draw on 
exact pixel boundaries and are as fast as possible, and their behavior 
will be duplicated exactly on any platform FLTK is ported to.  It is 
undefined whether these are affected by the <A href=#complex_shapes>
transformation matrix</A>, so you should only call these while it is 
the identity. 
<H4>void fl_rectf(int x, int y, int w, int h)</H4>
 Color a rectangle that exactly fills the given bounding box. 


<H4>void fl_rectf(int x, int y, int w, int h, <a
href=Fl_Color.html>Fl_Color</a>)</h4>

Color a rectangle with &quot;exactly&quot; the passed <TT>r,g,b</TT>
color.  On screens with less than 24 bits of color this is done by
drawing a solid-colored block using <A
href=#fl_draw_image><TT>fl_draw_image()</TT> </A> so that dithering is
produced.

<H4>void fl_rectf(int x, int y, int w, int h, uchar r, uchar g, uchar
b)</H4>

Same as <tt>fl_rectf(x,y,w,h,fl_rgb(r,g,b))</tt>.

<H4>void fl_rect(int x, int y, int w, int h)</H4>
 Draw a 1-pixel border <I>inside</I> this bounding box. 
<H4>void fl_line(int x, int y, int x1, int y1)
<BR> void fl_line(int x, int y, int x1, int y1, int x2, int y2)</H4>
 Draw one or two 1-pixel thick lines between the given points. 
<H4>void fl_loop(int x, int y, int x1, int y1, int x2, int y2)
<BR> void fl_loop(int x, int y, int x1, int y1, int x2, int y2, int x3, 
int y3)</H4>
 Outline a 3 or 4-sided polygon with 1-pixel thick lines. 
<H4>void fl_polygon(int x, int y, int x1, int y1, int x2, int y2)
<BR> void fl_polygon(int x, int y, int x1, int y1, int x2, int y2, int 
x3, int y3)</H4>
 Fill a 3 or 4-sided polygon.  The polygon must be convex. 
<H4>void fl_xyline(int x, int y, int x1, int y1)
<BR> void fl_xyline(int x, int y, int x1, int y1, int x2)
<BR> void fl_xyline(int x, int y, int x1, int y1, int x2, int y3)</H4>
 Draw 1-pixel wide horizontal and vertical lines.  A horizontal line is 
drawn first, then a vertical, then a horizontal. 
<H4>void fl_yxline(int x, int y, int y1)
<BR> void fl_yxline(int x, int y, int y1, int x2)
<BR> void fl_yxline(int x, int y, int y1, int x2, int y3)</H4>
 Draw 1-pixel wide vertical and horizontal lines.  A vertical line is 
drawn first, then a horizontal, then a vertical. 
<H4>void fl_arc(int x, int y, int w, int h, double a1, double a2)
<BR> void fl_pie(int x, int y, int w, int h, double a1, double a2)</H4>
 High-speed ellipse sections.  These functions match the rather limited 
circle drawing code provided by X and WIN32.  The advantage over 
using <A href=#fl_arc><TT>fl_arc</TT></A> is that they are faster 
because they often use the hardware, and they draw much nicer small 
circles, since the small sizes are often hard-coded bitmaps. 
<P>If a complete circle is drawn it will fit inside the passed bounding 
box.  The two angles are measured in degrees counterclockwise from 
3'oclock and are the starting and ending angle of the arc, <TT>a2</TT>
 must be greater or equal to <TT>a1</TT>. </P>
<P><TT>fl_arc()</TT> draws a 1-pixel thick line (notice this has a 
different number of arguments than the <A href=#fl_arc><TT>fl_arc()</TT></A>
 described below. </P>
<P><TT>fl_pie()</TT> draws a filled-in pie slice.  This slice may 
extend outside the line drawn by <TT>fl_arc</TT>, to avoid this use <TT>
w - 1</TT> and <TT>h - 1</TT>. </P>
<H3><A name=complex>Complex Shapes</A></H3>
 These functions let you draw arbitrary shapes with 2-D linear 
transformations.  The functionality matches that found in Adobe&reg; 
PostScript<SUP>TM</SUP>.  The exact pixels that are filled is less defined 
than for the previous calls so that FLTK can take advantage of drawing 
hardware.  On both X and WIN32 the transformed vertices are rounded to integers before 
drawing the line segments: this severely limits the accuracy of these 
functions for complex graphics, so use OpenGL when greater accuracy 
and/or performance is required. 
<H4>void fl_push_matrix()
<BR> void fl_pop_matrix()</H4>
 Save and restore the current transformation.  The maximum depth of the 
stack is 4. 
<H4>void fl_scale(float x, float y)
<BR> void fl_scale(float x)
<BR> void fl_translate(float x, float y)
<BR> void fl_rotate(float d)
<BR> void fl_mult_matrix(float a,  float b,  float c,  float d,  float 
x,  float y)</H4>
 Concatenate another transformation onto the current one.  The rotation 
angle is in degrees (not radians) and is counter-clockwise. 

<h4>void fl_begin()</h4>

Clear the current "path" and start a new one.

<H4>void fl_vertex(float x, float y)</H4>

Add a single vertex to the current path. 

<h4>void fl_curve(float x, float y, float x1, float y1, float x2, float y2, float x3, float y3)</H4>

Add a series of points on a Bezier curve to the path.  The curve ends 
(and two of the points) are at <TT>x,y</TT> and <TT>x3,y3</TT>. 

<H4>void fl_arc(float x, float y, float r, float start, float end)</H4>

Add a series of points to the current path on the arc of a circle (you 
can get elliptical paths by using scale and rotate before calling 
this). <TT>x,y</TT> are the center of the circle, and <TT>r</TT> is its 
radius. <TT>fl_arc()</TT> takes <TT>start</TT> and <TT>end</TT> angles 
that are measured in degrees counter-clockwise from 3 o'clock.  If <TT>
end</TT> is less than <TT>start</TT> then it draws the arc in a 
clockwise direction. 

<H4>void fl_circle(float x, float y, float r)</H4>

<TT>fl_circle()</TT> is equivalent to <TT>fl_arc(...,0,360)</TT> but
may be faster.  It must be the <I>only</I> thing in the path: if you
want a circle as part of a complex polygon you must use
<TT>fl_arc()</TT>. <I>This draws incorrectly if the transformation is
both rotated and non-square scaled.</I>

<h4>void fl_gap()</h4>

Closes the current loop of the path by adding a segment to the first
point. Then this sets things up so the next point starts a new line
segment or loop. It is unnecessary but harmless to call
<TT>fl_gap()</TT> before the first vertex, after the last one, or
multiple times in a row.

<h4> void fl_end_points()</h4>

Draw each point in the current path as a dot.

<h4> void fl_end_line()</h4>

Draw the path as a line (see fl_line_type() for ways to set the
thicknesss and dot pattern of the line).

<h4>void fl_end_loop()</h4>

Draw a closed path with a line, by adding a segment back to the first
point and doing fl_end_line().

<h4>void fl_end_polygon()</h4>

Close the path and then fill with the current color.

<h4>void fl_end_complex_polygon()</h4>

Close the path and then fill with the current color. This invokes
extra logic so that non-convex polygons can be drawn correctly
(otherwise only convex polygons (all interior angles less or equal to
180 degrees) will draw correctly.

For portability, you should only draw polygons that appear the same
whether &quot;even/odd&quot; or &quot;non-zero&quot; winding rules are
used to fill them.  This mostly means that holes should be drawn in
the opposite direction of the outside.

<H3><A name=text>Text</A></H3>

<H4><A name=fl_font>
void fl_font(<a href=Fl_Font.html>Fl_Font</a>, unsigned size)</h4>

Set the current font.  It is scaled so that the point size is
<i>size</i> pixels tall (other transformations are not yet supported).
It is undefined if the font selection is affected by the current
transformation, so keep it the identity.

<h4>void fl_font(<a href=Fl_Font.html>Fl_Font</a>, unsigned size, const char* encoding)</h4>

<p>Select a font and name the encoding you would prefer to get.  If
the encoding cannot be found, one of the existing encodings is picked
at random.  The only way to find out what encodings are going to work
is to call <a href=Fl_Font.html>Fl_Font::encodings()</a>.

<p>This call is provided to handle some of the evils of present day
internationalization.  In the future I hope that UTF-8 encoding will
be supported by the window system and thus by fltk, avoiding the need
for this (and for "wide" characters which fltk does not and will never
support!).

<h4>extern const char* fl_encoding;</h4>

The default encoding to use, calling <tt>fl_font(f,s)</tt> is the same
as calling <tt>fl_font(f,s,fl_encoding)</tt>.  The default value of
this is "iso8859-1".

<h4>Fl_Font fl_font()</h4>

Returns the current font.

<h4>unsigned fl_size()</h4>

Returns the current font size.

<h4><a name=fl_draw>void fl_draw(const char*, float x, float y)
<br>void fl_draw(const char*, int n, float x, float y)</h4>

Draw a nul-terminated string or an array of <TT>n</TT> characters 
starting at the given location. 

<H4>void fl_draw(const char*, int x, int y, int w, int h, Fl_Flags)</H4>
Fancy string drawing function which is used to draw all the labels.
The string is formatted and aligned inside the passed box.  Handles
'\t' and '\n', expands all other control characters to ^X, and aligns
inside or against the edges of the box.  See <A
href=Fl_Labeltype.html> <TT>Fl_Labeltype_::draw()</TT></A> for values
for the flags.  The value <TT>FL_ALIGN_INSIDE</TT> is ignored, as this
function always prints inside the box.

<H4>int fl_height()</H4>

Returns the vertical size of the font according to the system.  It is
highly recommended that you use <tt>fl_size()</tt> instead for
portability and because many X fonts return erroneous values for this.

<H4>int fl_descent()</H4>
Recommended distance above the bottom of a <TT>fl_height()</TT> tall 
box to draw the text at so it looks centered vertically in that box. 

<H4>float fl_width(const char*)
<BR> float fl_width(const char*, int n)
<BR> float fl_width(uchar)</H4>
 Return the pixel width of a nul-terminated string, a sequence of <TT>n</TT>
 characters, or a single character in the current font. 
<H4>void fl_measure(const char*, int &amp;w, int &amp;h)</H4>
 Measure how wide and tall the string will be when printed by the <TT>
fl_draw(...align)</TT> function.  If the incoming <TT>w</TT> is 
non-zero it will wrap to that width. 

<H3><A name=overlay>Overlays</A></H3>
<H4>void fl_overlay_rect(int x, int y, int w, int h)
<BR> void fl_overlay_clear()</H4>
 These functions allow you to draw interactive selection rectangles 
without using the overlay hardware.  FLTK will XOR a single rectangle 
outline over a window. Calling this will erase any previous rectangle 
(by XOR'ing it), and then draw the new one.  Calling <TT>
fl_overlay_clear()</TT> will erase the rectangle without drawing a new 
one. 
<P>Using this is tricky. You should make a widget with both a <TT>
handle()</TT> and <TT>draw()</TT> method. <TT>draw()</TT> should call <TT>
fl_overlay_clear()</TT> before doing anything else.  Your <TT>handle()</TT>
 method should call <TT>window()-&gt;make_current()</TT> and then <TT>
fl_overlay_rect()</TT> after <TT>FL_DRAG</TT> events, and should call <TT>
fl_overlay_clear()</TT> after a <TT>FL_RELEASE</TT> event. </P>

<H2><A name=images>Images</A></H2>

To draw images, you can either do it directly from data in your
memory, or you can create an <a
href=Fl_Image.html><tt>Fl_Image</tt></a> subclass such as <A
href=Fl_Image.html#Fl_Bitmap><TT>Fl_Bitmap</TT></A>, <A
href=Fl_Image.html#Fl_RGB_Image> <TT>Fl_RGB_Image</TT></A>, or <A
href=Fl_Image.html#Fl_Pixmap><TT>Fl_Pixmap</TT></A> and call <a
href=Fl_Image.html#draw><tt>draw()</tt></a> on them.  The advantage of
drawing directly is that it is more intuitive, and it is faster if the
image data changes more often than it is redrawn.  The advantage of
using the object is that FLTK will cache translated forms of the image
(on X it uses a server pixmap) and thus redrawing is <I>much</I>
faster.  In addition, on current systems, <tt>Fl_Image</tt> is the
only way to get transparency or to draw 1-bit bitmaps.

<H3>Direct Image Drawing</H3>
 It is undefined whether the location or drawing of the image is 
affected by the current transformation, so you should only call these 
when it is the identity. 
<H4>void fl_draw_image(const uchar*, int X, int Y, int W, int H, int D 
= 3, int LD = 0)
<BR> void fl_draw_image_mono(const uchar*, int X, int Y, int W, int H, 
int D = 1, int LD = 0)</H4>
 Draw an 8-bit per color RGB or luminance image.  The pointer points at 
the &quot;r&quot; data of the top-left pixel.  Data must be in <TT>r,g,b</TT>
 order. <TT>X,Y</TT> are where to put the top-left corner. <TT>W</TT>
 and <TT>H</TT> define the size of the image. <TT>D</TT> is the delta 
to add to the pointer between pixels, it may be any value greater or 
equal to <TT>3</TT>, or it can be negative to flip the image 
horizontally. <TT>LD</TT> is the delta to add to the pointer between 
lines (if 0 is passed it uses <TT>W * D</TT>), and may be larger than <TT>
W * D</TT> to crop data, or negative to flip the image vertically. 
<P>It is highly recommended that you put the following code before the 
first <TT>show()</TT> of <I>any</I> window in your program to get rid 
of the dithering if possible: </P>
<UL>
<PRE>
Fl::visual(FL_RGB);
</PRE>
</UL>
 Gray scale (1-channel) images may be drawn.  This is done if <TT>abs(D)</TT>
 is less than 3, or by calling <TT>fl_draw_image_mono()</TT>.  Only one 
8-bit sample is used for each pixel, and on screens with different 
numbers of bits for red, green, and blue only gray colors are used. 
 Setting <TT>D</TT> greater than 1 will let you display one channel of 
a color image. 
<P><I>The X version does not support all possible visuals.</I> If FLTK 
cannot draw the image in the current visual it will abort.  FLTK 
supports any visual of 8 bits or less, and all common TrueColor visuals 
up to 32 bits. </P>
<H4>typedef void (*fl_draw_image_cb)(void*, int x, int y, int w, uchar 
*)
<BR> void fl_draw_image(fl_draw_image_cb, void*, int X, int Y, int W, 
int H, int D = 3)
<BR> void fl_draw_image_mono(fl_draw_image_cb, void*, int X, int Y, 
int W, int H, int D = 1)</H4>
 Call the passed function to provide each scan line of the image.  This 
lets you generate the image as it is being drawn, or do arbitrary 
decompression of stored data (provided it can be decompressed to 
individual scan lines easily). 
<P>The callback is called with the <TT>void*</TT> user data pointer 
(this can be used to point at a structure of information about the 
image), and the <TT>x</TT>, <TT>y</TT>, and <TT>w</TT> of the scan line 
desired from the image.  0,0 is the upper-left corner (<I>not <TT>X,Y</TT>
</I>).  A pointer to a buffer to put the data into is passed.  You must 
copy <TT>w</TT> pixels from scanline <TT>y</TT>, starting at pixel <TT>x</TT>
, to this buffer. </P>
<P>Due to cropping, less than the whole image may be requested.  So <TT>
x</TT> may be greater than zero, the first <TT>y</TT> may be greater 
than zero, and <TT>w</TT> may be less than <TT>W</TT>.  The buffer is 
long enough to store the entire <TT>W * D</TT> pixels, this is for 
convienence with some decompression schemes where you must decompress 
the entire line at once: decompress it into the buffer, and then if <TT>
x</TT> is not zero, copy the data over so the <TT>x</TT>'th pixel is at 
the start of the buffer. </P>
<P>You can assume the <TT>y</TT>'s will be consecutive, except the 
first one may be greater than zero. </P>
<P>If <TT>D</TT> is 4 or more, you must fill in the unused bytes with 
zero. </P>
<H4>int fl_draw_pixmap(char** data, int X, int Y, <a href=Fl_Color.html>Fl_Color</a> = FL_GRAY)</H4>
Draws XPM image data, with the top-left corner at the given position. 
The image is dithered on 8-bit displays so you won't lose color space 
for programs displaying both images and pixmaps.  This function returns 
zero if there was any error decoding the XPM data. 
<P>To use an XPM, do: </P>
<UL>
<PRE>
#include &quot;foo.xpm&quot;
...
fl_draw_pixmap(foo, X, Y);
</PRE>
</UL>
 In the current version the XPM data is converted to 24-bit RGB color 
and passed through <TT>fl_draw_image()</TT>.  This is obviously not the 
most efficient way to do it, and has the same visual limitations as 
listed above for <TT>fl_draw_image()</TT>.  Transparent colors are 
replaced by the optional <TT><a href=Fl_Color.html>Fl_Color</a></TT> argument (this may change in 
the future). 
<H4>int fl_measure_pixmap(char** data, int &amp;w, int &amp;h)</H4>
 An XPM image contains the dimensions in its data.  This function finds 
and returns the width and height.  The return value is non-zero if it 
parsed the dimensions ok, and zero if there is any problem. 

</BODY></HTML>
