<html><body>

<h1 align=right><a name=osissues>F - Operating System Issues</A></h1>

<hr>
<h1>X-Specific Interface</h1>

<UL><PRE>#include &lt;FL/x.H&gt;</PRE></UL>

On X you can include this file to access FLTK's X-specific functions. 
Be warned that some of the structures and calls in it are subject to 
change in future version of FLTK.  Try to avoid doing this so your code 
is portable. 

<h4><A name=add_handler>void Fl::add_handler(int (*f)(int))</A></h4>

Installs a function to parse unrecognized events.  If FLTK cannot 
figure out what to do with an event, it calls each of these functions 
(most recent first) until one of them returns non-zero.  If none of 
them returns non-zero then the event is ignored. 

<P>FLTK calls this for any X events it does not recognize, or X events
with a window id that FLTK does not recognize, or for events when the
widget's handle function returns zero.  You can look at the X event
with the <A href=#fl_xevent><TT>fl_xevent</TT></A> variable.

<P>The argument is the event number (like <tt>FL_PUSH</tt>).  For X
events that fltk does not understand, it is zero.  For keystrokes it
will be <tt>FL_SHORTCUT</tt>.

<h4><A name=fl_xevent>extern XEvent* fl_xvent</A></h4>

The most recent X event. 

<h4><A name=fl_event_time>extern ulong fl_event_time</A></h4>

This is the time stamp from the most recent X event that reported it 
(not all do).  Many X calls (like cut and paste) need this value. 

<h4><A name=fl_handle>int fl_handle(const XEvent &amp;)</A></h4>

This call allows you to supply the X events to FLTK, which may allow 
FLTK to cooperate with another toolkit or library.  The return value is 
true if FLTK understood the event (if the window does not belong to 
FLTK and the <TT>add_handler()</TT> functions all ignore it this 
returns false). 

<P>Besides feeding events your code should call <A href=functions.html#flush>
<TT>Fl::flush()</TT></A> periodically so that FLTK redraws its windows. </P>

<P>This function will call the callback functions.  It will not return 
until they complete.  In particular if a callback pops up a modal 
window (by calling <A href=functions.html#fl_ask><TT>fl_ask()</TT></A>, 
for instance) it will not return until the modal function returns. </P>

<h4><A name=display>int Fl::display(const char*)</A></h4>

Set which X display to use.  This actually does <TT>
putenv(&quot;DISPLAY=...&quot;)</TT> so that child programs will
display on the same screen if called with <TT>exec()</TT>.  This must
be done before <tt>fl_open_display</tt> is called.  This call is
provided under WIN32 but it has no effect.

<h4><A name=fl_open_display>void fl_open_display()</A></h4>

Opens the display.  Does nothing if it is already open.  You should
call this if you wish to do X calls and there is a chance that your
code will be called before the first <TT>show()</TT> of a window.
This is called automatically <tt>by Fl_Window::show()</tt>.

<P>This may call <TT>Fl::abort()</TT> if there is an error opening the 
display.

<h4>void fl_open_display(Display*)</A></h4>

You can make fltk "open" a display that has already been opened,
perhaps by another GUI library.  Calling this will set
<tt>fl_display</tt> to the passed display and also read information
fltk needs from it.  You can only call this once.

<h4><A name=fl_display>extern Display* fl_display</A></h4>

The open X display.  This is needed as an argument to most Xlib calls. 
Don't attempt to change it!  This is <TT>NULL</TT> before
<tt>fl_open_display</tt> is called.

<h4><A name=fl_message_window>extern Window fl_message_window</A></h4>

This dummy 1x1 window is created by <tt>fl_open_display()</tt> and is
never destroyed.  You can use it to communicate with the window
manager or other programs.

<h4><A name=fl_screen>extern int fl_screen</A></h4>

Which screen number to use.  This is set by <TT>fl_open_display()</TT>
to the default screen.  You can change it by setting this to a 
different value immediately afterwards.

<h4><A name=fl_visual>extern XVisualInfo* fl_visual</A>
<br><A name=fl_colormap>extern Colormap fl_colormap</A></h4>

The visual and colormap that FLTK will use for all windows.  These are 
set by <TT>fl_open_display()</TT> to the default visual and colormap. 
You can change them before calling <TT>show()</TT> on the first 
window.  Typical code for changing the default visual is: 

<UL><PRE>Fl::args(argc, argv); // do this first so $DISPLAY is set
fl_open_display();
fl_visual = find_a_good_visual(fl_display, fl_screen);
if (!fl_visual) Fl::abort(&quot;No good visual&quot;);
fl_colormap = make_a_colormap(fl_display, fl_visual-&gt;visual, fl_visual-&gt;depth);
// it is now ok to show() windows:
window-&gt;show(argc, argv);</PRE></UL>

You may also want to call <A
href=functions.html#visual>Fl::visual()</A>, which is a portable
interface to get a full color and/or double buffered visual.

<h4><A name=fl_xid>Window fl_xid(const Fl_Window*)</A></h4>

Returns the XID for a window, or zero if not <TT>shown()</TT>. 

<h4><A name=fl_find>Fl_Window* fl_find(ulong xid)</A></h4>

Returns the <TT>Fl_Window</TT> that corresponds to the given XID, or
<TT>NULL</TT> if not found.  This uses a cache so it is slightly
faster than iterating through the windows yourself.

<h4><a name=fl_window>extern Window fl_window;
<br><a name=fl_gc>extern GC fl_gc;</h4>

These variables are set before <TT>Fl_Widget::draw()</TT>
is called, or by <A href=Fl_Window.html#Fl_Window.make_current><TT>
Fl_Window::make_current()</TT></a>.  They are needed by most Xlib
drawing calls, a typical call is like this:

<UL><PRE>XDrawSomething(fl_display, fl_window, fl_gc, ...);</PRE></UL>

<p>Notice that <tt>fl_window</tt> is the X window id number.  Other
information such as the position or size of the X window can be found
by looking at <A href=Fl_Window.html#Fl_Window.make_current><TT>
Fl_Window::current()</TT></A>, which returns a pointer to the <TT>
Fl_Window</TT> being drawn.

<h4><a name=fl_xpixel>unsigned long fl_xpixel(Fl_Color i)</a></h4>

Returns the X pixel number used to draw the given FLTK color index or
RGB color. This is the X pixel that <A
href=drawing.html#fl_color><TT>fl_color(i)</TT> </A> would use.

<h4><A name=fl_xfont>extern XFontStruct* fl_xfont</A></h4>

Points at the font selected by the most recent <A
href=drawing.html#fl_font><TT>fl_font()</TT></A>.  This is not
necessarily the current font of <TT>fl_gc</TT>, which is not set
until <A href=drawing.html#fl_draw><TT>fl_draw()</TT></A> is called.

<h4><A name=fl_close_display>void fl_close_display()</A></h4>

This closes the X connection.  You do <I>not</I> need to call this to 
exit, and in fact it is faster to not do so!  It may be useful to call 
this if you want your program to continue without the X connection. You 
cannot open the display again, and probably cannot call any FLTK 
functions. 

<h4><A name=Fl_Window.xclass>static void Fl_Window::xclass(const char*)
<br>static const char* Fl_Window::xclass() const</A></h4>

This string is used to set the <TT>XA_WM_CLASS</TT> property of all
the windows fltk creates.  The default value is "fltk".  Many window
managers can use this string to select an icon.  <a
href=functions.html#args><tt>Fl::args(...)</tt></a> will set this to
the name of the program.

<p>This call is provided on WIN32 for compatability, but the value is
ignored.

<h4>void Fl_Window::icon(char*)</h4>

Sets the icon for the window to the passed pointer.  You will need to 
cast the icon <TT>Pixmap</TT> to a <TT>char*</TT> when calling this 
method. To set the icon using a bitmap compiled with your application 
use:

<UL><PRE>#include &quot;icon.xbm&quot;

Pixmap p = XCreateBitmapFromData(fl_display, DefaultRootWindow(fl_display),
                                 icon_bits, icon_width, icon_height);

window-&gt;icon((char*)p);</PRE></UL>

<p>This only works if called <i>before</i> it is shown using the
<TT>Fl_Window::show()</TT> method.

<h3>Using a Subclass of Fl_Window for Special X Stuff</h3>

FLTK can manage an X window on a different screen, visual and/or 
colormap, you just can't use FLTK's drawing routines to draw into it. 
But you can write your own <TT>draw()</TT> method that uses Xlib 
(and/or OpenGL) calls only. 

<P>To do this, you need to make a subclass of <A href=Fl_Window.html#Fl_Window>
<TT>Fl_Window</TT></A> and override some of these virtual functions: </P>

<h4>virtual void Fl_Window::create()</h4>

Creates the X window, and perhaps other data such as colormaps needed
by this window.  To create the X window you must call
<TT>Fl_X::create()</TT>.  Do not map the window, fltk does that for you.

<P>An example:

<UL><PRE>void MyWindow::create() {
  fl_open_display();	// necessary if this is first window
  // we only calcualte the necessary visual & colormap once:
  static XVisualInfo* visual;
  static Colormap colormap;
  static int background;
  if (!visual) {
    visual = figure_out_visual();
    colormap = XCreateColormap(fl_display, RootWindow(fl_display,fl_screen),
			        vis-&gt;visual, AllocNone);
    XColor xcol; xcol.red = 1; xcol.green = 2; xcol.blue = 3;
    XAllocColor(fl_display, colormap, &xcol);
    background = xcol.pixel;
  }
  Fl_X::create(this, visual, colormap, background);
}</PRE></UL>

<h4>void Fl_X::create(Fl_Window*, XVisualInfo*, Colormap, int background=-1)</h4>

This function calls XCreateWindow and sets things up so that
<tt>fl_xid(window)</tt> returns the created window id.  This also does
a lot of other ugly X stuff, including setting the label, resize
limitations, etc.  The
background is a pixel to use for X's automatic fill color, use -1 to
indicate that no background filling should be done.

<h4>virtual void Fl_Window::flush()</h4>

This virtual function is called by <TT>Fl::flush()</TT> to update the
window. For FLTK's own windows it does this by setting the global
variables <TT>fl_window</TT> and <TT>fl_gc</TT> and then calling the
<TT>draw()</TT> method.  For your own windows you might just want to
put all the drawing code in here.

<P>The X region that is a combination of all <TT>damage()</TT> calls
done so far is in <TT>Fl_X::i(this)-&gt;region</TT>.  If <TT>NULL</TT>
then you should redraw the entire window.  The undocumented function
<TT>fl_clip_region(XRegion)</TT> will initialize the FLTK clip stack
with a region or <TT>NULL</TT> for no clipping.  You must set region
to <TT>NULL</TT> afterwards as <TT>fl_clip_region()</TT> now owns it
and will delete it when done.

<P>If <TT>damage() == FL_DAMAGE_EXPOSE</TT> then only X expose
events have happened.  This may be useful if you have an undamaged
image (such as a backing buffer) around.

<P>Here is a sample where an undamaged image is kept somewhere: </P>

<UL><PRE>void MyWindow::flush() {
  fl_clip_region(Fl_X::i(this)-&gt;region);
  Fl_X::i(this)-&gt;region = 0;
  if (damage() != 2) {
    fl_window = backing_store_pixmap;
    fl_gc = backing_store_gc;
    this->draw();
  }
  copy_image(backing_store_pixmap, fl_xid(this));
}</PRE></UL>

<h4>virtual void Fl_Window::destroy()</h4>

Destroy the window server copy of the window.  Usually you will 
destroy contexts, pixmaps, or other resources used by the window, and 
then call <TT>Fl_Window::hide()</TT> to get rid of the main window 
identified by <TT>xid()</TT>.  If you override this, you must also 
override the destructor as shown: 

<UL><PRE>void MyWindow::destroy() {
  if (mypixmap) {
    XFreePixmap(fl_display,mypixmap);
    mypixmap = 0;
  }
  Fl_Window::destroy(); // you must call this
}</PRE></UL>

<h4>virtual void Fl_Window::~Fl_Window()</h4>

Because of the way C++ works, if you override <TT>destroy()</TT> you
<I>must</I> override the destructor as well (otherwise only the base
class <TT>destroy()</TT> is called):

<UL><PRE>MyWindow::~MyWindow() {
  destroy();
}</PRE></UL>

<hr>
<h1>WIN32-Specific Interface</h1>

<UL><PRE>#include &lt;FL/x.H&gt;</PRE></UL>

The <TT>&lt;FL/x.H&gt;</TT> header file defines the interface to FLTK's 
WIN32-specific functions.  Be warned that some of the structures and 
calls in it are subject to change in future version of FLTK.  Try to 
avoid doing this so your code is portable. 

<p>Fltk creates a single WNDCLASSEX called &quot;FLTK&quot;.  The
window class is created the first time <TT>Fl_Window::show()</TT> is
called.

<P>You can probably combine FLTK with other libraries that make their
own WIN32 window classes.  The easiest way is to call
<TT>Fl::wait()</TT>, it will call <TT>DispatchMessage</TT> for all
messages to the other windows.  If necessary you can let the other
library take over (as long as it calls <TT>DispatchMessage()</TT>),
but you will have to arrange for the function <TT>Fl::flush()</TT> to
be called regularily so that widgets are updated, timeouts are
handled, and the idle functions are called.

<h4><A name=WIN32.add_handler>void Fl::add_handler(int (*f)(int))</A></h4>

Install a function to parse unrecognized messages sent to FLTK 
windows.  If FLTK cannot figure out what to do with a message, it calls 
each of these functions (most recent first) until one of them returns 
non-zero.  The argument passed to the fuctions is zero.  If all the 
handlers return zero then FLTK calls <TT>DefWindowProc()</TT>. 

<h4><A name=fl_msg>extern MSG fl_msg</A></h4>

The most recent message read by <TT>GetMessage</TT> (which is called 
by <A href=functions.html#wait><TT>Fl::wait()</TT></A>.  This may not 
be the most recent message sent to an FLTK window (because our
fun-loving friends at MicroSoft decided that calling the handle
procedures directly would be a good idea sometimes...)

<h4><A name=WIN32.fl_xid>HWND fl_xid(const Fl_Window*)</A></h4>

Returns the window handle for a <TT>Fl_Window</TT>, or zero if not
<TT>shown()</TT>.

<h4><A name=WIN32.fl_find>Fl_Window* fl_find(HWND xid)</A></h4>

Return the <TT>Fl_Window</TT> that corresponds to the given window 
handle, or <TT>NULL</TT> if not found.  This uses a cache so it is 
slightly faster than iterating through the windows yourself. 

<h4><A name=fl_display>extern HINSTANCE fl_display;</h4>

This is set on program initialization to <tt>GetModuleHandle(0)</tt>
and can be used to identify this application.

<h4><a name=fl_window>extern HWND fl_window;
<br><a name=fl_gc>extern HDC fl_gc;</h4>

These are set before <tt>draw()</tt> is called, or by <a
href=Fl_Window.html#Fl_Window.make_current><tt>Fl_Window::make_current()</tt>,
and can be used as arguments to GDI32 calls.

<p>Notice that <tt>fl_window</tt> is the window handle.  Other
information such as the position or size of the window can be found
by looking at <A href=Fl_Window.html#Fl_Window.make_current><TT>
Fl_Window::current()</TT></A>, which returns a pointer to the <TT>
Fl_Window</TT> being drawn.

<h4><a name=fl_rgb>extern COLORREF fl_rgb;
<br><a name=fl_pen>extern HPEN fl_pen;
<br><a name=fl_brush>extern HBRUSH fl_brush;</h4>

These are set by <a href=drawing.html#fl_color><tt>fl_color()</tt></a>
and by <a href=drawing.html#fl_line_style><tt>fl_line_style()</tt></a>,
by using these in your drawing calls you can provide the illusion that
GDI has a color in it's graphics state.

<h4>void Fl_Window::icon(char*)</h4>

Sets the icon for the window to the passed pointer.  You will need to 
cast the <TT>HICON</TT> handle to a <TT>char*</TT> when calling this 
method. To set the icon using an icon resource compiled with your 
application use: 

<UL><PRE>
window-&gt;icon((char*)LoadIcon(fl_display, MAKEINTRESOURCE(IDI_ICON)));
</PRE></UL>

<p>This only works if called <i>before</i> it is shown using the
<TT>Fl_Window::show()</TT> method.

<h3>How to Not Get a MSDOS Console Window</h3>

WIN32 has a really stupid mode switch stored in the executables that 
controls whether or not to make a console window. 

<P>To always get a console window you simply create a console 
application (the &quot;/SUBSYSTEM:CONSOLE&quot; option for the linker).  For a 
GUI-only application create a WIN32 application (the 
&quot;/SUBSYSTEM:WINDOWS&quot; option for the linker). </P>

<P>FLTK includes a <TT>WinMain()</TT> function that calls the ANSI 
standard <TT>main()</TT> entry point for you. <i>This function creates 
a console window when you use the debug version of the library.</i>

<P>WIN32 applications without a console cannot write to <TT>stdout</TT>
or <TT>stderr</TT>, even if they are run from a console window.  Any 
output is silently thrown away.

<h3>Known Bugs</h3>

If a program is deactivated, <TT>Fl::wait()</TT> does not return until 
it is activated again, even though many events are delivered to the 
program. This can cause idle background processes to stop unexpectedly. 
This also happens while the user is dragging or resizing windows or 
otherwise holding the mouse down.  I was forced to remove most of the 
efficiency FLTK uses for redrawing in order to get windows to update 
while being moved.  This is a design error in WIN32 and probably 
impossible to get around. 

<P>Cut text contains ^J rather than ^M^J to break lines.  This is a 
feature, not a bug.

</body></html>
