<html>
<body>

<hr break>

<h2><a name="Fl_Output">class Fl_Output</a></h2>

<hr>

<h3>Class Hierarchy</h3>

<ul><pre>
<a href="#Fl_Input_">Fl_Input_</a>
   |
   +----<b>Fl_Output</b>
           |
           +----<a href="#Fl_Multiline_Output">Fl_Multiline_Output</a>
</pre></ul>

<h3>Include Files</h3>

<ul><pre>
#include &lt;FL/Fl_Output.H>
</pre></ul>

<h3>Description</h3>

This widget displays a piece of text.  When you set the <tt>value()</tt>,
<tt>Fl_Output</tt> does a <tt>strcpy()</tt> to it's own storage, which is useful for
program-generated values.  The user may select portions of the text
using the mouse and paste the contents into other fields or programs.

<p><img src=text.gif>

<p>There is a single subclass, <a
href="#Fl_Multiline_Output">Fl_Multiline_Output</a>, which allows you to
display multiple lines of text.

<p>The text may contain any characters except \0, and will correctly
display anything, using ^X notation for unprintable control characters
and \nnn notation for unprintable characters with the high bit set. It
assummes the font can draw any characters in the ISO-Latin1 character
set.

<h3>Methods</h3>

<ul>
	<li><a href="#Fl_Output.Fl_Output">Fl_Output</a>
	<li><a href="#Fl_Output.~Fl_Output">~Fl_Output</a>
	<li><a href="#Fl_Output.cursor_color">cursor_color</a>
	<li><a href="#Fl_Output.index">index</a>
	<li><a href="#Fl_Output.size">size</a>
	<li><a href="#Fl_Output.textcolor">textcolor</a>
	<li><a href="#Fl_Output.textfont">textfont</a>
	<li><a href="#Fl_Output.textsize">textsize</a>
	<li><a href="#Fl_Output.value">value</a>
</ul>

<h4><a name="Fl_Output.Fl_Output">Fl_Output::Fl_Output(int x, int y, int w, int h, const char *label = 0)</a></h4>

Creates a new <tt>Fl_Output</tt> widget using the given position, size, and
label string. The default boxtype is <tt>FL_DOWN_BOX</tt>.

<h4><a name="Fl_Output.~Fl_Output">virtual Fl_Output::~Fl_Output()</a></h4>

Destroys the widget and any value associated with it.

<h4><a name="Fl_Output.value">const char *Fl_Output::value() const<br>
int Fl_Output::value(const char*)<br>
int Fl_Output::value(const char*, int)</a></h4>

The first form returns the current value, which is a pointer to the
internal buffer and is valid only until the value is changed.

<p>The second two forms change the text and set the mark and the point
to the end of it. The string is copied to the internal buffer.  Passing
<tt>NULL</tt> is the same as "".  This returns non-zero if the new
value is different than the current one.  You can use the second
version to directly set the length if you know it already or want to
put nul's in the text.

<h4><a name="Fl_Output.size">int Fl_Output::size() const</a></h4>

Returns the number of characters in <tt>value()</tt>.  This may be greater than
<tt>strlen(value())</tt> if there are nul characters in it.

<h4><a name="Fl_Output.index">char Fl_Output::index(int) const</a></h4>

Same as <tt>value()[n]</tt>, but may be faster in plausible implementations.
No bounds checking is done.

<h4><a name="Fl_Output.textcolor">Fl_Color Fl_Output::textcolor() const<br>
void Fl_Output::textcolor(Fl_Color)</a></h4>

Gets or sets the color of the text in the input field.

<h4><a name="Fl_Output.textfont">Fl_Font Fl_Output::textfont() const<br>
void Fl_Output::textfont(Fl_Font)</a></h4>

Gets or sets the font of the text in the input field.

<h4><a name="Fl_Output.textsize">uchar Fl_Output::textsize() const<br>
void Fl_Output::textsize(uchar)</a></h4>

Gets or sets the size of the text in the input field.

</body>
</html>
