<HTML><BODY>
<HR break>
<H2><A name=Fl_Input>class Fl_Input</A></H2>
<HR>
<H3>Class Hierarchy</H3>
<UL>
<PRE>
<A href=Fl_Input_.html#Fl_Input_>Fl_Input_</A>
   |
   +----<B>Fl_Input</B>
           |
           +----<A href=Fl_Float_Input.html#Fl_Float_Input>Fl_Float_Input</A>, <A href=Fl_Int_Input.html#Fl_Int_Input>Fl_Int_Input</A>,
                <A href=Fl_Multiline_Input.html#Fl_Multiline_Input>Fl_Multiline_Input</A>, <A href=Fl_Secret_Input.html#Fl_Secret_Input>Fl_Secret_Input</A>
</PRE>
</UL>
<H3>Include Files</H3>
<UL>
<PRE>
#include &lt;FL/Fl_Input.H&gt;
</PRE>
</UL>
<H3>Description</H3>
 This is the FLTK text input widget.  It displays a single line of text 
and lets the user edit it.  Normally it is drawn with an inset box and 
a white background.  The text may contain any characters (even 0), and 
will correctly display anything, using ^X notation for unprintable 
control characters and \nnn notation for unprintable characters with 
the high bit set. It assummes the font can draw any characters in the 
ISO8859-1 character set. 
<CENTER><TABLE border=1 WIDTH=90%>
<TR><TD WIDTH=200><B>Mouse button 1</B></TD><TD>Moves the cursor to this point. 
 Drag selects characters.  Double click selects words.  Triple click 
selects all text.  Shift+click extends the selection.</TD></TR>
<TR><TD><B>Mouse button 2</B></TD><TD>Insert the current X selection at 
the cursor (unlike Motif this does not move the insertion point to the 
mouse).  If the widget does not have the input focus (and thus no 
cursor) it puts the cursor where clicked and inserts the selection 
there.</TD></TR>
<TR><TD><B>Mouse button 3</B></TD><TD>Currently acts like button 1.</TD></TR>
<TR><TD><B>Backspace</B></TD><TD>Deletes one character to the left, or 
deletes the selected region.</TD></TR>
<TR><TD><B>Enter</B></TD><TD>May cause the callback, see when().</TD></TR>
<TR><TD><B>^A or Home</B></TD><TD>Go to start of line.</TD></TR>
<TR><TD><B>^B or Left</B></TD><TD>Move left</TD></TR>
<TR><TD><B>^C</B></TD><TD>Copy the selection to the clipboard</TD></TR>
<TR><TD><B>^D or Delete</B></TD><TD>Deletes one character to the right 
or deletes the selected region. <I>Due to silly historical X problems, 
the Delete key will act like Backspace until you type a &quot;real&quot; 
backspace.</I></TD></TR>
<TR><TD><B>^E or End</B></TD><TD>Go to the end of line.</TD></TR>
<TR><TD><B>^F or Right</B></TD><TD>Move right</TD></TR>
<TR><TD><B>^K</B></TD><TD>Delete to the end of line (next \n character) 
or deletes a single \n character.  These deletions are all concatenated 
into the clipboard.</TD></TR>
<TR><TD><B>^N or Down</B></TD><TD>Move down (for Fl_Multiline_Input 
only, otherwise it moves to the next input field).</TD></TR>
<TR><TD><B>^P or Up</B></TD><TD>Move up (for Fl_Multiline_Input only, 
otherwise it moves to the previous input field).</TD></TR>
<TR><TD><B>^Q or
<BR>RightCtrl or
<BR>Compose</B></TD><TD>Start a <A href="events.html#compose">compose-character</A>
 sequence.  The next one or two keys typed define the character to 
insert.  This also can be used to &quot;quote&quot; control characters.</TD></TR>
<TR><TD><B>^U</B></TD><TD>Delete everything.</TD></TR>
<TR><TD><B>^V or ^Y</B></TD><TD>Paste the clipboard</TD></TR>
<TR><TD><B>^X or ^W</B></TD><TD>Copy the region to the clipboard and 
delete it.</TD></TR>
<TR><TD><B>^Z or ^_</B></TD><TD>Undo.  This is a single-level undo 
mechanism, but all adjacent deletions and insertions are concatenated 
into a single &quot;undo&quot;.  Often this will undo a lot more than you 
expected.</TD></TR>
<TR><TD><B>Shift+move</B></TD><TD>Move the cursor but also extend the 
selection.</TD></TR>
</TABLE></CENTER>
<H3>Methods</H3>
<CENTER>
<TABLE width=90%>
<TR><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Input.Fl_Input>Fl_Input</A></LI>
<LI><A href=#Fl_Input.~Fl_Input>~Fl_Input</A></LI>
<LI><A href=#Fl_Input.cursor_color>cursor_color</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Input.index>index</A></LI>
<LI><A href=#Fl_Input.size>size</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Input.static_value>static_value</A></LI>
<LI><A href=#Fl_Input.textcolor>textcolor</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Input.textfont>textfont</A></LI>
<LI><A href=#Fl_Input.textsize>textsize</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Input.value>value</A></LI>
<LI><A href=#Fl_Input.when>when</A></LI>
</UL>
</TD></TR>
</TABLE>
</CENTER>
<H4><A name=Fl_Input.Fl_Input>Fl_Input::Fl_Input(int x, int y, int w, 
int h, const char *label = 0)</A></H4>
 Creates a new <TT>Fl_Input</TT> widget using the given position, size, 
and label string. The default boxtype is <TT>FL_DOWN_BOX</TT>. 
<H4><A name=Fl_Input.~Fl_Input>virtual Fl_Input::~Fl_Input()</A></H4>
 Destroys the widget and any value associated with it. 
<H4><A name=Fl_Input.value>const char *Fl_Input::value() const
<BR> int Fl_Input::value(const char*)
<BR> int Fl_Input::value(const char*, int)</A></H4>
 The first form returns the current value, which is a pointer to the 
internal buffer and is valid only until the next event is handled. 
<P>The second two forms change the text and set the mark and the point 
to the end of it. The string is copied to the internal buffer.  Passing <TT>
NULL</TT> is the same as &quot;&quot;.  This returns non-zero if the new value is 
different than the current one.  You can use the second version to 
directly set the length if you know it already or want to put nul's in 
the text. </P>
<H4><A name=Fl_Input.static_value>int Fl_Input::static_value(const 
char*)
<BR> int Fl_Input::static_value(const char*, int)</A></H4>
 Change the text and set the mark and the point to the end of it.  The 
string is <I>not</I> copied.  If the user edits the string it is copied 
to the internal buffer then.  This can save a great deal of time and 
memory if your program is rapidly changing the values of text fields, 
but this will only work if the passed string remains unchanged until 
either the <TT>Fl_Input</TT> is destroyed or <TT>value()</TT> is called 
again. 
<H4><A name=Fl_Input.size>int Fl_Input::size() const</A></H4>
 Returns the number of characters in <TT>value()</TT>.  This may be 
greater than <TT>strlen(value())</TT> if there are nul characters in 
it. 
<H4><A name=Fl_Input.index>char Fl_Input::index(int) const</A></H4>
 Same as <TT>value()[n]</TT>, but may be faster in plausible 
implementations. No bounds checking is done. 
<H4><A name=Fl_Input.when>Fl_When Fl_Widget::when() const
<BR> void Fl_Widget::when(Fl_When)</A></H4>
 Controls when callbacks are done.  The following values are useful, 
the default value is <TT>FL_WHEN_RELEASE</TT>: 
<UL>
<LI><TT>0</TT>: The callback is not done, but <TT>changed()</TT> is 
 turned on. </LI>
<LI><TT>FL_WHEN_CHANGED</TT>: The callback is done each time the  text 
is changed by the user. </LI>
<LI><TT>FL_WHEN_RELEASE</TT>: The callback will  be done when this 
widget loses the focus, including when the window is  unmapped.  This 
is a useful value for text fields in a panel where  doing the callback 
on every change is wasteful.  However the callback  will also happen if 
the mouse is moved out of the window, which means  it should not do 
anything visible (like pop up an error message).  You  might do better 
setting this to zero, and scanning all the items for <TT>changed()</TT>
 when the OK button on a panel is pressed. </LI>
<LI><TT>FL_WHEN_ENTER_KEY</TT>: If the user types the Enter  key, the 
entire text is selected, and the callback is done if  the text has 
changed.  Normally the Enter key will navigate to  the next field (or 
insert a newline for a <TT>Fl_Mulitline_Input</TT>), this changes the 
behavior. </LI>
<LI><TT>FL_WHEN_ENTER_KEY|FL_WHEN_NOT_CHANGED</TT>: The Enter key  will 
do the callback even if the text has not changed.  Useful for  command 
fields. </LI>
</UL>
<H4><A name=Fl_Input.textcolor>Fl_Color Fl_Input::textcolor() const
<BR> void Fl_Input::textcolor(Fl_Color)</A></H4>
 Gets or sets the color of the text in the input field. 
<H4><A name=Fl_Input.textfont>Fl_Font Fl_Input::textfont() const
<BR> void Fl_Input::textfont(Fl_Font)</A></H4>
 Gets or sets the font of the text in the input field. 
<H4><A name=Fl_Input.textsize>uchar Fl_Input::textsize() const
<BR> void Fl_Input::textsize(uchar)</A></H4>
 Gets or sets the size of the text in the input field. 
<H4><A name=Fl_Input.cursor_color>Fl_Color Fl_Input::cursor_color() 
const
<BR> void Fl_Input::cursor_color(Fl_Color)</A></H4>
 Get or set the color of the cursor.  This is black by default.

</BODY></HTML>
