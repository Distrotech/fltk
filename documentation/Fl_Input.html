<html><head><link href="fltk.css" rel="stylesheet" type="text/css">
<title>class fltk::Input</title></head><body>
<!-- NEW PAGE -->
<h2>class fltk::Input</h2>
<hr>

<H3>Class Hierarchy</H3>
<PRE>
<A href=Fl_Widget.html#Widget>fltk::Widget</A>
   |
   +----<B>fltk::Input</B>
           |
           +----<A href=Fl_Float_Input.html#FloatInput>fltk::FloatInput</A>, <A href=Fl_Int_Input.html#IntInput>fltk::IntInput</A>,
                <A href=Fl_Multiline_Input.html#MultilineInput>fltk::MultilineInput</A>, <A href=Fl_Secret_Input.html#SecretInput>fltk::SecretInput</A>, <A href=Fl_Output.html#Output>fltk::Output</A>
</PRE>
<H3>Include Files</H3>
<PRE>
#include &lt;fltk/Input.h&gt;
</PRE>
<H3>Description</H3>

 This is the FLTK text input widget.  It displays a single line of
text and lets the user edit it.  Normally it is drawn with an inset
box and a white background.  The text may contain any characters (even
0).  The unprintable control characters are displayed with ^X
notation.  The appearance of other characters will depend on your
operating system.

<p>
<CENTER><TABLE border=1 WIDTH=90%>

<TR><TD WIDTH=200><B>Mouse button 1</B></TD><TD>Moves the cursor to
 this point. Drag selects characters.  Double click selects words.
 Triple click selects all text.  Shift+click extends the selection.
 When you select text it is automatically copied to the clipboard.
</TD></TR>

<TR><TD><B>Mouse button 2</B></TD><TD>Insert the clipboard at
the point clicked.  You can also select a region and replace it with the
clipboard by selecting the region with mouse button 2.
</TD></TR>

<TR><TD><B>Mouse button 3</B></TD><TD>Currently acts like button 1.</TD></TR>

<TR><TD><B>Backspace</B></TD><TD>Deletes one character to the left, or 
deletes the selected region.</TD></TR>
<TR><TD><B>Enter</B></TD><TD>May cause the callback, see when().</TD></TR>
<TR><TD><B>^A or Home</B></TD><TD>Go to start of line.</TD></TR>
<TR><TD><B>^B or Left</B></TD><TD>Move left</TD></TR>
<TR><TD><B>^C</B></TD><TD>Copy the selection to the clipboard</TD></TR>
<TR><TD><B>^D or Delete</B></TD><TD>Deletes one character to the right 
or deletes the selected region.</TD></TR>
<TR><TD><B>^E or End</B></TD><TD>Go to the end of line.</TD></TR>
<TR><TD><B>^F or Right</B></TD><TD>Move right</TD></TR>
<TR><TD><B>^K</B></TD><TD>Delete to the end of line (next \n character) 
or deletes a single \n character.  These deletions are all concatenated 
into the clipboard.</TD></TR>
<TR><TD><B>^N or Down</B></TD><TD>Move down (for fltk::MultilineInput 
only, otherwise it moves to the next input field).</TD></TR>
<TR><TD><B>^O</B></TD><TD>Insert a newline and put the cursor before it.</TD></TR>
<TR><TD><B>^P or Up</B></TD><TD>Move up (for fltk::MultilineInput only, 
otherwise it moves to the previous input field).</TD></TR>
<TR><TD><B>^T</B></TD><TD>Swap the two characters around the cursor,
or the two characters before it if at the end of line.</TD></TR>
<TR><TD><B>^U</B></TD><TD>Delete everything.</TD></TR>
<TR><TD><B>^V or ^Y</B></TD><TD>Paste the clipboard</TD></TR>
<TR><TD><B>^X or ^W</B></TD><TD>Copy the region to the clipboard and 
delete it.</TD></TR>
<TR><TD><B>^Z or ^_</B></TD><TD>Undo.  This is a single-level undo 
mechanism, but all adjacent deletions and insertions are concatenated 
into a single &quot;undo&quot;.  Often this will undo a lot more than you 
expected.</TD></TR>
<TR><TD><B>Shift+move</B></TD><TD>Move the cursor but also extend the 
selection.</TD></TR>

<TR><TD><B>RightCtrl or
<BR>Compose</B></TD><TD><a name=compose>
Start a <A href="Fl.html#compose">compose-character</A>
sequence.  The next one or two keys typed define the character to insert:

<br><center><table border=1>
<tr>
	<th>Keys</th><th>Char</th>
	<th>Keys</th><th>Char</th>
	<th>Keys</th><th>Char</th>
	<th>Keys</th><th>Char</th>
	<th>Keys</th><th>Char</th>
	<th>Keys</th><th>Char</th>

</tr><tr>
	<td align=center><small>space</small></td><td align=center><small>nbsp</small></td>
	<td align=center><TT>*</tt></td><td align=center>°</td>
	<td align=center><TT>`A</tt></td><td align=center>À</td>
	<td align=center><TT>D-</tt></td><td align=center>Ð</td>
	<td align=center><TT>`a</tt></td><td align=center>à</td>
	<td align=center><TT>d-</tt></td><td align=center>ð
</tr><tr>
	<td align=center><TT>!</tt></td><td align=center>¡</td>
	<td align=center><TT>+-</tt></td><td align=center>±</td>
	<td align=center><TT>'A</tt></td><td align=center>Á</td>
	<td align=center><TT>~N</tt></td><td align=center>Ñ</td>
	<td align=center><TT>'a</tt></td><td align=center>á</td>
	<td align=center><TT>~n</tt></td><td align=center>ñ
</tr><tr>
	<td align=center><TT>c|</tt></td><td align=center>¢</td>
	<td align=center><TT>2</tt></td><td align=center>²</td>
	<td align=center><TT>A^</tt></td><td align=center>Â</td>
	<td align=center><TT>`O</tt></td><td align=center>Ò</td>
	<td align=center><TT>^a</tt></td><td align=center>â</td>
	<td align=center><TT>`o</tt></td><td align=center>ò
</tr><tr>
	<td align=center><TT>L-</tt></td><td align=center>£</td>
	<td align=center><TT>3</tt></td><td align=center>³</td>
	<td align=center><TT>~A</tt></td><td align=center>Ã</td>
	<td align=center><TT>'O</tt></td><td align=center>Ó</td>
	<td align=center><TT>~a</tt></td><td align=center>ã</td>
	<td align=center><TT>'o</tt></td><td align=center>ó
</tr><tr>
	<td align=center><TT>ox</tt></td><td align=center>¤</td>
	<td align=center><TT>'</tt></td><td align=center>´</td>
	<td align=center><TT>:A</tt></td><td align=center>Ä</td>
	<td align=center><TT>^O</tt></td><td align=center>Ô</td>
	<td align=center><TT>:a</tt></td><td align=center>ä</td>
	<td align=center><TT>^o</tt></td><td align=center>ô
</tr><tr>
	<td align=center><TT>y=</tt></td><td align=center>¥</td>
	<td align=center><TT>u</tt></td><td align=center>µ</td>
	<td align=center><TT>*A</tt></td><td align=center>Å</td>
	<td align=center><TT>~O</tt></td><td align=center>Õ</td>
	<td align=center><TT>*a</tt></td><td align=center>å</td>
	<td align=center><TT>~o</tt></td><td align=center>õ
</tr><tr>
	<td align=center><TT>|</tt></td><td align=center>¦</td>
	<td align=center><TT>p</tt></td><td align=center>¶</td>
	<td align=center><TT>AE</tt></td><td align=center>Æ</td>
	<td align=center><TT>:O</tt></td><td align=center>Ö</td>
	<td align=center><TT>ae</tt></td><td align=center>æ</td>
	<td align=center><TT>:o</tt></td><td align=center>ö
</tr><tr>
	<td align=center><TT>&amp;</tt></td><td align=center>§</td>
	<td align=center><TT>.</tt></td><td align=center>·</td>
	<td align=center><TT>,C</tt></td><td align=center>Ç</td>
	<td align=center><TT>x</tt></td><td align=center>×</td>
	<td align=center><TT>,c</tt></td><td align=center>ç</td>
	<td align=center><TT>-:</tt></td><td align=center>÷
</tr><tr>
	<td align=center><TT>:</tt></td><td align=center>¨</td>
	<td align=center><TT>,</tt></td><td align=center>¸</td>
	<td align=center><TT>E`</tt></td><td align=center>È</td>
	<td align=center><TT>O/</tt></td><td align=center>Ø</td>
	<td align=center><TT>`e</tt></td><td align=center>è</td>
	<td align=center><TT>o/</tt></td><td align=center>ø
</tr><tr>
	<td align=center><TT>c</tt></td><td align=center>©</td>
	<td align=center><TT>1</tt></td><td align=center>¹</td>
	<td align=center><TT>'E</tt></td><td align=center>É</td>
	<td align=center><TT>`U</tt></td><td align=center>Ù</td>
	<td align=center><TT>'e</tt></td><td align=center>é</td>
	<td align=center><TT>`u</tt></td><td align=center>ù
</tr><tr>
	<td align=center><TT>a</tt></td><td align=center>ª</td>
	<td align=center><TT>o</tt></td><td align=center>º</td>
	<td align=center><TT>^E</tt></td><td align=center>Ê</td>
	<td align=center><TT>'U</tt></td><td align=center>Ú</td>
	<td align=center><TT>^e</tt></td><td align=center>ê</td>
	<td align=center><TT>'u</tt></td><td align=center>ú
</tr><tr>
	<td align=center><TT>&lt;&lt;</tt></td><td align=center>«</td>
	<td align=center><TT>>></tt></td><td align=center>»</td>
	<td align=center><TT>:E</tt></td><td align=center>Ë</td>
	<td align=center><TT>^U</tt></td><td align=center>Û</td>
	<td align=center><TT>:e</tt></td><td align=center>ë</td>
	<td align=center><TT>^u</tt></td><td align=center>û
</tr><tr>
	<td align=center><TT>~</tt></td><td align=center>¬</td>
	<td align=center><TT>14</tt></td><td align=center>1/4</td>
	<td align=center><TT>`I</tt></td><td align=center>Ì</td>
	<td align=center><TT>:U</tt></td><td align=center>Ü</td>
	<td align=center><TT>`i</tt></td><td align=center>ì</td>
	<td align=center><TT>:u</tt></td><td align=center>ü
</tr><tr>
	<td align=center><TT>-</tt></td><td align=center>­</td>
	<td align=center><TT>12</tt></td><td align=center>1/2</td>
	<td align=center><TT>'I</tt></td><td align=center>Í</td>
	<td align=center><TT>'Y</tt></td><td align=center>Ý</td>
	<td align=center><TT>'i</tt></td><td align=center>í</td>
	<td align=center><TT>'y</tt></td><td align=center>ý
</tr><tr>
	<td align=center><TT>r</tt></td><td align=center>®</td>
	<td align=center><TT>34</tt></td><td align=center>3/4</td>
	<td align=center><TT>^I</tt></td><td align=center>Î</td>
	<td align=center><TT>TH</tt></td><td align=center>Þ</td>
	<td align=center><TT>^i</tt></td><td align=center>î</td>
	<td align=center><TT>th</tt></td><td align=center>þ
</tr><tr>
	<td align=center><TT>_</tt></td><td align=center>¯</td>
	<td align=center><TT>?</tt></td><td align=center>¿</td>
	<td align=center><TT>:I</tt></td><td align=center>Ï</td>
	<td align=center><TT>ss</tt></td><td align=center>ß</td>
	<td align=center><TT>:i</tt></td><td align=center>ï</td>
	<td align=center><TT>:y</tt></td><td align=center>ÿ
</table></center>

<p>For instance, to type "á" type [compose][a]['] or [compose]['][a].

<P>The character "nbsp" (non-breaking space) is typed by using
[compose][space].

<P>The single-character sequences may be followed by a space if
necessary to remove ambiguity.  For instance, if you really want to
type "ª~" rather than "ã" you must type [compose][a][space][~].

<p>The same key may be used to "quote" control characters into the
text.  If you need a <tt>^Q</tt> character you can get one by typing
[compose][Control+Q].

<p>X may have a key on the keyboard
defined as <tt>XK_Multikey</tt>.  If so this key may be used as well
as the right-hand control key.  You can set this up with the program
<tt>xmodmap</tt>.

<p>If your keyboard is set to support a foreign language you should
also be able to type "dead key" prefix characters.  On X you will
actually be able to see what dead key you typed, and if you then move
the cursor without completing the sequence the accent will remain
inserted.
</TABLE></CENTER>
<H3>Methods</H3>

<H3>Methods</H3>
<CENTER>
<TABLE width=90%>
<TR><TD align=left valign=top>

<UL>
<LI><A href=#Input>fltk::Input</A></LI>
<LI><A href=#~Input>~Input</A></LI>
<LI><A href=#index>index</A></LI>
<LI><A href=#static_value>static_value</A></LI>
<LI><A href=#textcolor>textcolor</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#textfont>textfont</A></LI>
<LI><A href=#textsize>textsize</A></LI>
<LI><A href=#copy>copy</A></LI>
<LI><A href=#cut>cut</A></LI>
<LI><A href=#drawtext>drawtext</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#handletext>handletext</A></LI>
<LI><A href=#insert>insert</A></LI>
<LI><A href=#line_start>line_start</A></LI>
<LI><A href=#line_end>line_end</A></LI>
<LI><A href=#mark>mark</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#maybe_do_callback>maybe_do_callback</A></LI>
<LI><A href=#position>position</A></LI>
<LI><A href=#replace>replace</A></LI>
<LI><A href=#size>size</A></LI>
<LI><A href=#undo>undo</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#up_down_position>up_down_position</A></LI>
<LI><A href=#value>value</A></LI>
<LI><A href=#when>when</A></LI>
<LI><A href=#word_start>word_start</A></LI>
<LI><A href=#word_end>word_end</A></LI>
</UL>
</TD></TR>
</TABLE>
</CENTER>
<H4><A name=Input>fltk::Input::Input(int x, int y, int 
w, int h, const char *label = 0)</A></H4>
 Creates a new <TT>fltk::Input</TT> widget using the given position, 
size, and label string. The default boxtype is <TT>fltk::DOWN_BOX</TT>. 

<H4><A name=~Input>virtual fltk::Input::~Input()</A></H4>
 The destructor removes the widget and any value associated with it. 

<H4><A name=word_start>int fltk::Input::word_start(int position) 
const</A></H4>

Returns the location of the first word boundary at or before position.

<H4><A name=word_end>int fltk::Input::word_end(int position) 
const</A></H4>

Returns the location of the next word boundary at or after position.

<H4><A name=line_start>int fltk::Input::line_start(int position) 
const</A></H4>

Returns the location of the start of the line containing the position.

<H4><A name=line_end>int fltk::Input::line_end(int position) 
const</A></H4>

Returns the location of the next newline or wordwrap space at or after
position.

<H4><A name=drawtext>void fltk::Input::drawtext(int,int,int,int)</A>
</H4>
 Draw the text in the passed bounding box.  If <TT>damage() 
fltk::DAMAGE_ALL</TT> is true, this assummes the area has already been 
erased to <TT>color()</TT>.  Otherwise it does minimal update and 
erases the area itself. 
<H4><A name=handletext>void fltk::Input::handletext(int 
e,int,int,int,int)</A></H4>
 Default handler for all event types.  Your <TT>handle()</TT> method 
should call this for all events that it does not handle completely. 
 You must pass it the same bounding box as passed to <TT>draw()</TT>. 
 Handles <TT>fltk::PUSH</TT>, <TT>fltk::DRAG</TT>, <TT>fltk::RELEASE</TT> to 
select text, handles <TT>fltk::FOCUS</TT> and <TT>fltk::UNFOCUS</TT> to show 
and hide the cursor. 

<H4><A name=up_down_position>int 
fltk::Input::up_down_position(int i, int keepmark=0)</A></H4>

Do the correct thing for arrow keys. <tt>i</tt> must be the location
of the start of a line. Sets the position (and mark if <I>
keepmark</I> is zero) to somewhere after <I>i</I>, such
that pressing the arrows repeatedly will cause the point to move up
and down.

<H4><A name=maybe_do_callback>void 
fltk::Input::maybe_do_callback()</A></H4>
 Does the callback if <TT>changed()</TT> is true or if <TT>when() 
fltk::WHEN_NOT_CHANGED</TT> is non-zero.  You should call this at any 
point you think you should generate a callback. 
<H4><A name=position>int fltk::Input::position() const
<BR> int fltk::Input::position(int new_position, int new_mark)
<BR> int fltk::Input::position(int new_position_and_new_mark)</A></H4>
 The input widget maintains two pointers into the string.  The 
&quot;position&quot; is where the cursor is.  The &quot;mark&quot; is the other end of the 
selected text.  If they are equal then there is no selection.  Changing 
this does not affect the clipboard (use <TT>copy()</TT> to do that). 
<P>Changing these values causes a <TT>redraw()</TT>.  The new values 
are bounds checked.  The return value is non-zero if the new position 
is different than the old one. <TT>position(n)</TT> is the same as <TT>
position(n,n)</TT>. <TT>mark(n)</TT> is the same as <TT>
position(position(),n)</TT>. </P>
<H4><A name=mark>int fltk::Input::mark() const
<BR> int fltk::Input::mark(int new_mark)</A></H4>
 Gets or sets the current selection mark. <TT>mark(n)</TT> is the same 
as <TT>position(position(),n)</TT>. 

<h4><a name=replace>virtual int fltk::Input::replace(int a, int b, 
const char* insert, int length)</a></h4>

This call does all editing of the text.  It deletes the region between
<TT>a</TT> and <TT>b</TT> (either one may be less or equal to the
other), and then inserts <tt>length</tt> (which may be zero)
characters from the string <TT>insert</TT> at that point and leaves
the <TT>mark()</TT> and <TT>position()</TT> after the insertion.  Does
the callback if <TT>when()&amp;fltk::WHEN_CHANGED</TT> and there is a
change.

<p>Subclasses of fltk::Input can override this function to control what
characters can be inserted into the text. A typical implementation
will check the characters in the insertion for legality and then call
<tt>fltk::Input::replace</tt> only if they are all ok.

<p>Subclasses should return true if the keystroke that produced this
call should be "eaten". If false is returned the keystroke is allowed
to be tested as a shortcut for other widgets. In our experience it is
best to return true even if you don't make changes. The base class
version returns true always.

<H4><A name=cut>int fltk::Input::cut()
<BR> int fltk::Input::cut(int n)
<BR> int fltk::Input::cut(int a, int b);</A></H4>

These are wrappers around <a href=#replace>replace()</a>.
<TT>fltk::Input::cut()</TT> deletes the area between <tt>mark()</tt> and
<tt>position()</tt>. <TT>cut(n)</TT> deletes <TT>n</TT> characters
after the <TT>position()</TT>. <TT> cut(-n)</TT> deletes <TT>n</TT>
characters before the <TT>position()</TT> . <TT>cut(a,b)</TT> deletes
the characters between offsets <TT>a</TT> and <TT>b</TT>. <TT>A</TT>,
<TT>b</TT>, and <TT>n</TT> are all clamped to the size of the string.
The mark and point are left where the deleted text was.

<P>If you want the data to go into the clipboard, do <TT>
fltk::Input::copy()</TT> before calling <TT>fltk::Input::cut()</TT>.

<H4><A name=insert>int fltk::Input::insert(const char *t,int 
l=0)</A></H4>

Insert the string <TT>t</TT> at the current position, and leave the 
mark and position after it.  If <TT>l</TT> is not zero then it is 
assummed to be <TT>strlen(t)</TT>. 
<H4><A name=copy>int fltk::Input::copy(bool clipboard=true)</A></H4>

Put the current selection between <TT>mark()</TT> and <TT>position()</TT>
into the clipboard.  Does not replace the old clipboard contents if <TT>
position()</TT> and <TT>mark()</TT> are equal. This calls <a
href=Fl.html#copy><tt>fltk::copy()</tt></a>.

<p>If <i>clipboard</i> is true the text is put into the user-visible
cut & paste clipboard (this is probably what you want). If false it is
put into the less-visible selection buffer that is used to do
middle-mouse paste and drag & drop.

<p>To paste the clipboard, call <a
href=Fl.html#paste><tt>fltk::paste(true)</tt></a> and fltk will send the
widget a <tt>fltk::PASTE</tt> event with the text, which will cause it to
be inserted.

<H4><A name=undo>int fltk::Input::undo()</A></H4>
 Does undo of several previous calls to <TT>replace()</TT>.  Returns 
non-zero if any change was made. 

<H4><A name=value>const char *fltk::Input::value() const
<BR> int fltk::Input::value(const char*)
<BR> int fltk::Input::value(const char*, int)</A></H4>
 The first form returns the current value, which is a pointer to the 
internal buffer and is valid only until the next event is handled. 
<P>The second two forms change the text and set the mark and the point 
to the end of it. The string is copied to the internal buffer.  Passing <TT>
NULL</TT> is the same as &quot;&quot;.  This returns non-zero if the new value is 
different than the current one.  You can use the second version to 
directly set the length if you know it already or want to put nul's in 
the text. </P>
<H4><A name=static_value>int fltk::Input::static_value(const 
char*)
<BR> int fltk::Input::static_value(const char*, int)</A></H4>
 Change the text and set the mark and the point to the end of it.  The 
string is <I>not</I> copied.  If the user edits the string it is copied 
to the internal buffer then.  This can save a great deal of time and 
memory if your program is rapidly changing the values of text fields, 
but this will only work if the passed string remains unchanged until 
either the <TT>fltk::Input</TT> is destroyed or <TT>value()</TT> is called 
again. 
<H4><A name=size>int fltk::Input::size() const</A></H4>
 Returns the number of characters in <TT>value()</TT>.  This may be 
greater than <TT>strlen(value())</TT> if there are nul characters in 
it. 
<H4><A name=index>char fltk::Input::index(int) const</A></H4>
 Same as <TT>value()[n]</TT>, but may be faster in plausible 
implementations. No bounds checking is done. 
<H4><A name=when>fltk::When fltk::Widget::when() const
<BR> void fltk::Widget::when(fltk::When)</A></H4>
 Controls when callbacks are done.  The following values are useful, 
the default value is <TT>fltk::WHEN_RELEASE</TT>: 
<UL>
<LI><TT>0</TT>: The callback is not done, but <TT>changed()</TT> is 
 turned on. </LI>
<LI><TT>fltk::WHEN_CHANGED</TT>: The callback is done each time the  text 
is changed by the user. </LI>
<LI><TT>fltk::WHEN_RELEASE</TT>: The callback will  be done when this 
widget loses the focus, including when the window is  unmapped.  This 
is a useful value for text fields in a panel where  doing the callback 
on every change is wasteful.  However the callback  will also happen if 
the mouse is moved out of the window, which means  it should not do 
anything visible (like pop up an error message).  You  might do better 
setting this to zero, and scanning all the items for <TT>changed()</TT>
 when the OK button on a panel is pressed. </LI>
<LI><TT>fltk::WHEN_ENTER_KEY</TT>: If the user types the Enter  key, the 
entire text is selected, and the callback is done if  the text has 
changed.  Normally the Enter key will navigate to  the next field (or 
insert a newline for a <TT>fltk::Mulitline_Input</TT>), this changes the 
behavior. </LI>
<LI><TT>fltk::WHEN_ENTER_KEY|fltk::WHEN_NOT_CHANGED</TT>: The Enter key  will 
do the callback even if the text has not changed.  Useful for  command 
fields. </LI>
</UL>
<H4><A name=textcolor>fltk::Color fltk::Input::textcolor() const
<BR> void fltk::Input::textcolor(fltk::Color)</A></H4>
 Gets or sets the color of the text in the input field. 
<H4><A name=textfont>fltk::Font fltk::Input::textfont() const
<BR> void fltk::Input::textfont(fltk::Font)</A></H4>
 Gets or sets the font of the text in the input field. 
<H4><A name=textsize>uchar fltk::Input::textsize() const
<BR> void fltk::Input::textsize(uchar)</A></H4>
 Gets or sets the size of the text in the input field. 
<H4><A name=cursor_color>fltk::Color fltk::Input::cursor_color() 
const
<BR> void fltk::Input::cursor_color(fltk::Color)</A></H4>
 Get or set the color of the cursor.  This is black by default.

</BODY></HTML>
