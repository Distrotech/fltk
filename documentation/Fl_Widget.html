<html><body>
<hr break>
<h2><A name=Fl_Widget>class Fl_Widget</A></h2>
<hr>
<h3>Class Hierarchy</h3>

<ul><pre><B>Fl_Widget</B>
   |
   +----<A href=Fl_Box.html#Fl_Box>Fl_Box</A>, <A href=Fl_Browser_.html#Fl_Browser_>Fl_Browser_</A>, <A href=Fl_Button.html#Fl_Button>Fl_Button</A>, <A href=Fl_Chart.html#Fl_Chart>Fl_Chart</A>, <A href=Fl_Clock.html#Fl_Clock>Fl_Clock</A>,
        <A href=Fl_Free.html#Fl_Free>Fl_Free</A>, <A href=Fl_Group.html#Fl_Group>Fl_Group</A>, <A href=Fl_Input.html#Fl_Input>Fl_Input</A>, <A href=Fl_Menu_.html#Fl_Menu_>Fl_Menu_</A>, <A href=Fl_Positioner.html#Fl_Positioner>Fl_Positioner</A>,
        <A href=Fl_Timer.html#Fl_Timer>Fl_Timer</A>, <A href=Fl_Valuator.html#Fl_Valuator>Fl_Valuator</A>
</pre></ul>

<h3>Include Files</h3>

<ul><pre>#include &lt;FL/Fl_Widget.H&gt;</pre></ul>

<h3>Description</h3>

<tt>Fl_Widget</tt> is the base class for all widgets in FLTK. You can't 
create one of these because the constructor is not public.  However you 
can <A href="subclassing.html">subclass</A> it. 

<P>All &quot;property&quot; accessing methods, such as <tt>color()</tt>, <tt>
parent()</tt>, or <tt>argument()</tt> are implemented as trivial inline 
functions and thus are as fast and small as accessing fields in a 
structure. Unless otherwise noted, the property setting methods such as <tt>
color(n)</tt> or <tt>label(s)</tt> are also trivial inline functions, 
even if they change the widget's appearance.  It is up to the user code 
to call <tt>redraw()</tt> after these. </P>

<h3>Methods</h3>

<center><table width=90%>
<TR><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Widget>Fl_Widget</A></LI>
<LI><A href=#~Fl_Widget>~Fl_Widget</A></LI>
<LI><A href=#activate>activate</A></LI>
<LI><A href=#active>active</A></LI>
<LI><A href=#active_r>active_r</A></LI>
<LI><A href=#align>align</A></LI>
<LI><A href=#argument>argument</A></LI>
<LI><A href=#box>box</A></LI>
<LI><A href=#box_color>box_color</a>
<LI><A href=#callback>callback</A></LI>
<LI><A href=#changed>changed</A></LI>
<LI><A href=#clear_changed>clear_changed</A></LI>
<LI><a href=#clear_visible>clear_visible</A>
<LI><A href=#color>color</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#contains>contains</A></LI>
<LI><A href=#copy_label>copy_label</A></LI>
<LI><A href=#damage>damage</A></LI>
<LI><A href=#deactivate>deactivate</A></LI>
<LI><A href=#default_callback>default_callback</A></LI>
<LI><A href=#do_callback>do_callback</A></LI>
<LI><a href=#draw_box>draw_box</A>
<LI><a href=#draw_button>draw_button</A>
<li><a href=#draw_text_frame>draw_text_frame</A>
<li><a href=#draw_text_box>draw_text_box</A>
<li><a href=#draw_glyph>draw_glyph</a>
<LI><A href=#draw_label>draw_label</A>
<LI><A href=#draw_inside_label>draw_inside_label</A>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#flags>flags</A></LI>
<LI><A href=#glyph_color>glyph_color</a>
<LI><A href=#height>height</A></LI>
<LI><A href=#h>h</A></LI>
<LI><A href=#hide>hide</A></LI>
<LI><A href=#inside>inside</A></LI>
<LI><A href=#label>label</A></LI>
<LI><A href=#labelcolor>labelcolor</A></LI>
<LI><A href=#labelfont>labelfont</A></LI>
<LI><A href=#labelsize>labelsize</A></LI>
<LI><A href=#labeltype>labeltype</A></LI>
<LI><A href=#layout>layout</A></LI>
<LI><A href=#measure_label>measure_label</A>
<LI><A href=#output>output</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#parent>parent</A></LI>
<LI><A href=#position>position</A></LI>
<LI><A href=#redraw>redraw</A></LI>
<LI><A href=#resize>resize</A></LI>
<LI><A href=#selection_color>selection_color</A></LI>
<LI><A href=#set_changed>set_changed</A></LI>
<LI><A href=#set_flag>set_flag</A></LI>
<LI><A href=#set_visible>set_visible</A></LI>
<LI><A href=#show>show</A></LI>
<LI><A href=#size>size</A></LI>
<LI><A href=#take_focus>take_focus</A></LI>
<LI><A href=#takesevents>takesevents</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#test_shortcut>test_shortcut</A></LI>
<LI><A href=#type>type</A></LI>
<LI><A href=#user_data>user_data</A></LI>
<LI><A href=#visible>visible</A></LI>
<LI><A href=#visible_r>visible_r</A></LI>
<LI><A href=#w>w</A></LI>
<LI><A href=#width>width</A></LI>
<LI><A href=#when>when</A></LI>
<LI><A href=#window>window</A></LI>
<LI><A href=#x>x</A></LI>
<LI><A href=#y>y</A></LI>
</UL>
</TD></TR>

</table></center>

<h4>Fl_Widget::Fl_Widget(int x, int y, int w, int h, const char* 
label=0);</h4>

This is the protected constructor for an Fl_Widget, but all derived 
widgets have a matching public constructor.  It takes a value for x(), 
y(), w(), h(), and an optional value for label(). 

<h4>virtual Fl_Widget::~Fl_Widget();</h4>

Destroying single widgets is not very common.  It is your 
responsibility to either remove() them from any enclosing group, or to 
destroy that group <I>immediately</I> after destroying the children. 

<h4>uchar Fl_Widget::type() const;</h4>

This value is used for Forms compatability and to simulate RTTI. 

<h4><A name=x>int Fl_Widget::x() const</A>
<BR><A name=y>int Fl_Widget::y() const</A>
<BR><A name=w>int Fl_Widget::w() const</A>
<BR><A name=h>int Fl_Widget::h() const</A></h4>

The position of the upper-left corner of the widget in its enclosing 
Fl_Window (<I>not</I> its parent if that is not an Fl_Window), and its 
width and height. 

<h4><A name=height>int Fl_Widget::height()</a>
<br><A name=width>int Fl_Widget::width()</a></h4>

Returns h() (or w()), but if the current value is zero it calls
layout() before returning the value.  Using these calls allows a
widget to delay the calculation of size until it is needed.

<h4><A name=resize>void Fl_Widget::resize(int x, int y, int w, int h)</A>
<BR><A name=position>void Fl_Widget::position(short x, short y)</A>
<BR><A name=size>void Fl_Widget::size(short w, short h)</A></h4>

Change the size or position of the widget.  Nothing is done if the
passed size and position are the same as before.  If the size changes,
this sets a flag so that the virtual function layout() is called
before the next draw().  <P><tt>position(x,y)</tt> is a shortcut for
<tt>resize(x,y,w(),h())</tt>, and <tt>size(w,h)</tt> is a shortcut for
<tt>resize(x(),y(),w,h)</tt>. </P>

<h4><A name=layout>virtual void Fl_Widget::layout()</A></h4>

This is a virtual function 
so the widget may implement its own handling of resizing.  The default 
version does <I>not</I> do redraw(), that is the parent widget's 
responsibility (this is because the parent may know a faster way to 
update the display, such as scrolling from the old position). 

<h4><A name=window>Fl_Window* Fl_Widget::window() const;</A></h4>
 Return a pointer to the <A href=Fl_Window.html#Fl_Window><tt>Fl_Window</tt>
</A> that this widget is in (it will skip any and all parent widgets 
between this and the window).  Returns <tt>NULL</tt> if none.  Note: 
for an <tt>Fl_Window</tt>, this returns its <I>parent</I> window (if 
any), not <I>this</I> window. 

<h4><a name=style>const <a href=Fl_Style.html>Fl_Style</a>* Fl_Widget::style() const</h4>

Return the <a href=Fl_Style.html>Fl_Style</a> structure used by this
widget.  Normally this structure is shared with many other widgets.

<h4><a name=wstyle><a href=Fl_Style.html>Fl_Style</a>* Fl_Widget::wstyle();</h4>

Returns a "writable" style.  If the current value of <a
href=#style>style()</a> is shared then a unique copy is made and
returned.  This may be modified without changing other widgets.

<h4>bool Fl_Widget::style(<a href=Fl_Style.html>Fl_Style</a>* s);
<br>bool Fl_Widget::style(<a href=Fl_Style.html>Fl_Style</a>& s);</h4>

Set the style to this <i>shared</i> style.  If this style has never
been used before fltk adds it as a child of the current style and
returns true (this allows the calling code to initialize it).

<h4><a name=copy_style>bool copy_style(const <a href=Fl_Style.html>Fl_Style</a>* s);</h4>

Copy the style from another widget.  If it is not shared then a copy
is made, otherwise the pointer is just copied.  This is done so that
either widget may be destroyed without deleting the style used by the
other one.

<h4>Fl_Boxtype Fl_Widget::box();<br>
Fl_Boxtype Fl_Widget::text_box();<br>
Fl_Glyph Fl_Widget::glyph();<br>
Fl_Font Fl_Widget::label_font();<br>
Fl_Font Fl_Widget::text_font();<br>
Fl_Labeltype Fl_Widget::label_type();<br>
Fl_Color Fl_Widget::color();<br>
Fl_Color Fl_Widget::label_color();<br>
Fl_Color Fl_Widget::highlight_color();<br>
Fl_Color Fl_Widget::highlight_label_color();<br>
Fl_Color Fl_Widget::text_background();<br>
Fl_Color Fl_Widget::text_color();<br>
Fl_Color Fl_Widget::selection_color();<br>
Fl_Color Fl_Widget::selection_text_color();<br>
unsigned Fl_Widget::label_size();<br>
unsigned Fl_Widget::text_size();<br>
unsigned Fl_Widget::leading();</h4>

Return the given field out of the <a href=#style>style()</a>.

<h4>void Fl_Widget::box(Fl_Boxtype);<br>
void Fl_Widget::text_box(Fl_Boxtype);<br>
void Fl_Widget::glyph(Fl_Glyph);<br>
void Fl_Widget::label_font(Fl_Font);<br>
void Fl_Widget::text_font(Fl_Font);<br>
void Fl_Widget::label_type(Fl_Labeltype);<br>
void Fl_Widget::color(Fl_Color);<br>
void Fl_Widget::label_color(Fl_Color);<br>
void Fl_Widget::highlight_color(Fl_Color);<br>
void Fl_Widget::highlight_label_color(Fl_Color);<br>
void Fl_Widget::text_background(Fl_Color);<br>
void Fl_Widget::text_color(Fl_Color);<br>
void Fl_Widget::selection_color(Fl_Color);<br>
void Fl_Widget::selection_text_color(Fl_Color);<br>
void Fl_Widget::label_size(unsigned);<br>
void Fl_Widget::text_size(unsigned);<br>
void Fl_Widget::leading(unsigned);</h4>

These all create a writable <a href=Fl_Style.html>Fl_Style</a> with <a
href=#wstyle>wstyle()</a> and set the given field in it.

<h4><A name=label>const char* Fl_Widget::label() const
<BR>void Fl_Widget::label(const char*)</a></h4>

The label is printed somewhere on the widget or next to it.  The
string passed to label() is <I>not</I> copied, it simply replaces the
value currently in the widget.

<h4><a name=copy_label>void Fl_Widget::copy_label(const char*)</A></h4>

The passed string is copied to private storage and used to set the
label.  The memory will be freed when the widget is destroyed or when
<tt>copy_label</tt> is called again.  You can pass <tt>NULL</tt> and
it will set <tt>label()</tt> to <tt>NULL</tt>.

<p><i>Don't call label(string) after this, as it replaces the pointer
without checking.</i>

<h4><A name=image>Fl_Image* Fl_Widget::image() const
<BR> void Fl_Widget::image(Fl_Image*)</A></h4>

<a href=Fl_Image.html>Fl_Image</a> to draw as part of the label.

<h4><A name=flags>Fl_Flags Fl_Widget::flags() const;
void Fl_Widget::set_flag(Fl_Flags);
void Fl_Widget::clear_flag(Fl_Flags);</A></h4>

Each widget, and many of the drawing functions, take a bitmask of
flags that indicate the current state and exactly how to draw
things. The following flags are defined:

<ul>
<li><tt>FL_INACTIVE</tt> - does not get events, gray it out
<li><tt>FL_INVISIBLE</tt> - does not get events, does not draw
<li><tt>FL_OUTPUT</tt> - does not get events
<li><tt>FL_VALUE</tt> - <tt>value()</tt>, indicates true/down/on state
<li><tt>FL_CHANGED</tt> - <tt>changed()</tt>, value changed since last callback
<li><tt>FL_COPIED_LABEL</tt> - destructor will delete label()
<li><tt>FL_FOCUSED</tt> - draw with keyboard focus
<li><tt>FL_HIGHLIGHT</tt> - draw highlighted
<li><tt>FL_FRAME_ONLY</tt> - don't draw interior of boxes
<li><tt>FL_SELECTED</tt> - draw using selection colors
<li><tt>FL_NO_SHORTCUT_LABEL</tt> - don't draw &amp;x in label as underscore
<li><tt>FL_MENU_STAYS_UP</tt> - dont exit menu when picked
<li><tt>FL_OPEN</tt> - this group in a Fl_Browser is open
<li><tt>FL_ALIGN_*</tt> - label alignment, see below.
</ul>

<h4><a name=align>void Fl_Widget::align(Fl_Flags);</a></h4>

Forces the values of all the <tt>FL_ALIGN_*</tt> flags to the passed
value.  This determines how the label is printed next to or inside the
widget.  The default value is <tt>FL_ALIGN_CENTER</tt>, which centers
the label.  The value can be any of these constants or'd together:

<UL>
<LI><tt>FL_ALIGN_CENTER</tt></LI>
<LI><tt>FL_ALIGN_TOP</tt></LI>
<LI><tt>FL_ALIGN_BOTTOM</tt></LI>
<LI><tt>FL_ALIGN_LEFT</tt></LI>
<LI><tt>FL_ALIGN_RIGHT</tt></LI>
<LI><tt>FL_ALIGN_INSIDE</tt></LI>
<LI><tt>FL_ALIGN_CLIP</tt></LI>
<LI><tt>FL_ALIGN_WRAP</tt></LI>
</UL>

<h4>Fl_Callback* Fl_Widget::callback() const
<BR> void Fl_Widget::callback(Fl_Callback*, void* = 0)</A></h4>

Each widget has a single callback.  You can set it or examine it with 
these methods. 

<h4><A name=user_data>void* Fl_Widget::user_data() const
<BR> void Fl_Widget::user_data(void*)</A></h4>

You can also just change the <tt>void *</tt> second argument to the 
callback with the <tt>user_data</tt> methods. 

<h4><A name=argument>void Fl_Widget::callback(void 
(*)(Fl_Widget*, long), long = 0)
<BR> long Fl_Widget::argument() const
<BR> void Fl_Widget::argument(long)</A></h4>

For convenience you can also define the callback as taking a long 
argument.  This is implemented by casting this to a <tt>Fl_Callback</tt>
and casting the <tt>long</tt> to a <tt>void *</tt> and may not be 
portable to some machines. 

<h4>void Fl_Widget::callback(void (*)(Fl_Widget*))</h4>

For convenience you can also define the callback as taking only one 
argument.  This is implemented by casting this to a <tt>Fl_Callback</tt>
and may not be portable to some machines. 

<h4><A name=do_callback>void Fl_Widget::do_callback()
<BR> void Fl_Widget::do_callback(Fl_Widget*, void* = 0)
<BR> void Fl_Widget::do_callback(Fl_Widget*, long)</A></h4>

You can cause a widget to do its callback at any time, and even pass 
arbitrary arguments. 

<h4><A name=changed>int Fl_Widget::changed() const</A>
<BR><A name=set_changed>void Fl_Widget::set_changed()</A>
<BR><A name=clear_changed>void Fl_Widget::clear_changed()</A></h4>

<tt>Fl_Widget::changed()</tt> is a flag that is turned on when the user 
changes the value stored in the widget.  This is only used by 
subclasses of <tt>Fl_Widget</tt> that store values, but is in the base 
class so it is easier to scan all the widgets in a panel and <tt>
do_callback()</tt> on the changed ones in response to an &quot;OK&quot; button. 
<P>Most widgets turn this flag off when they do the callback, and when 
the program sets the stored value. </P>

<h4><A name=when>Fl_When Fl_Widget::when() const
<BR> void Fl_Widget::when(Fl_When)</A></h4>

<tt>Fl_Widget::when()</tt> is a set of bitflags used by subclasses of <tt>
Fl_Widget</tt> to decide when to do the callback.  If the value is zero 
then the callback is never done.  Other values are described in the 
individual widgets.  This field is in the base class so that you can 
scan a panel and <tt>do_callback()</tt> on all the ones that don't do 
their own callbacks in response to an &quot;OK&quot; button. 

<h4><A name=default_callback>static void 
Fl_Widget::default_callback(Fl_Widget*, void*)</A></h4>

The default callback, which puts a pointer to the widget on the queue
returned by <A href=functions.html#readqueue><tt>Fl::readqueue()</tt></A>.
You may want to call this from your own callback.

<h4><A name=visible>int Fl_Widget::visible() const</A><BR>
<A name=visible_r>int Fl_Widget::visible_r() const</A><BR>
<A name=show>void Fl_Widget::show()</A><BR>
<A name=hide>void Fl_Widget::hide()</A></h4>

An invisible widget never gets redrawn and does not get events.  The
<tt>visible()</tt> method returns true if the widget is set to be
visible.The <tt>visible_r()</tt> method returns true if the widget and
all of its parents are visible. A widget is only visible if
<tt>visible()</tt> is true on it <I>and all of its parents</I>.  
<P>Changing it will send <tt>FL_SHOW</tt> or <tt>FL_HIDE</tt>
events to the widget. <I>Do not change it if the parent is not 
visible, as this will send false <tt>FL_SHOW</tt> or <tt>FL_HIDE</tt>
 events to the widget</I>. <tt>redraw()</tt> is called if necessary on 
this or the parent. 

<h4><A name=active>int Fl_Widget::active() const</A><BR>
<A name=active_r>int Fl_Widget::active_r() const</A></BR>
<A name=activate>void Fl_Widget::activate()</A></BR>
<A name=deactivate>void Fl_Widget::deactivate()</A></h4>

<tt>Fl_Widget::active()</tt> returns whether the widget is active.
<tt>Fl_Widget::active_r()</tt> returns whether the widget and all of
its parents are active.  An inactive widget does not get any events,
but it does get redrawn.  A widget is only active if <tt>active()</tt> is
true on it <I>and all of its parents</I>.
<P>Changing this value will send <tt>FL_ACTIVATE</tt> or <tt>
FL_DEACTIVATE</tt> to the widget if <tt>active_r()</tt> is true.
<P>Currently you cannot deactivate <tt>Fl_Window</tt> widgets. </P>

<h4><A name=output>int Fl_Widget::output() const</A><BR>
<A name=set_output>void Fl_Widget::set_output()</A></BR>
<A name=clear_output>void Fl_Widget::clear_output()</A></h4>

<tt>output()</tt> means the same as <tt>!active()</tt> except it does
not change how the widget is drawn.  The widget will not recieve any
events.  This is useful for making scrollbars or buttons that work as
displays rather than input devices.

<h4><A name=takesevents>int Fl_Widget::takesevents() const</A></h4>

This is the same as <tt>(active() &amp;&amp; visible() &amp;&amp;
!output())</tt> but is faster.

<h4><a name=damage>void Fl_Widget::damage(uchar flags)</a></h4>

Mark the widget as needing its <tt>draw()</tt> method called.  The
passed bits are or'd into the value of damage().  All parents then have
<tt>damage(FL_DAMAGE_CHILD)</tt> called on them, and a global flag is
set indicating that fltk should search for damaged widgets.

<h4><A name=redraw>void Fl_Widget::redraw()</A></h4>

Same as <tt>damage(FL_DAMAGE_ALL)</tt>.  This is the normal call to
make to indicate damage.

<h4><A name=damage_label>uchar Fl_Widget::damage_label()</A></h4>

Indicate that the <i>outside</i> label needs to be redrawn.  This
causes the parent widget to be redrawn in order to erase the old label
and then produce the new one.

<h4><A name=parent>Fl_Widget *Fl_Widget::parent() const</A></h4>

Returns a pointer to the parent widget.  Usually this is a <A
href=Fl_Group.html#Fl_Group> <tt>Fl_Group</tt></A> or <A
HREF="Fl_Window.html#Fl_Window"><tt>Fl_Window</tt></a>.  Returns
<tt>NULL</tt> if none.

<h4><a name=contains>int Fl_Widget::contains(Fl_Widget* b) const</A></h4>

Returns true if <tt>b</tt> is a child of this widget, or is equal to
this widget.  Returns false  if <tt>b</tt> is <tt>NULL</tt>. 

<h4><A name=inside>int Fl_Widget::inside(const Fl_Widget* a) 
const</A></h4>

Returns true if this is a child of <i>a</i>, or is equal to
<i>a</i>. Returns false if <i>a</i> is <tt>NULL</tt>.

<h4><A name=take_focus>int Fl_Widget::take_focus()</A></h4>

Tries to make this widget be the <tt>Fl::focus()</tt> widget, by first 
sending it an <tt>FL_FOCUS</tt> event, and if it returns non-zero, 
setting <tt>Fl::focus()</tt> to this widget.  You should use this 
method to assign the focus to an widget.  Returns true if the widget 
accepted the focus.

<h2>Methods for subclasses to use</h2>

You should not call the methods in this section except from a subclass
of Fl_Widget.  <p>See <A href="subclassing.html">Adding and
Extending Widgets</A>.

<h4><A name=damage>uchar Fl_Widget::damage() const</A></h4>

The 'or' of all the calls to <tt>damage(n)</tt> done since the last
<TT>draw()</TT>.  Cleared to zero after <tt>draw()</tt> is
called.

<P><I>When redrawing your widgets you should look at the damage bits to
see what parts of your widget need redrawing.</I> The <tt>handle()</tt>
method can then set individual damage bits to limit the amount of drawing
that needs to be done:

<UL><PRE>
MyClass::handle(int event) {
  ...
  if (change_to_part1) damage(1);
  if (change_to_part2) damage(2);
  if (change_to_part3) damage(4);
}

MyClass::draw() {
  if (damage() & FL_DAMAGE_ALL) {
    ... draw frame/box and other static stuff ...
  }

  if (damage() & (FL_DAMAGE_ALL | 1)) draw_part1();
  if (damage() & (FL_DAMAGE_ALL | 2)) draw_part2();
  if (damage() & (FL_DAMAGE_ALL | 4)) draw_part3();
}
</PRE></UL>

<h4><A name=damage>void Fl_Widget::damage(uchar mask)
<br>void Fl_Widget::damage(uchar mask, int x, int y, int w, int h)</A></h4>

The first form indicates that a partial update of the object is 
needed.  The bits in mask are OR'd into <TT>damage()</TT>.  Your <TT>
draw()</TT> routine can examine these bits to limit what it is
drawing.  The public method <TT>Fl_Widget::redraw()</TT> simply does
<TT> Fl_Widget::damage(FL_DAMAGE_ALL)</TT>, but the  implementation of
your widget can call the private <TT>damage(n)</TT>. 

<P>The second form indicates that a region is damaged.  If only these 
calls are done in a window (no calls to <TT>damage(n)</TT>) then FLTK 
will clip to the union of all these calls before drawing anything. 
This can greatly speed up incremental displays.  The mask bits are 
OR'd into <TT>damage()</TT>.

<h4><a name=draw_box>void Fl_Widget::draw_box(int x, int y, int w, int
h, Fl_Flags f) const;</h4>

Calls <a href=Fl_Boxtype.html>box()->draw()</a> with the given
arguments, to draw the box in the given rectangle. The flags may be
used to cause box effects such as making it inactive or selected.

<h4><a name=draw_box>Fl_Flags Fl_Widget::draw_box() const;</h4>

Calls <tt>draw_box(x(),y(),y(),h(),f)</tt> where <i>f</i> is the
current <tt>flags()</tt> plus:

<ul>
<li><tt>FL_INACTIVE</tt> if <tt>!active_r()</tt>
</ul>

Returns the resulting flags so you can pass them to another function.

<h4><a name=draw_button>Fl_Flags Fl_Widget::draw_button() const;</h4>

Standard routine for drawing <a
href=Fl_Button.html><tt>Fl_Button</tt></a> and similar widgets.  Calls
<tt>draw_box()</tt> but with the following bits 'or'd into the flags:

<ul>

<li><tt>FL_SELECTED</tt> if <tt>FL_VALUE</tt> is on and
<tt>selected_color</tt> is set <i>in this widget's style</i> (not
inherited).

<li><tt>FL_INACTIVE</tt> if <tt>!active_r()</tt>

<li><tt>FL_HIGHLIGHT</tt> if <tt>belowmouse()</tt>

<li><tt>FL_FOCUSED</tt> if <tt>focused()</tt>

</ul>

Returns the resulting flags so you can pass them to another function.

<h4><a name=draw_button>Fl_Flags Fl_Widget::draw_button(Fl_Flags f)
const;</h4>

Same as <tt>draw_button()</tt> but starts with <i>f</i> instead of
<tt>flags()</tt>. This can be used to force <tt>FL_VALUE</tt> on or
off.

<h4><a name=draw_text_frame>Fl_Flags Fl_Widget::draw_text_frame() const;
<br>Fl_Flags Fl_Widget::draw_text_frame(int x, int
y, int w, int h) const ;</a></h4>

Draws <tt>text_box()</tt> with the <tt>FL_FRAME_ONLY</tt> flag turned
on (so only the edge is drawn). Also turns on <tt>FL_INACTIVE</tt> if
<tt>!active_r()</tt>.

<h4><a name=draw_text_box>Fl_Flags Fl_Widget::draw_text_box() const;
<br>Fl_Flags Fl_Widget::draw_text_box(int x, int
y, int w, int h) const ;</a></h4>

Calls <tt>draw_text_frame()</tt> and then draws a rectangle of
<tt>text_background()</tt> color inside it. It uses
<tt>text_box()->inset()</tt> to figure out where to draw the
rectangle.

<h4><a name=draw_glyph>void Fl_Widget::draw_glyph(int type, int x,int y,int w,int h, Fl_Flags f) const</a></h4>

Calls the <tt>glyph()</tt> function with the given arguments (the
caller must figure out inactive and selected, this is best done by
using the return value from <tt>draw_box()</tt>).

<h4><a name=glyph_color>Fl_Color Fl_WIdget::glyph_color(Fl_Flags f) const ;</a></h4>

Returns the correct color to draw a glyph, based on the values of
<tt>FL_INACTIVE, FL_SELECTED, FL_HIGHLIGHT</tt> of the flags and the
<tt>text_color(), selection_text_color(), highlight_label_color()</tt>
of this widget.

<h4><a name=box_color>Fl_Color Fl_WIdget::box_color(Fl_Flags f) const ;</a></h4>

Returns the correct color to draw the interior of a box, based on the
values of <tt>FL_SELECTED, FL_HIGHLIGHT</tt> of the flags and the
<tt>color(), selection_color(), highlight_color()</tt> of this widget.

<h4><a name=measure_label>void Fl_Widget::measure_label(int& w, int& h) const ;</h4>

Return in w and h the size that the widget's <tt>label()</tt> and
<tt>image()</tt> will take.

<h4><A name=draw_inside_label>void Fl_Widget::draw_inside_label() const
<br>void Fl_Widget::draw_inside_label(int x, int y, int w, int h) const
<br>void Fl_Widget::draw_inside_label(int x, int y, int w, int h,
Fl_Flags f) const</A></h4>

This is the usual function for a <TT>draw()</TT> method to call to 
draw the widget's label.  It does not draw the label if it is supposed 
to be outside the box (on the assumption that the enclosing group will 
draw those labels).

<p>The label consists of the value for <tt>label()</tt> and the value
for <tt>image()</tt>.  The alignment flags control how they are
arranged next to each other in the box. The color to draw the label is
determined by the settings of the flags, the <tt>active_r()</tt>
value, and the <tt>label_color(), selection_text_color(),
highlight_label_color()</tt> of this widget.

<P>The second form uses the passed bounding box instead of the widget's 
bounding box. This allows the widget to draw the label somewhere other
than centered on itself.

<p>The third form lets you force <tt>FL_VALUE</tt> or
<tt>FL_SELECTED</tt> on or off (passed alignment flags are 'or'd with
the widget's flags).

<h4><A name=draw_label>void Fl_Widget::draw_label(int x, int y, int w, int h, Fl_Flags f) const</A></h4>

<P>Draws the label anywhere. This ignores the <TT>FL_ALIGN_INSIDE</TT>
and always draws the label inside the passed bounding box.
This is used by <a href=Fl_Group.html>Fl_Group</a> and <a
href=Fl_Tabs.html>Fl_Tabs</a> to draw outside labels.

<h4><A name=set_visible>void Fl_Widget::set_visible()</A>
<br><A name=clear_visible>void Fl_Widget::clear_visible()</A></h4>

Fast inline versions of <TT>Fl_Widget::hide()</TT> and
<TT>Fl_Widget::show()</TT>. These do not send the <TT>FL_HIDE</TT> and
<TT>FL_SHOW</TT> events to the widget.

<h4><A name=test_shortcut>int Fl_Widget::test_shortcut() const </A></h4>

Tests the value of <tt>shortcut()</tt> and the value of
<tt>label()</tt> (if <tt>FL_NO_SHORTCUT_LABEL</tt> is not set) against
the current event (which must be a <TT>FL_SHORTCUT</TT> or <TT>FL_KEYBOARD</TT>
event). Returns 1 if it matches shortcut(), returns 2 if it matches
the label(), and returns 0 if there is no match.

<h4><A name=set_flag>void Fl_Widget::set_flag(FL_NO_SHORTCUT_LABEL)</A></h4>

Modifies <TT>draw_label()</TT> so that '&amp;' characters do not get
translated into an underscore under the next letter. This flag also
stops <a name=#test_shortcut>Fl_Widget::test_shortcut</a> from looking
at the label for this letter.

<h4><A name=type>uchar Fl_Widget::type() const
<br> void Fl_Widget::type(uchar t)</A></h4>

The property <TT>Fl_Widget::type()</TT> can return an arbitrary 8-bit
identifier, and can be set with the protected method <TT>type(uchar
t)</TT>. This value had to be provided for Forms compatibility, but
you can use it for any purpose you want (mostly for "bad object
oriented programming" where you insert some subclass functionality
into the base class).  Try to keep the value less than 100 to not
interfere with reserved values.

<P>For portability FLTK does not use RTTI (Run Time Typing Infomation)
internally (you are free to use it, though). If you don't have RTTI you can
use the clumsy FLTK mechanisim, by having <TT>type()</TT> use a unique
value.  These unique values must be greater than the symbol
<TT>FL_RESERVED_TYPE</TT> (which is 100).  Look through the header
files for <TT>FL_RESERVED_TYPE</TT> to find an unused number.  If you
make a subclass of <TT>Fl_Window</TT> you must use <TT>FL_WINDOW +
n</TT> (<TT>n</tt> must be in the range 1 to 7), if you
make a subclass of <TT>Fl_Group</TT> you must use <TT>FL_GROUP +
n</TT> (<TT>n</tt> must be in the range 1 to 7) (fltk needs to be able
to identify Fl_Window and Fl_Group subclasses internally).

</body></html>
