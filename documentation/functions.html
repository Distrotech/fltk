<HTML><BODY>
<H1 ALIGN=RIGHT><A NAME=functions>B - Function Reference</A></H1>

This appendix describes all of the <tt>Fl::xyz</tt> functions.  These
are mostly concerned with describing the current event and with doing
event handling and timing.  <tt>Fl::</tt> should be considered a
namespace, although it is defined as a C++ class in the header file to
work with older C++ compilers.

<p>There are a number of other functions with <tt>fl_xyz</tt> names.
These are described in the <a href=drawing.html>Drawing</a> and <a
href=utility.html>Utility</a> sections of the appendix and in the
documentation for individual <a href=widgets.html>Classes</a>.

<H3><A name=add_fd>void Fl::add_fd(int fd, void (*cb)(int, void 
*), void * = 0)
<BR>void Fl::add_fd(int fd, int when, void (*cb)(int, void *), 
void * = 0)</A>
<BR><A name=remove_fd>void Fl::remove_fd(int)</A></H3>

Add file descriptor <tt>fd</tt> to listen to.  When the <tt>fd</tt>
becomes ready for reading the callback is done.  The callback is
passed the <tt>fd</tt> and the arbitrary <tt>void *</tt>
argument. <tt> Fl::wait()</tt> will return immediately after calling
the callback.

<p>The second version takes a <tt>when</tt> bitfield, with the bits
<tt> FL_READ</tt>, <tt>FL_WRITE</tt>, and <tt>FL_EXCEPT</tt> defined,
to indicate when the callback should be done.</p> <p>There can only
be one callback of each type for a file descriptor. <tt>
Fl::remove_fd()</tt> gets rid of <I>all</I> the callbacks for a given
file descriptor.</p>

<p>Under UNIX <I>any</I> file descriptor can be monitored (files,
devices, pipes, sockets, etc.) Due to limitations in Microsoft
Windows, WIN32 applications can only monitor sockets.</p>

<H3><A name=add_handler>void Fl::add_handler(int (*f)(int))</A></H3>

Install a function to parse unrecognized events.  If FLTK cannot 
figure out what to do with an event, it calls each of these functions 
(most recent first) until one of them returns non-zero.  If none of 
them returns non zero then the event is ignored.  Events that cause 
this to be called are: 

<UL>
<LI><tt>FL_SHORTCUT</tt> events that are not recognized by any  widget. 
This lets you provide global shortcut keys.</LI>

<LI>System events that FLTK does not recognize.  See <A
href=osissues.html#fl_xevent><tt>fl_xevent</tt></A>.</LI>

<LI><I>Some</I> other events when the widget FLTK selected  returns 
zero from its <tt>handle()</tt> method.  Exactly which  ones may change 
in future versions, however.</LI>
</UL>

<H3><A name=add_idle>Fl::add_idle(void (*cb)(void *), void *)</A></H3>

Adds a callback function that is called by <tt>Fl::wait()</tt> when 
there is nothing to do. This can be used for background processing. 

<p><I>Warning: this can absorb all your machine's time!</I></p>

<p>You can have multiple idle callbacks. To remove an idle callback use <A
href=#remove_idle><tt>Fl::remove_idle()</tt></A>.</p>

<p><tt>Fl::wait()</tt> and <tt>Fl::check()</tt> call idle callbacks,
but <tt>Fl::ready()</tt> does not.</p>

<p>The idle callback can call any FLTK functions.  However if you call 
something that calls <tt>Fl::wait()</tt> or <tt>Fl::check()</tt> (such
as a message pop-up) you  should first remove the idle callback so that
it does not recurse.</p>

<H3><A name=add_timeout>void Fl::add_timeout(float t, void 
(*cb)(void *),void *v=0)</A></H3>

Add a one-shot timeout callback.  The timeout will happen as soon as 
possible after <tt>t</tt> seconds after the last time <tt>wait()</tt>
was called.  The optional <tt>void *</tt> argument is passed to the 
callback. 

<p>This code will print &quot;TICK&quot; each second on stdout, no matter what 
else the user or program does:</p>

<UL><PRE>void callback(void *) {
  printf(&quot;TICK\n&quot;);
  Fl::add_timeout(1.0,callback);
}

main() {
  Fl::add_timeout(1.0,callback);
  Fl::run();
}</PRE></UL>

<H3><A name=arg>int Fl::arg(int argc, char **argv, int &amp;i)</A></H3>

Consume a single switch from <tt>argv</tt>, starting at word i. 
Returns the number of words eaten (1 or 2, or 0 if it is not 
recognized) and adds the same value to <tt>i</tt>.  You can use this 
function if you prefer to control the incrementing through the 
arguments yourself. 

<H3><A name=args>int Fl::args(int argc, char **argv, int &amp;i, int 
(*callback)(int, char**,int &amp;)=0)
<BR> void Fl::args(int argc, char **argv)</A></H3>

FLTK provides an <I>entirely optional</I> command-line switch parser. 
You don't have to call it if you don't like them! Everything it can do 
can be done with other calls to FLTK. 

<p>To use the switch parser, call <tt>Fl::args(...)</tt> near the
start of your program.  This does <I>not</I> open the display, instead
switches that need the display open are stashed into static variables.
Then you <I>must</I> display your first window by calling <A
href=Fl_Window.html#Fl_Window.show> window-&gt;show(argc,argv)</A>,
which will do anything stored in the static variables.</p>

<p><tt>callback</tt> lets you define your own switches.  It is called 
with the same <tt>argc</tt> and <tt>argv</tt>, and with <tt>i</tt> the 
index of each word. The callback should return zero if the switch is 
unrecognized, and not change <tt>i</tt>.  It should return non-zero if 
the switch is recognized, and add at least 1 to <tt>i</tt> (it can add 
more to consume words after the switch).  This function is called 
<i>before</i> any other tests, so <i>you can override any FLTK
switch</i> (this is why fltk can use very short switches instead of
the long ones all other toolkits force you to use).</p>
<p>On return <tt>i</tt> is set to the index of the first non-switch. 
This is either:</p>

<UL>
<LI>The first word that does not start with '-'.</LI>
<LI>The word '-' (used by many programs to name stdin as a file)</LI>
<LI>The first unrecognized switch (return value is 0).</LI>
<LI><tt>argc</tt></LI>
</UL>

The return value is <tt>i</tt> unless an unrecognized switch is found, 
in which case it is zero.  If your program takes no arguments other 
than switches you should produce an error if the return value is less 
than <tt>argc</tt>. 

<p>All switches except -bg2 may be abbreviated one letter and case is
ignored:

<UL>
<LI><tt>-display host:n.n</tt> The X display to use (ignored  under 
WIN32).</LI>
<LI><tt>-geometry WxH+X+Y</tt> The window position and size  will be 
modified according the the standard X geometry string.</LI>
<LI><tt>-name string</tt> Fl_Window::xclass(string) will be  done to 
the window, possibly changing its icon.</LI>
<LI><tt>-title string</tt> Fl_Window::label(string) will be  done to 
the window, changing both its title and the icontitle.</LI>
<LI><tt>-iconic</tt> Fl_Window::iconize() will be done to  the window.</LI>
<LI><tt>-bg color</tt> XParseColor is used to lookup the  passed color 
and then Fl::background() is done.  Under WIN32  only color names of 
the form &quot;#xxxxxx&quot; are understood.</LI>
</UL>

The second form of <tt>Fl::args()</tt> is useful if your program does 
not have command line switches of its own.  It parses all the switches, 
and if any are not recognized it calls <tt>Fl::abort(Fl::help)</tt>. 

<H3><A name=belowmouse>Fl_Widget *Fl::belowmouse() const
<BR>void Fl::belowmouse(Fl_Widget *)</A></H3>

Get or set the widget that is below the mouse.  This is for 
highlighting buttons.  It is not used to send <tt>FL_PUSH</tt> or <tt>
FL_MOVE</tt> directly, for several obscure reasons, but those events 
typically go to this widget.  This is also the first widget tried for <tt>
FL_SHORTCUT</tt> events. 

<p>If you change the belowmouse widget, the previous one and all 
parents (that don't contain the new widget) are sent <tt>FL_LEAVE</tt>
 events.  Changing this does <I>not</I> send <tt>FL_ENTER</tt> to this 
or any widget, because sending <tt>FL_ENTER</tt> is supposed to <I>test</I>
 if the widget wants the mouse (by it returning non-zero from <tt>
handle()</tt>).</p>

<H3><A name=check>int Fl::check()</A></H3>

This does the same thing as <tt>Fl::wait(0)</tt>, except because it 
does not have to return the elapsed time value it can be implemented 
faster on certain systems.  Use this to interrupt a big calculation: 

<UL><PRE>while (!calculation_done()) {
  calculate();
  Fl::check();
  if (user_hit_abort_button()) break;
}</PRE></UL>

This returns non-zero if any windows are displayed, and 0 if no 
windows are displayed. 

<H3><A name=damage>int Fl::damage()</A></H3>

If true then <A href=#flush><tt>flush()</tt></A> will do something. 

<H3><A name=display>void Fl::display(const char *)</A></H3>

Sets the X display to use for all windows.  Actually this just sets
the environment variable $DISPLAY to the passed string, so this only
works before you show() the first window or otherwise open the display,
and does nothing useful under WIN32. 

<H3><A name=event_button>int Fl::event_button()</A></H3>

Returns which mouse button was pressed.  This returns garbage if the 
most recent event was not a <tt>FL_PUSH</tt> or <tt>FL_RELEASE</tt>
event. 

<H3><A name=event_clicks>int Fl::event_clicks()
<BR>void Fl::event_clicks(int)</A></H3>

The first form returns non-zero if the most recent <tt>FL_PUSH</tt> or <tt>
FL_KEYBOARD</tt> was a &quot;double click&quot;.  Returns N-1 for N clicks.  A 
double click is counted if the same button is pressed again while <tt>
event_is_click()</tt> is true. 

<p>The second form directly sets the number returned by <tt>
Fl::event_clicks()</tt>.  This can be used to set it to zero so that 
later code does not think an item was double-clicked.</p>

<H3><A name=event_inside>int Fl::event_inside(const Fl_Widget *) const
<BR>int Fl::event_inside(int x, int y, int w, int h)</A></H3>

Returns non-zero if the current <tt>event_x</tt> and <tt>event_y</tt>
put it inside the widget or inside an arbitrary bounding box.  You 
should always call this rather than doing your own comparison so you 
are consistent about edge effects. 

<H3><A name=event_is_click>int Fl::event_is_click()
<BR>void Fl::event_is_click(0)</A></H3>

The first form returns non-zero if the mouse has not moved far enough 
and not enough time has passed since the last <tt>FL_PUSH</tt> or <tt>
FL_KEYBOARD</tt> event for it to be considered a &quot;drag&quot; rather than a 
&quot;click&quot;.  You can test this on <tt>FL_DRAG</tt>, <tt>FL_RELEASE</tt>, 
and <tt>FL_MOVE</tt> events.  The second form clears the value returned 
by <tt>Fl::event_is_click()</tt>.  Useful to prevent the <I>next</I>
click from being counted as a double-click or to make a popup menu 
pick an item with a single click.  Don't pass non-zero to this. 

<H3><A name=event_key>int Fl::event_key()
<BR> int Fl::event_key(int)</A>
<BR><A name=get_key>int Fl::get_key(int)</A></H3>

<tt>Fl::event_key()</tt> returns which key on the keyboard was last 
pushed. 

<p><tt>Fl::event_key(int)</tt> returns true if the given key was held 
down (or pressed) <I>during</I> the last event.  This is constant until 
the next event is read from the server.</p>

<p><tt>Fl::get_key(int)</tt> returns true if the given key is held down <I>
now</I>.  Under X this requires a round-trip to the server and is <I>
much</I> slower than <tt>Fl::event_key(int)</tt>.</p>

<p>Keys are identified by the <I>unshifted</I> values. FLTK defines a 
set of symbols that should work on most modern machines for every key 
on the keyboard:</p>

<UL>
<LI>All keys on the main keyboard producing a printable ASCII 
character use the value of that ASCII character (as though shift, 
ctrl, and caps lock were not on).  The space bar is 32.</LI>

<LI>All keys on the numeric keypad producing a printable ASCII 
character use the value of that ASCII character plus <tt>FL_KP</tt>. 
The highest possible value is <tt>FL_KP_Last</tt> so you can 
range-check to see if something is  on the keypad.</LI>

<LI>All numbered function keys use the number on the function key plus <tt>
FL_F</tt>.  The highest possible number is <tt>FL_F_Last</tt>, so you 
can range-check a value.</LI>

<LI>Buttons on the mouse are considered keys, and use the button 
number (where the left button is 1) plus <tt>FL_Button</tt>.</LI>

<LI>All other keys on the keypad have a symbol: <tt>FL_Escape, 
FL_BackSpace, FL_Tab, FL_Enter, FL_Print, FL_Scroll_Lock, FL_Pause, 
FL_Insert, FL_Home, FL_Page_Up, FL_Delete, FL_End, FL_Page_Down, 
FL_Left, FL_Up, FL_Right, FL_Down, FL_Shift_L, FL_Shift_R, 
FL_Control_L, FL_Control_R, FL_Caps_Lock, FL_Alt_L, FL_Alt_R, 
FL_Meta_L, FL_Meta_R, FL_Menu, FL_Num_Lock, FL_KP_Enter</tt>.  Be 
careful not to confuse these with the very similar, but all-caps, 
symbols used by <A href=events.html#event_state><tt>Fl::event_state()</tt>
</A>.</LI>
</UL>

On X <tt>Fl::get_key(FL_Button+n)</tt> does not work. 

<p>On WIN32 <tt>Fl::get_key(FL_KP_Enter)</tt> and <tt>
Fl::event_key(FL_KP_Enter)</tt> do not work.</p>

<H3><A name=event_length>char *Fl::event_length()</A></H3>

Returns the length of the text in <tt>Fl::event_text()</tt>.  There 
will always be a nul at this position in the text.  However there may 
be a nul before that if the keystroke translates to a nul character or 
you paste a nul character. 

<H3><A name=event_state>ulong Fl::event_state()
<BR> unsigned int Fl::event_state(ulong)</A></H3>

This is a bitfield of what shift states were on and what mouse buttons 
were held down during the most recent event.  The second version 
returns non-zero if any of the passed bits are turned on.  The legal 
bits are: 

<UL>
<LI><tt>FL_SHIFT</tt></LI>
<LI><tt>FL_CAPS_LOCK</tt></LI>
<LI><tt>FL_CTRL</tt></LI>
<LI><tt>FL_ALT</tt></LI>
<LI><tt>FL_NUM_LOCK</tt></LI>
<LI><tt>FL_META</tt></LI>
<LI><tt>FL_SCROLL_LOCK</tt></LI>
<LI><tt>FL_BUTTON1</tt></LI>
<LI><tt>FL_BUTTON2</tt></LI>
<LI><tt>FL_BUTTON3</tt></LI>
</UL>

X servers do not agree on shift states, and FL_NUM_LOCK, FL_META, and 
FL_SCROLL_LOCK may not work.  The values were selected to match the 
XFree86 server on Linux.  In addition there is a bug in the way X works 
so that the shift state is not correctly reported until the first event <I>
after</I> the shift key is pressed or released. 

<H3><A name=event_text>char *Fl::event_text()</A></H3>

Returns the ASCII text (in the future this may be UTF-8) produced by 
the last <tt>FL_KEYBOARD</tt> or <tt>FL_PASTEM</tt> or possibly other 
event.  A zero-length string is returned for any keyboard function keys 
that do not produce text. This pointer points at a static buffer and is 
only valid until the next event is processed. 

<p>Under X this is the result of calling <tt>XLookupString()</tt>.</p>

<H3><A name=event_x>int Fl::event_x()
<BR><A name=event_y>int Fl::event_y()</A></A></H3>

Returns the mouse position of the event relative to the <tt>Fl_Window</tt>
it was passed to. 

<H3><A name=event_x_root>int Fl::event_x_root()
<BR><A name=event_y_root>int Fl::event_y_root()</A></A></H3>

Returns the mouse position on the screen of the event.  To find the 
absolute position of an <tt>Fl_Window</tt> on the screen, use the 
difference between <tt>event_x_root(),event_y_root()</tt> and <tt>
event_x(),event_y()</tt>. 

<H3><A name=first_window>Fl_Window *Fl::first_window()</A></H3>

Returns the first top-level window in the list of shown() windows.  If
a modal() window is shown this is the top-most modal window, otherwise
it is the most recent window to get an event.

<H3><A name=first_window>void Fl::first_window(Fl_Window*)</A></H3>

Since the first window is used by default as the "parent" of modal
windows, changing it is useful.  This removes the window from wherever
it is in the list and inserts it at the top.  This is not done if
Fl::modal() is on or if the window is not shown().

<H3><A name=next_window>Fl_Window *Fl::next_window(Fl_Window *)</A></H3>

Returns the next top-level window in the list of shown() windows.  You can 
use this call to iterate through all the windows that are shown(). 

<H3><A name=flush>void Fl::flush()</A></H3>

Causes all the windows that need it to be redrawn and graphics forced 
out through the pipes.  This is what <tt>wait()</tt> does before 
looking for events. 

<H3><A name=focus>Fl_Widget *Fl::focus() const;
<BR>void Fl::focus(Fl_Widget *)</A></H3>

Get or set the widget that will receive <tt>FL_KEYBOARD</tt> events. 

<p>If you change <tt>Fl::focus()</tt>, the previous widget and all 
parents (that don't contain the new widget) are sent <tt>FL_UNFOCUS</tt>
 events.  Changing the focus does <I>not</I> send <tt>FL_FOCUS</tt> to 
this or any widget, because sending <tt>FL_FOCUS</tt> is supposed to <I>
test</I> if the widget wants the focus (by it returning non-zero from <tt>
handle()</tt>).</p>

<H3><A name=get_mouse>void Fl::get_mouse(int &amp;x, int &amp;y)</A></H3>

Return where the mouse is on the screen by doing a round-trip query to 
the server.  You should use <tt>Fl::event_x_root()</tt> and <tt>
Fl::event_y_root()</tt> if possible, but this is necessary if you are 
not sure if a mouse event has been processed recently (such as to 
position your first window).  If the display is not open, this will 
open it. 

<H3><A name=gl_visual>int Fl::gl_visual(int)</A></H3>

This does the same thing as <A
href=#visual><tt>Fl::visual(int)</tt></A> but also requires OpenGL
drawing to work.  This <I>must</I> be done if you want to draw in
normal windows with OpenGL with <A href=opengl.html#gl_start>
<tt>gl_start()</tt></A> and <tt>gl_end()</tt>.  It may be useful to
call this so your X windows use the same visual as an <A
href=Fl_Gl_Window.html#Fl_Gl_Window> <tt>Fl_Gl_Window</tt></A>, which
on some servers will reduce colormap flashing.

<p>See <A href=Fl_Gl_Window.html#Fl_Gl_Window.mode><tt>Fl_Gl_Window</tt></A>
for a list of additional values for the argument.</p>

<H3><A name=grab>void grab(int (*)(int, void*), void*);
<BR>void release();
<BR>int (*Fl::grab())(int, void*);</A></H3>

This is used when pop-up menu systems are active.  All user events are
sent to the passed function, rather than going to widgets.  The
<tt>void*</tt> argument can be used to pass arbitrary data to this
function.

<p>This messes with the window system so you get the events no matter
where the cursor is on the screen.  <i>Under both X and WIN32 some
window must be mapped because the system interface needs a window id.
Be careful that your program does not enter an infinite loop 
while <tt>grab()</tt> is on.  On X this will lock up your screen!</I></p>

<p>To turn off grabbing do <tt>Fl::release()</tt>.

<p><tt>Fl::grab()</tt> returns the current function, this is useful for
checking if a grab is active.

<H3><A name=h>int Fl::h()</A></H3>

Returns the height of the screen in pixels. 

<H3><A name=handle>int Fl::handle(int, Fl_Window *)</A></H3>

Sends the event to a window for processing.  Returns non-zero if any 
widget uses the event. 

<H3><A name=help>const char *Fl::help</A></H3>

This is the usage string that is displayed if <tt>Fl::args()</tt>
detects an invalid argument on the command-line. 

<H3><A name=modal>Fl_Window *Fl::modal()</A></H3>

Returns the top-most <tt>modal()</tt> window currently shown.  This is
the most recently <tt>shown()</tt> window with <A
href=Fl_Window.html#Fl_Window.modal><tt> modal()</tt></A> true, or
<tt>NULL</tt> if there are no <tt>modal()</tt> windows
<tt>shown()</tt>.  The <tt>modal()</tt> window has its
<tt>handle()</tt> method called for all events, and no other windows
will have <tt>handle()</tt> called (<A href=#grab><tt>grab()</tt></A>
overrides this).

<H3><A name=own_colormap>void Fl::own_colormap()</A></H3>

Makes FLTK use its own colormap.  This may make FLTK display better 
and will reduce conflicts with other programs that want lots of colors. 
However the colors may flash as you move the cursor between windows. 

<p>This does nothing if the current visual is not colormapped.</p>

<H3><A name=paste>void Fl::paste(Fl_Widget *receiver)</A></H3>

Set things up so the receiver widget will be called with an <A href=#FL_PASTE>
<tt>FL_PASTE</tt></A> event some time in the future. The reciever 
should be prepared to be called <I>directly</I> by this, or for it to 
happen <I>later</I>, or possibly <I>not at all</I>.  This allows the 
window system to take as long as necessary to retrieve the paste buffer 
(or even to screw up completely) without complex and error-prone 
synchronization code in FLTK. 

<H3><A name=pushed>Fl_Widget *Fl::pushed() const
<BR>void Fl::pushed(Fl_Widget *)</A></H3>

Get or set the widget that is being pushed. <tt>FL_DRAG</tt> or <tt>
FL_RELEASE</tt> (and any more <tt>FL_PUSH</tt>) events will be sent to 
this widget. 

<p>If you change the pushed widget, the previous one and all parents 
(that don't contain the new widget) are sent <tt>FL_RELEASE</tt>
events.  Changing this does <I>not</I> send <tt>FL_PUSH</tt> to this 
or any widget, because sending <tt>FL_PUSH</tt> is supposed to <I>test</I>
if the widget wants the mouse (by it returning non-zero from <tt>
handle()</tt>).</p>

<H3><A name=readqueue>Fl_Widget *Fl::readqueue()</A></H3>

All <tt>Fl_Widgets</tt> that don't have a callback defined use a 
default callback that puts a pointer to the widget in this queue, and 
this method reads the oldest widget out of this queue. 

<H3><A name=ready>int Fl::ready()</A></H3>

Returns non-zero if there are pending timeouts or events or file 
descriptors.  This does <I>not</I> call <tt>Fl::flush()</tt> or any 
callbacks, which is useful if your program is in a state where such 
callbacks are illegal: 

<UL><PRE>while (!calculation_done()) {
  calculate();
  if (Fl::ready()) {
    do_expensive_cleanup();
    Fl::check();
    if (user_hit_abort_button()) break;
  }
}</PRE></UL>

<H3><A name=redraw>void Fl::redraw()</A></H3>

Redraws all widgets. 

<H3><A name=remove_idle>void Fl::remove_idle(void (*cb)(void *), 
void *= 0)</A></H3>

Removes the specified idle callback. 

<H3><A name=remove_timeout>void Fl::remove_timeout(void (*cb)(void *),
void *= 0)</A></H3>

Removes a timeout callback. It is harmless to remove a timeout 
callback that no longer exists. 

<H3><A name=run>int Fl::run()</A></H3>

Runs FLTK until there are no windows displayed, and then returns a 
zero. <tt>Fl::run()</tt> is <I>exactly equivalent to:</I>

<UL><PRE>while (Fl::wait());
return 0;
</PRE></UL>

<H3><A name=selection>void Fl::selection(Fl_Widget *owner, const 
char *stuff, int len)
<BR>const char* Fl::selection()
<BR>int Fl::selection_length()</A></H3>

The first form changes the current selection.  The block of text is 
copied to an internal buffer by FLTK (be careful if doing this in 
response to an <tt>FL_PASTE</tt> as this <I>may</I> be the same buffer 
returned by <tt>event_text()</tt>).  The <tt>selection_owner()</tt>
widget is set to the passed owner (possibly sending <tt>
FL_SELECTIONCLEAR</tt> to the previous owner).  The second form looks 
at the buffer containing the current selection.  The contents of this 
buffer are undefined if this program does not own the current 
selection. 

<H3><A name=selection_owner>Fl_Widget *Fl::selection_owner() const
<BR>void Fl::selection_owner(Fl_Widget *)</A></H3>

The single-argument <tt>selection_owner(x)</tt> call can be used to
move the selection to another widget or to set the owner to
<tt>NULL</tt>, without changing the actual text of the selection. <tt>
FL_SELECTIONCLEAR</tt> is sent to the previous selection owner, if
any.

<p><I>Copying the buffer every time the selection is changed is 
obviously wasteful, especially for large selections.  An interface will 
probably be added in a future version to allow the selection to be made 
by a callback function.  The current interface will be emulated on top 
of this.</I></p>

<H3><A name=test_shortcut>int Fl::test_shortcut(ulong) const</A></H3>

Test the current event, which must be an <tt>FL_KEYBOARD</tt> or <tt>
FL_SHORTCUT</tt>, against a shortcut value (described in <A
href=Fl_Button.html#Fl_Button.shortcut> <tt>Fl_Button</tt></A>).
Returns non-zero if there is a match.  Not to be confused with <A
href=#Fl_Widge.test_shortcut><tt> Fl_Widget::test_shortcut()</tt></A>.

<H3><A name=visual>int Fl::visual(int)</A></H3>

Selects a visual so that your graphics are drawn correctly.  This does 
nothing if the default visual satisfies the capabilities, or if no 
visual satisfies the capabilities, or on systems that don't have such 
brain-dead notions. 

<p>Only the following combinations do anything useful:</p>

<UL>
<LI><tt>Fl::visual(FL_RGB)</tt>
<BR>Full/true color (if there are several depths FLTK chooses  the 
largest).  Do this if you use <A href=#fl_draw_image><tt>fl_draw_image</tt>
</A> for much better (non-dithered)  output. 
<BR>&nbsp;</LI>
<LI><tt>Fl::visual(FL_RGB8)</tt>
<BR>Full color with at least 24 bits of color. <tt>FL_RGB</tt> will 
always  pick this if available, but if not it will happily return a 
 less-than-24 bit deep visual.  This call fails if 24 bits are not 
 available. 
<BR>&nbsp;</LI>
<LI><tt>Fl::visual(FL_DOUBLE|FL_INDEX)</tt>
<BR>Hardware double buffering.  Call this if you are going to use <A href=Fl_Double_Window.html#Fl_Double_Window>
<tt>Fl_Double_Window</tt></A>. 
<BR>&nbsp;</LI>
<LI><tt>Fl::visual(FL_DOUBLE|FL_RGB)</tt></LI>
<LI><tt>Fl::visual(FL_DOUBLE|FL_RGB8)</tt>
<BR>Hardware double buffering and full color. 
<BR>&nbsp;</LI>
</UL>

This returns true if the system has the capabilities by default or 
FLTK suceeded in turing them on.  Your program will still work even if 
this returns false (it just won't look as good). 

<H3><A name=w>int Fl::w()</A></H3>

Returns the width of the screen in pixels. 

<H3><A name=wait>int Fl::wait()
<BR>double Fl::wait(double time)</A></H3>

Calls <a name=flush><tt>Fl::flush()</tt> to make the screen update,
then this function waits the until <i>either</i> the given time
passes, or some event, timeout, idle, or file descriptor callback
happens.  It executes all the things that are already ready when this
is called, or that become ready simultaneously, for instance all
pending events from the window system are executed.

<p>It is important to realize that this returns immediately after
callbacks and handlers are called, not when <i>time</i> passes.  The
purpose of <tt>wait()</tt> is to return <i>when the state of your
program has changed</i>, not for evenly spacing events.  Your program can
check its global state and update things after each call to
<tt>Fl::wait()</tt>, which can be very useful in complex programs.</p>

<p>Plain <tt>wait()</tt> does an infinite timeout.  The return value is
non-zero if there are any windows displayed after all the events and
callbacks are handled.

<p><tt>wait(time)</tt> waits a <i>maximum</i> of <i>time</i> seconds.
The return value is how much time remains.  If the return value is
zero or negative then the entire time period elapsed.</p>

<p>If you do several <tt>wait(time)</tt> calls in a row, the
subsequent ones are measured from when the first one returned, even if
you do time-consuming calculations after they return (or if the flush
takes a long time).  This allows you to accurately make something
happen at regular intervals.  This code will accurately call
<tt>A()</tt> once per second (as long as A() takes less than a second
to execute):</p>

<UL><PRE>for (;;) {
  for (float time = 1.0; time &gt; 0; ) time = Fl::wait(time);
  A();
}</PRE></UL>

<p>PS: this accurate timing is currently broken due to some misguided
fixes put into the fltk code.  I plan to fix it someday...

<H3><A name=warning>void (*Fl::warning)(const char *, ...)</A>
<BR><A name=error>void (*Fl::error)(const char *, ...)</A>
<BR><A name=fatal>void (*Fl::fatal)(const char *, ...)</A></H3>

FLTK will call these to print messages when unexpected conditions 
occur.  By default they <tt>fprintf</tt> to <tt>stderr</tt>, and <tt>
Fl::error</tt> and <tt>Fl::fatal</tt> call <tt>exit(1)</tt>.  You can 
override the behavior by setting the function pointers to your own 
routines. 

<p><tt>Fl::warning</tt> means that there was a recoverable problem, the 
display may be messed up but the user can probably keep working (all X 
protocol errors call this). <tt>Fl::error</tt> means there is a 
recoverable error, but the display is so messed up it is unlikely the 
user can continue (very little calls this now). <tt>Fl::fatal</tt> must 
not return, as FLTK is in an unusable state, however your version may 
be able to use <tt>longjmp</tt> or an exception to continue, as long as 
it does not call FLTK again.</p>

</BODY></HTML>
