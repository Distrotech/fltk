<html><head><title>Fl::functions</title></head><body bgcolor = white>

<h1 align=right><A NAME=functions>B - The Fl:: Functions</A></h1>

This appendix describes all of the <tt>Fl::xyz</tt> functions.  These
functions mostly are concerned with event handling and waiting for
events.  <tt>Fl::</tt> should be considered a namespace, although it
is defined as a C++ class in the header file to work with older C++
compilers.

<p>FLTK also provides a number of global functions with
<tt>fl_xyz</tt> names. The majority of these are concerned with
drawing or graphics state, and are described in the <a
href=drawing.html>Drawing</a> appendix. The others are a set of modal
popup utility functions for asking questions described in 
the <a href=utility.html>Utility</a> appendix.

<p>Also see the description of all the classes listed in the <a
href=widgets.html>Classes</a> appendix.

<h3><A name=add_fd>void Fl::add_fd(int fd, void (*cb)(int, void 
*), void* = 0)
<BR>void Fl::add_fd(int fd, int when, void (*cb)(int, void*), void* = 0)</A>
<BR><A name=remove_fd>void Fl::remove_fd(int)</A></h3>

Add file descriptor <tt>fd</tt> to listen to.  When the <tt>fd</tt>
becomes ready for reading <tt>Fl::wait()</tt> will call the callback
and then return.  The callback is
passed the <tt>fd</tt> and the arbitrary <tt>void*</tt> argument.

<P>The second version takes a <tt>when</tt> bitfield, with the bits
<tt>FL_READ</tt>, <tt>FL_WRITE</tt>, and <tt>FL_EXCEPT</tt> defined,
to indicate when the callback should be done.

<P>There can only be one callback of each type for a file descriptor. <tt>
Fl::remove_fd()</tt> gets rid of <I>all</I> the callbacks for a given
file descriptor.

<P>Under UNIX <I>any</I> file descriptor can be monitored (files,
devices, pipes, sockets, etc.) Due to limitations in Microsoft Windows,
WIN32 applications can only monitor sockets.

<h3><A name=add_handler>void Fl::add_handler(int (*f)(int))</A></h3>

Install a function to parse unrecognized events.  If FLTK cannot 
figure out what to do with an event, it calls each of these functions 
(most recent first) until one of them returns non-zero.  If none of 
them returns non zero then the event is ignored.  Events that cause 
this to be called are: 

<UL>
<LI><tt>FL_SHORTCUT</tt> events that are not recognized by any  widget. 
This lets you provide global shortcut keys.</LI>

<LI>System events that FLTK does not recognize.  See <A
href=osissues.html#fl_xevent><tt>fl_xevent</tt></A>.</LI>

<LI><I>Some</I> other events when the widget FLTK selected  returns 
zero from its <tt>handle()</tt> method.  Exactly which  ones may change 
in future versions, however.</LI>
</UL>

<h3><A name=add_idle>Fl::add_idle(void (*cb)(void*), void*)</A></h3>

Adds a callback function that is called every time by
<tt>Fl::wait()</tt> and also makes it act as though the timeout is
zero (this makes <tt>Fl::wait()</tt> return immediately, so if it is
in a loop it is called repeatedly, and thus the idle fucntion is
called repeatedly).  The idle function can be used to get background
processing done.

<P>You can have multiple idle callbacks. To remove an idle callback use <A
href=#remove_idle><tt>Fl::remove_idle()</tt></A>.

<P><tt>Fl::wait()</tt> and <tt>Fl::check()</tt> call idle callbacks,
but <tt>Fl::ready()</tt> does not.

<P>The idle callback can call any FLTK functions, including
<tt>Fl::wait()</tt>, <tt>Fl::check()</tt>, and <tt>Fl::ready()</tt>.
Fltk will not recursively call the idle callback.

<h3><A name=add_timeout>static void Fl::add_timeout(float t, void (*cb)(void*),void*v=0)</A></h3>

Add a one-shot timeout callback.  The function will be called by
<tt>Fl::wait()</tt> at <i>t</i> seconds after this function is called.
The optional <tt>void*</tt> argument is passed to the callback.

<h3><A name=repeat_timeout>static void Fl::repeat_timeout(float t, void (*cb)(void*),void*v=0)</A></h3>

Inside a timeout callback you can call this to add another timeout.
Rather than the time being measured from "now", it is measured from
when the system call elapsed that caused this timeout to be called.  This
will result in far more accurate spacing of the timeout callbacks, it
also has slightly less system call overhead.  (It will also use all
your machine time if your timeout code and fltk's overhead take more
than <i>t</i> seconds, as the real timeout will be reduced to zero).

<p>It is undefined what this does if called from outside a timeout
callback.

<P>This code will print &quot;TICK&quot; each second on stdout, with a
fair degree of accuracy:

<UL><PRE>void callback(void*) {
  printf(&quot;TICK\n&quot;);
  Fl::repeat_timeout(1.0,callback);
}

main() {
  Fl::add_timeout(1.0,callback);
  for (;;) Fl::wait();
}</PRE></UL>

<h3><A name=add_timeout>static void Fl::add_check(void (*cb)(void*),void*v=0)</A></h3>

Fltk will call this callback just before it flushes the display and
waits for events.  This is different than an idle callback because it
is only called once, then fltk calls the system and tells it not to
return until an event happens.

<p>This can be used by code that wants to monitor the
application's state, such as to keep a display up to date. The
advantage of using a check callback is that it is called only when no
events are pending. If events are coming in quickly, whole blocks of
them will be processed before this is called once. This can save
significant time and avoid the application falling behind the events.

<p>Sample code:

<ul><pre>bool state_changed; // anything that changes the display turns this on

void callback(void*) {
  if (!state_changed) return;
  state_changed = false;
  do_expensive_calculation();
  widget->redraw();
}

main() {
  Fl::add_check(1.0,callback);
  return Fl::run();
}</pre></ul>

<h3><A name=arg>int Fl::arg(int argc, char **argv, int &amp;i)</A></h3>

Consume a single switch from <tt>argv</tt>, starting at word i. 
Returns the number of words eaten (1 or 2, or 0 if it is not 
recognized) and adds the same value to <tt>i</tt>.  You can use this 
function if you prefer to control the incrementing through the 
arguments yourself. 

<h3><A name=args>int Fl::args(int argc, char **argv, int &amp;i, int 
(*callback)(int, char**,int &amp;)=0)
<BR> void Fl::args(int argc, char **argv)</A></h3>

FLTK provides an <I>entirely optional</I> command-line switch parser. 
You don't have to call it if you don't like them! Everything it can do 
can be done with other calls to FLTK. 

<p>To use the switch parser, call <tt>Fl::args(...)</tt> near the
start of your program.  This does <I>not</I> open the display, instead
switches that need the display open are stashed into static variables.
Then you <I>must</I> display your first window by calling <A
href=Fl_Window.html#show> window-&gt;show(argc,argv)</A>,
which will do anything stored in the static variables.</p>

<p><tt>callback</tt> lets you define your own switches.  It is called 
with the same <tt>argc</tt> and <tt>argv</tt>, and with <tt>i</tt> the 
index of each word. The callback should return zero if the switch is 
unrecognized, and not change <tt>i</tt>.  It should return non-zero if 
the switch is recognized, and add at least 1 to <tt>i</tt> (it can add 
more to consume words after the switch).  This function is called 
<i>before</i> any other tests, so <i>you can override any FLTK
switch</i> (this is why fltk can use very short switches instead of
the long ones all other toolkits force you to use).</p>
<p>On return <tt>i</tt> is set to the index of the first non-switch. 
This is either:</p>

<UL>
<LI>The first word that does not start with '-'.</LI>
<LI>The word '-' (used by many programs to name stdin as a file)</LI>
<LI>The first unrecognized switch (return value is 0).</LI>
<LI><tt>argc</tt></LI>
</UL>

The return value is <tt>i</tt> unless an unrecognized switch is found, 
in which case it is zero.  If your program takes no arguments other 
than switches you should produce an error if the return value is less 
than <tt>argc</tt>. 

<p>All switches except -bg2 may be abbreviated one letter and case is
ignored:

<UL>
<LI><tt>-display host:n.n</tt> The X display to use (ignored  under 
WIN32).</LI>
<LI><tt>-geometry WxH+X+Y</tt> The window position and size  will be 
modified according the the standard X geometry string.</LI>
<LI><tt>-name string</tt> Fl_Window::xclass(string) will be  done to 
the window, possibly changing its icon.</LI>
<LI><tt>-title string</tt> Fl_Window::label(string) will be  done to 
the window, changing both its title and the icontitle.</LI>
<LI><tt>-iconic</tt> Fl_Window::iconize() will be done to  the window.</LI>
<LI><tt>-bg color</tt> XParseColor is used to lookup the  passed color 
and then Fl::background() is done.  Under WIN32  only color names of 
the form &quot;#xxxxxx&quot; are understood.</LI>
</UL>

The second form of <tt>Fl::args()</tt> is useful if your program does 
not have command line switches of its own.  It parses all the switches, 
and if any are not recognized it calls <tt>Fl::abort(Fl::help)</tt>. 

<h3><A name=belowmouse>Fl_Widget *Fl::belowmouse() const
<BR>void Fl::belowmouse(Fl_Widget *)</A></h3>

Get or set the widget that is below the mouse.  This is for 
highlighting buttons.  It is not used to send <tt>FL_PUSH</tt> or <tt>
FL_MOVE</tt> directly, for several obscure reasons, but those events 
typically go to this widget.  This is also the first widget tried for <tt>
FL_SHORTCUT</tt> events. 

<p>If you change the belowmouse widget, the previous one and all 
parents (that don't contain the new widget) are sent <tt>FL_LEAVE</tt>
 events.  Changing this does <I>not</I> send <tt>FL_ENTER</tt> to this 
or any widget, because sending <tt>FL_ENTER</tt> is supposed to <I>test</I>
 if the widget wants the mouse (by it returning non-zero from <tt>
handle()</tt>).</p>


<h3><A name=check>static int Fl::check()</A></h3>

Same as <tt>Fl::wait(0)</tt>.  Calling this during a big calculation
will keep the screen up to date and the interface responsive:

<ul><pre>while (!calculation_done()) {
 calculate();
 Fl::check();
 if (user_hit_abort_button()) break;
}</pre></ul>

<h3><A name=damage>int Fl::damage()</A></h3>

If true then <A href=#flush><tt>flush()</tt></A> will do something. 

<h3><A name=display>void Fl::display(const char *)</A></h3>

Sets the X display to use for all windows.  Actually this just sets
the environment variable $DISPLAY to the passed string, so this only
works before you show() the first window or otherwise open the display,
and does nothing useful under WIN32. 

<h3><A name=event_button>int Fl::event_button()</A></h3>

Returns which mouse button was pressed.  This returns garbage if the 
most recent event was not a <tt>FL_PUSH</tt> or <tt>FL_RELEASE</tt>
event. 

<h3><A name=event_clicks>int Fl::event_clicks()
<BR>void Fl::event_clicks(int)</A></h3>

The first form returns non-zero if the most recent <tt>FL_PUSH</tt> or <tt>
FL_KEYBOARD</tt> was a &quot;double click&quot;.  Returns N-1 for N clicks.  A 
double click is counted if the same button is pressed again while <tt>
event_is_click()</tt> is true. 

<p>The second form directly sets the number returned by <tt>
Fl::event_clicks()</tt>.  This can be used to set it to zero so that 
later code does not think an item was double-clicked.</p>

<h3><A name=event_inside>int Fl::event_inside(const Fl_Widget *) const
<BR>int Fl::event_inside(int x, int y, int w, int h)</A></h3>

Returns non-zero if the current <tt>event_x</tt> and <tt>event_y</tt>
put it inside the widget or inside an arbitrary bounding box.  You 
should always call this rather than doing your own comparison so you 
are consistent about edge effects. 

<h3><A name=event_is_click>int Fl::event_is_click()
<BR>void Fl::event_is_click(0)</A></h3>

The first form returns non-zero if the mouse has not moved far enough 
and not enough time has passed since the last <tt>FL_PUSH</tt> or <tt>
FL_KEYBOARD</tt> event for it to be considered a &quot;drag&quot; rather than a 
&quot;click&quot;.  You can test this on <tt>FL_DRAG</tt>, <tt>FL_RELEASE</tt>, 
and <tt>FL_MOVE</tt> events.  The second form clears the value returned 
by <tt>Fl::event_is_click()</tt>.  Useful to prevent the <I>next</I>
click from being counted as a double-click or to make a popup menu 
pick an item with a single click.  Don't pass non-zero to this. 

<h3><A name=event_key>int Fl::event_key()
<BR> int Fl::event_key(int)</A>
<BR><A name=get_key>int Fl::get_key(int)</A></h3>

<tt>Fl::event_key()</tt> returns which key on the keyboard was last
pushed.  It returns zero if the last event was not a key press or release.

<p><tt>Fl::event_key(int)</tt> returns true if the given key was held 
down (or pressed) <I>during</I> the last event.  This is constant until 
the next event is read from the server.</p>

<p><tt>Fl::get_key(int)</tt> returns true if the given key is held down <I>
now</I>.  Under X this requires a round-trip to the server and is <I>
much</I> slower than <tt>Fl::event_key(int)</tt>.</p>

<p>Keys are identified by the <I>unshifted</I> values. FLTK defines a 
set of symbols that should work on most modern machines for every key 
on the keyboard:</p>

<UL>
<LI>All keys on the main keyboard producing a printable ASCII 
character use the value of that ASCII character (as though shift, 
ctrl, and caps lock were not on).  The space bar is 32.</LI>

<LI>All keys on the numeric keypad producing a printable ASCII 
character use the value of that ASCII character plus <tt>FL_KP</tt>. 
The highest possible value is <tt>FL_KP_Last</tt> so you can 
range-check to see if something is  on the keypad.</LI>

<LI>All numbered function keys use the number on the function key plus <tt>
FL_F</tt>.  The highest possible number is <tt>FL_F_Last</tt>, so you 
can range-check a value.</LI>

<LI>Buttons on the mouse are considered keys, and use
<tt>FL_Button+n</tt>, where n is the button number (the left button is
1).

<LI>All other keys on a US 101-keyboard have a symbol.  Be
careful not to confuse these with the very similar, but all-caps, 
symbols used by <A href=events.html#event_state><tt>Fl::event_state()</tt></A>

<ul><tt>FL_Escape<br> FL_BackSpace<br>FL_Tab<br> FL_Enter<br>
FL_Print<br> FL_Scroll_Lock<br> FL_Pause<br> FL_Insert<br> FL_Home<br>
FL_Page_Up<br> FL_Delete<br> FL_End<br> FL_Page_Down<br> FL_Left<br>
FL_Up<br> FL_Right<br> FL_Down<br> FL_Shift_L<br> FL_Shift_R<br>
FL_Control_L<br> FL_Control_R<br> FL_Caps_Lock<br> FL_Alt_L<br>
FL_Alt_R<br> FL_Meta_L<br> FL_Meta_R<br> FL_Menu<br> FL_Num_Lock<br>
FL_KP_Enter</tt></ul>

<li>On X systems any unrecognized keys are reported as their X keysym
value.

</UL>

On X <tt>Fl::get_key(FL_Button+n)</tt> does not work. 

<p>On WIN32 <tt>Fl::get_key(FL_KP_Enter)</tt> and <tt>
Fl::event_key(FL_KP_Enter)</tt> do not work.</p>

<h3><A name=event_length>char *Fl::event_length()</A></h3>

Returns the length of the text in <tt>Fl::event_text()</tt>.  There 
will always be a nul at this position in the text.  However there may 
be a nul before that if the keystroke translates to a nul character or 
you paste a nul character. 

<h3><A name=event_state>ulong Fl::event_state()
<BR>unsigned int Fl::event_state(ulong)</A></h3>

This is a bitfield of what shift states were on and what mouse buttons 
were held down during the most recent event.  The second version 
returns non-zero if any of the passed bits are turned on.  The legal 
bits are: 

<UL>
<LI><tt>FL_SHIFT</tt></LI>
<LI><tt>FL_CAPS_LOCK</tt></LI>
<LI><tt>FL_CTRL</tt></LI>
<LI><tt>FL_ALT</tt></LI>
<LI><tt>FL_NUM_LOCK</tt></LI>
<LI><tt>FL_META</tt></LI>
<LI><tt>FL_SCROLL_LOCK</tt></LI>
<LI><tt>FL_BUTTON1</tt></LI>
<LI><tt>FL_BUTTON2</tt></LI>
<LI><tt>FL_BUTTON3</tt></LI>
</UL>

X servers do not agree on shift states, and FL_NUM_LOCK, FL_META, and 
FL_SCROLL_LOCK may not work.  The values were selected to match the 
XFree86 server on Linux.  In addition there is a bug in the way X works 
so that the shift state is not correctly reported until the first event <I>
after</I> the shift key is pressed or released. 

<A name=event_text><h3>char *Fl::event_text()</h3>

Returns the ASCII text (in the future this may be UTF-8) produced by 
the last <tt>FL_KEYBOARD</tt> or <tt>FL_PASTE</tt> or possibly other 
event.  A zero-length string is returned for any keyboard function keys 
that do not produce text. This pointer points at a static buffer and is 
only valid until the next event is processed. 

<p>Under X this is the result of calling <tt>XLookupString()</tt>.</p>

<a name=compose><h3>int Fl::compose(int&amp; del)</h3>

<p>Use of this function is very simple.  Any text editing widget should
call this for each <tt>FL_KEYBOARD</tt> event.

<p>If <tt>true</tt> is returned, then it has modified the <a
href=#event_text><tt>Fl::event_text()</tt></a> and <a
href=#event_length><tt>Fl::event_length()</tt></a> to a set of
<i>bytes</i> to insert (it may be of zero length!).  It will also set
the <i>del</i> parameter to the number of <i>bytes</i> to the left of
the cursor to delete, this is used to delete the results of the
previous call to Fl::compose().

<p>If <tt>false</tt> is returned, the keys should be treated as
function keys.  You could insert the text anyways, if you don't know
what else to do, <i>del</i> is set to zero and the <a
href=#event_text><tt>Fl::event_text()</tt></a> and <a
href=#event_length><tt>Fl::event_length()</tt></a> are left unchanged,
length is zero for any function keys.

<p>Though the current implementation returns immediately, future
versions may take quite awhile, as they may pop up a window or do
other user-interface things to allow characters to be selected.

<a name=compose_reset><h3>int Fl::compose_reset()</h3>

<p>If the user moves the cursor, be sure to call Fl::compose_reset().
The next call to Fl::compose() will start out in an initial state.  In
particular it will not set "del" to non-zero.  This call is very fast
so it is ok to call it many times and in many places.

<h3><A name=event_x>int Fl::event_x()
<BR><A name=event_y>int Fl::event_y()</A></A></h3>

Returns the mouse position of the event relative to the <tt>Fl_Window</tt>
it was passed to. 

<h3><A name=event_x_root>int Fl::event_x_root()
<BR><A name=event_y_root>int Fl::event_y_root()</A></A></h3>

Returns the mouse position on the screen of the event.  To find the 
absolute position of an <tt>Fl_Window</tt> on the screen, use the 
difference between <tt>event_x_root(),event_y_root()</tt> and <tt>
event_x(),event_y()</tt>. 

<h3><A name=first_window>Fl_Window *Fl::first_window()</A></h3>

Returns the first visible() top-level window. This is the
<a href=#modal>modal()</a> window if it exists, if there are no
modal windows it is the most recent window to get an event. Returns
NULL if no windows are visible.

<h3><A name=first_window_a>void Fl::first_window(Fl_Window*)</A></h3>

Since <a href=#first_window>first_window()</a> is used by default as
the "parent" of modal windows, changing it is useful.  This removes
<i>window</i> from wherever it is in the list and inserts it at the
top, as though it received an event. Code that then shows a modal
window or calls <a href=Fl_Window.html#exec>Fl_Window::exec()</a>
will make this window the "parent".

<h3><A name=next_window>Fl_Window *Fl::next_window(Fl_Window *)</A></h3>

Returns the next visible() top-level window, returns NULL after the
last one.  You can use this and first_window() to iterate through all
the visible windows.

<h3><A name=flush>void Fl::flush()</A></h3>

Causes all the windows that need it to be redrawn and graphics forced 
out through the pipes.  This is what <tt>wait()</tt> does before 
looking for events. 

<h3><A name=focus>Fl_Widget *Fl::focus() const;</a></h3>

Returns the widgets that will receive <tt>FL_KEYBOARD</tt>
events. This is NULL if the application does not have focus now, or if
no widgets accepted focus.

<h3>void Fl::focus(Fl_Widget *)</A></h3>

Change <tt>Fl::focus()</tt> to the given widget, the previous widget and all 
parents (that don't contain the new widget) are sent <tt>FL_UNFOCUS</tt>
events, the new widget and all parents that don't contain the old
widget are sent <tt>FL_FOCUS</tt> events. <tt>focus()</tt> is set whether or
not the applicaton has the focus or if the widgets accept the
focus. You may want to use <a
href=Fl_Widget.html#take_focus>Fl_Widget::take_focus()</a> instead, it
will test first.

<h3><A name=get_mouse>void Fl::get_mouse(int &amp;x, int &amp;y)</A></h3>

Return where the mouse is on the screen by doing a round-trip query to 
the server.  You should use <tt>Fl::event_x_root()</tt> and <tt>
Fl::event_y_root()</tt> if possible, but this is necessary if you are 
not sure if a mouse event has been processed recently (such as to 
position your first window).  If the display is not open, this will 
open it. 

<h3><A name=gl_visual>int Fl::gl_visual(int)</A></h3>

This does the same thing as <A
href=#visual><tt>Fl::visual(int)</tt></A> but also requires OpenGL
drawing to work.  This <I>must</I> be done if you want to draw in
normal windows with OpenGL with <A href=opengl.html#gl_start>
<tt>gl_start()</tt></A> and <tt>gl_end()</tt>.  It may be useful to
call this so your X windows use the same visual as an <A
href=Fl_Gl_Window.html#Fl_Gl_Window> <tt>Fl_Gl_Window</tt></A>, which
on some servers will reduce colormap flashing.

<p>See <A href=Fl_Gl_Window.html#Fl_Gl_Window.mode><tt>Fl_Gl_Window</tt></A>
for a list of additional values for the argument.</p>

<h3><A name=grab>void grab(int (*)(int, void*), void*);
<BR>void release();
<BR>int (*Fl::grab())(int, void*);</A></h3>

This is used when pop-up menu systems are active.  All user events are
sent to the passed function, rather than going to widgets.  The
<tt>void*</tt> argument can be used to pass arbitrary data to this
function.

<p>This messes with the window system so you get the events no matter
where the cursor is on the screen.  <i>Under both X and WIN32 some
window must be mapped because the system interface needs a window id.
Be careful that your program does not enter an infinite loop 
while <tt>grab()</tt> is on.  On X this will lock up your screen!</I></p>

<p>To turn off grabbing do <tt>Fl::release()</tt>.

<p><tt>Fl::grab()</tt> returns the current function, this is useful for
checking if a grab is active.

<h3><A name=h>int Fl::h()</A></h3>

Returns the height of the screen in pixels. 

<h3><A name=handle>int Fl::handle(int, Fl_Window *)</A></h3>

Sends the event to a window for processing.  Returns non-zero if any 
widget uses the event. 

<h3><A name=help>const char *Fl::help</A></h3>

This is the usage string that is displayed if <tt>Fl::args()</tt>
detects an invalid argument on the command-line. 

<h3><A name=modal>Fl_Window *Fl::modal()</A></h3>

Returns the top-most <tt>modal()</tt> window currently shown.  This is
the most recently <tt>shown()</tt> window with <A
href=Fl_Window.html#modal><tt>modal()</tt></A> true, or
<tt>NULL</tt> if there are no <tt>modal()</tt> windows
<tt>shown()</tt>.  The <tt>modal()</tt> window has its
<tt>handle()</tt> method called for all events, and no other windows
will have <tt>handle()</tt> called (<A href=#grab><tt>grab()</tt></A>
overrides this).

<h3><A name=own_colormap>void Fl::own_colormap()</A></h3>

Makes FLTK use its own colormap.  This may make FLTK display better 
and will reduce conflicts with other programs that want lots of colors. 
However the colors may flash as you move the cursor between windows. 

<p>This does nothing if the current visual is not colormapped.</p>

<h3><A name=paste>void Fl::paste(Fl_Widget *receiver)</A></h3>

Set things up so the receiver widget will be called with an <A href=#FL_PASTE>
<tt>FL_PASTE</tt></A> event some time in the future. The reciever 
should be prepared to be called <I>directly</I> by this, or for it to 
happen <I>later</I>, or possibly <I>not at all</I>.  This allows the 
window system to take as long as necessary to retrieve the paste buffer 
(or even to screw up completely) without complex and error-prone 
synchronization code in FLTK. 

<h3><A name=pushed>Fl_Widget *Fl::pushed() const
<BR>void Fl::pushed(Fl_Widget *)</A></h3>

Get or set the widget that is being pushed. <tt>FL_DRAG</tt> or <tt>
FL_RELEASE</tt> (and any more <tt>FL_PUSH</tt>) events will be sent to 
this widget. 

<p>If you change the pushed widget, the previous one and all parents 
(that don't contain the new widget) are sent <tt>FL_RELEASE</tt>
events.  Changing this does <I>not</I> send <tt>FL_PUSH</tt> to this 
or any widget, because sending <tt>FL_PUSH</tt> is supposed to <I>test</I>
if the widget wants the mouse (by it returning non-zero from <tt>
handle()</tt>).</p>

<h3><A name=ready>static int Fl::ready()</A></h3>

This is similar to <tt>Fl::check()</tt> except this does <I>not</I>
call <tt>Fl::flush()</tt> or any callbacks, which is useful if your
program is in a state where such callbacks are illegal.  This returns
true if <tt>Fl::check()</tt> would do anything (it will continue to
return true until you call <tt>Fl::check()</tt> or <tt>Fl::wait()</tt>).

<ul><pre>while (!calculation_done()) {
 calculate();
 if (Fl::ready()) {
   do_expensive_cleanup();
   Fl::check();
   if (user_hit_abort_button()) break;
 }
}</pre></ul>

<h3><A name=redraw>void Fl::redraw()</A></h3>

Redraws all widgets. 

<h3><A name=has_idle>static int Fl::has_idle(void (*cb)(void*), void* = 0)</A></h3>

Returns true if the specified idle callback is currently installed.

<h3><A name=remove_idle>static void Fl::remove_idle(void (*cb)(void*), void* = 0)</A></h3>

Removes the specified idle callback, if it is installed.

<h3><A name=has_timeout>static int Fl::has_timeout(void (*cb)(void*), void* = 0)</A></h3>

Returns true if the timeout exists and has not been called yet.

<h3><A name=remove_timeout>static void Fl::remove_timeout(void (*cb)(void*), void* = 0)</A></h3>

Removes a timeout callback. It is harmless to remove a timeout
callback that no longer exists.

<h3><A name=has_check>static int Fl::has_check(void (*cb)(void*), void* = 0)</A></h3>

Returns true if the check exists and has not been called yet.

<h3><A name=remove_check>static void Fl::remove_check(void (*cb)(void*), void* = 0)</A></h3>

Removes a check callback. It is harmless to remove a check
callback that no longer exists.

<h3><A name=run>static Fl::run()</A></h3>

Calls <a href=#wait><tt>Fl::wait()</tt></a> in an infinite loop. The only
way out is for a callback to call <tt>exit()</tt> or <tt>abort()</tt>.
A normal program will end <tt>main()</tt> with <tt>return
Fl::run();</tt>.

<h3><A name=copy>void Fl::copy(const char *stuff, int len)
<br>const char* Fl::selection()
<br>int Fl::selection_length()</a></h3>

The first form changes the current selection.  The block of text is 
copied to an internal buffer by FLTK (be careful if doing this in 
response to an <tt>FL_PASTE</tt> as this <I>may</I> be the same buffer 
returned by <tt>event_text()</tt>). The second form looks 
at the buffer containing the current selection.  The contents of this 
buffer are undefined if this program does not own the current 
selection. 

<p><I>Copying the buffer every time the selection is changed is 
obviously wasteful, especially for large selections.  An interface will 
probably be added in a future version to allow the selection to be made 
by a callback function.  The current interface will be emulated on top 
of this.</I></p>

<h3><A name=test_shortcut>int Fl::test_shortcut(int shortcut)</A></h3>

Test the current event, which must be an <tt>FL_KEYBOARD</tt> or <tt>
FL_SHORTCUT</tt>, against a shortcut value (described in <A
href=Fl_Button.html#shortcut><tt>Fl_Button</tt></A>).
Returns non-zero if there is a match.  Not to be confused with <A
href=Fl_Widget.html#test_shortcut><tt>Fl_Widget::test_shortcut()</tt></A>.

<h3><A name=key_name>const char* Fl::key_name(int shortcut)</a></h3>

Unparse a key name (as returned by <a
href=#event_key><tt>Fl::event_key()</tt></a>) or a shortcut value (as
used by <A href=Fl_Button.html#shortcut>
<TT>Fl_Button</TT></A> or <A href=Fl_Menu_Item.html#Fl_Menu_Item><TT>
Fl_Menu_Item</TT></A>) into a human-readable string like "Alt+N".  If
the shortcut is zero an empty string is returned. <i>The return value
points at a static buffer that is overwritten with each call.</i>

<h3><A name=visual>int Fl::visual(int)</A></h3>

Selects a visual so that your graphics are drawn correctly.  This is
only allowed before you call show() on any windows.  This does nothing
if the default visual satisfies the capabilities, or if no visual
satisfies the capabilities, or on systems that don't have such
brain-dead notions.

<p>Only the following combinations do anything useful:</p>

<UL>
<LI><tt>Fl::visual(FL_RGB)</tt>
<BR>Full/true color (if there are several depths FLTK chooses  the 
largest).  Do this if you use <A href=#fl_draw_image><tt>fl_draw_image</tt>
</A> for much better (non-dithered)  output. 
<BR>&nbsp;</LI>
<LI><tt>Fl::visual(FL_RGB8)</tt>
<BR>Full color with at least 24 bits of color. <tt>FL_RGB</tt> will 
always  pick this if available, but if not it will happily return a 
 less-than-24 bit deep visual.  This call fails if 24 bits are not 
 available. 
<BR>&nbsp;</LI>
<LI><tt>Fl::visual(FL_DOUBLE|FL_INDEX)</tt>
<BR>Hardware double buffering.  Call this if you are going to use <A href=Fl_Double_Window.html#Fl_Double_Window>
<tt>Fl_Double_Window</tt></A>. 
<BR>&nbsp;</LI>
<LI><tt>Fl::visual(FL_DOUBLE|FL_RGB)</tt></LI>
<LI><tt>Fl::visual(FL_DOUBLE|FL_RGB8)</tt>
<BR>Hardware double buffering and full color. 
<BR>&nbsp;</LI>
</UL>

This returns true if the system has the capabilities by default or 
FLTK suceeded in turing them on.  Your program will still work even if 
this returns false (it just won't look as good). 

<h3><A name=w>int Fl::w()</A></h3>

Returns the width of the screen in pixels. 

<h3><A name=wait>static int Fl::wait()</a></h3>

Same as <tt>Fl::wait(infinity)</tt>.  Call this repeatedly to "run"
your program.  You can also check what happened each time after this
returns, which is quite useful for managing program state.

<h3>static int Fl::wait(double time)</h3>

Waits until "something happens", or the given time interval passes.
<i>It can return much sooner than the time if something happens.</i>

<P>What this really does is call all idle callbacks, all elapsed
timeouts, call <tt>Fl::flush()</tt> to get the screen to update, and
then wait some time (zero if there are idle callbacks, the shortest of
all pending timeouts, or the given time), for any events from the user
or any <tt>Fl::add_fd()</tt> callbacks.  It then handles the events
and calls the callbacks and then returns.

<P>The return value is non-zero if there are any visible windows (this
may change in future versions of fltk).

<P>The return value is whatever the select() system call returned.
This will be negative if there was an error (this will happen on Unix
if a signal happens), zero if the timeout occurred, and positive if
any events or fd's came in.

<p>On Win32 the return value is zero if nothing happened and
<i>time</i> is 0.0.  Otherwise 1 is returned.

<h3><A name=warning>void (*Fl::warning)(const char *, ...)</A>
<BR><A name=error>void (*Fl::error)(const char *, ...)</A>
<BR><A name=fatal>void (*Fl::fatal)(const char *, ...)</A></h3>

FLTK will call these to print messages when unexpected conditions 
occur.  By default they <tt>fprintf</tt> to <tt>stderr</tt>, and <tt>
Fl::error</tt> and <tt>Fl::fatal</tt> call <tt>exit(1)</tt>.  You can 
override the behavior by setting the function pointers to your own 
routines. 

<p><tt>Fl::warning</tt> means that there was a recoverable problem, the 
display may be messed up but the user can probably keep working (all X 
protocol errors call this). <tt>Fl::error</tt> means there is a 
recoverable error, but the display is so messed up it is unlikely the 
user can continue (very little calls this now). <tt>Fl::fatal</tt> must 
not return, as FLTK is in an unusable state, however your version may 
be able to use <tt>longjmp</tt> or an exception to continue, as long as 
it does not call FLTK again.</p>

</BODY></HTML>
