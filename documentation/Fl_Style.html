<head><title>Fl_Style</title></head><body bgcolor=white>

<h2>struct Fl_Style</h2>

<p>Each widget has a pointer to an instance of Fl_Style.  Usually many
widgets share pointers to the same Fl_Style.  All the Fl_Styles are
linked into a hierarchy of parents & child styles, so that it is
possible to change an item in a parent style and propagate all the
changes to the children.

<p>When a widget looks up a value from a style, it looks at that style
and each parent up until it finds a non-zero value to return, or until
there are no more parents, in which case zero is used.  Thus changing
a parent style can make global changes as long as widgets do not have
local values set.

<p>In normal usage "set" methods like Fl_Widget::box(n) will create a
"unique" style for that widget, which is a child of the original
style, and set the box in that style.  This "unique" style is reused
for any other changes to that widget and it is deleted when the widget
is deleted.

<h3>Member variables</h3>

<h4><a href=Fl_Boxtype.html>Fl_Boxtype</a> box;</h4>

The type of box to draw around the outer edge of the widget (for the
majority of widgets, some classes ignore this or use it to draw only
text fields inside the widget). The default is <code>FL_DOWN_BOX</code>.

<h4><a href=Fl_Boxtype.html>Fl_Boxtype</a> button_box;</h4>

The type of box to draw buttons internal the widget (notice that <a
href="Fl_Button.html">Fl_Button</a> uses <tt>box</tt>, however). The
default is <code>FL_UP_BOX</code>.

<h4>void (*glyph)(int type, int x,int y,int w,int h, <a
href=Fl_Color.html>Fl_Color</a> bg, Fl_Color fg, Fl_Flags, Fl_Boxtype);</h4>

Draw a widget part, called a "glyph", such as a checkbox or arrow
button.  You should use the <code>FL_VALUE</code> of the flags to
determine if the glyph is pushed in or turned on.  If you write your
own function call the default of fl_glyph() for any symbols you don't
recognize.  Currently defined glyphs:

<p><ul>

<li>Zero is reserved to draw an empty box

<li><code>FL_GLYPH_CHECK</code> - draw a checkbox indicator

<li><code>FL_GLYPH_RADIO</code> - draw a radio button indicator

<li><code>FL_GLYPH_UP</code> - draw an up arrow at the top of a scrollbar

<li><code>FL_GLYPH_DOWN</code> - draw a down arrow at the botom of a scrollbar

<li><code>FL_GLYPH_LEFT</code> - draw a left arrow at the left of a scrollbar

<li><code>FL_GLYPH_RIGHT</code> - draw a right arrow at the right of a
scrollbar

<li><code>FL_GLYPH_VSLIDER</code> - draw a vertical slider/scrollbar handle

<li><code>FL_GLYPH_HSLIDER</code> - draw a horizontal slider/scrollbar handle

<li>All other values draw an empty box.

</ul>

<p>These glyphs all have values starting at 100 or more.  Many widget
subclasses define a private glyph function to draw parts of
themselves, using local glyphs whose values start at 1.  A "theme"
may want to replace these functions, you should examine the fltk
source code to find out what the codes for the glyphs are.

<h4><a href=Fl_Font.html>Fl_Font</a> label_font;</h4>

The font used to draw the label.  Default is <code>FL_HELVETICA</code>.

<h4>unsigned int label_size;</h4>

Size of <code>label_font</code>.  Default is 12.

<h4><a href=Fl_Font.html>Fl_Font</a> text_font;</h4>

Provides a font for text displays.  Default is <code>FL_HELVETICA</code>.

<h4>unsigned int text_size;</h4>

Size of <code>text_font</code>.  Default is 12.

<h4>unsigned int leading;</h4>

Extra spacing added between text lines or other things that are
stacked vertically.  The default is 2.

<h4><a href=Fl_Labeltype.html>Fl_Labeltype</a> label_type;</h4>

How to draw the label.  This provides things like inset, shadow, and
the symbols.  <code>FL_NORMAL_LABEL</code>.

<h4><a href=Fl_Color.html>Fl_Color</a> color;</h4>

Color passed to <code>box</code>.  Default is <code>FL_GRAY</code>.
If you wish to change the general color of fltk you probably want to
call <a href=#fl_background><code>fl_background(color)</code></a>
instead, as this will set the entry for <code>FL_GRAY</code> and also
set the "gray ramp" so that the edges of buttons are the same color.

<h4><a href=Fl_Color.html>Fl_Color</a> label_color;</h4>

Color used to draw labels and glyphs.  Default
<code>FL_NO_COLOR</code>.

<h4><a href=Fl_Color.html>Fl_Color</a> highlight_color;</h4>

The color to draw the widget when the mouse is over it (for scrollbars
and sliders this is used to color the moving parts).  The default of
zero disables highlighting.

<h4><a href=Fl_Color.html>Fl_Color</a> highlight_label_color;</h4>

Color to draw labels atop the <code>highlight_color</code>.  The
default of zero leaves the <code>label_color</code> unchanged.

<h4><a href=Fl_Color.html>Fl_Color</a> button_color;</h4>

Color used when drawing internal buttons. Default is <code>FL_GRAY</code>.

<h4><a href=Fl_Color.html>Fl_Color</a> text_color;</h4>

Color to draw text inside the widget.  Default is black.

<h4><a href=Fl_Color.html>Fl_Color</a> selection_color;</h4>

Color drawn behind selected text or browser or menu items.  The
default is Windows 95 blue.

<p>Check buttons, radio buttons, menu items, and light buttons use
this to color in the glyph that indicates check/radio state when the
button is turned on (<code>button_color</code> is used for the check
marks when they are off).

<h4><a href=Fl_Color.html>Fl_Color</a> selection_text_color;</h4>

The color to draw text atop the <code>selection_color</code>.  The
default is <code>FL_WHITE</code>.

<h2>class Fl_Named_Style</h2>

<h4><code>Fl_Named_Style(const char* name, void (*revert)(Fl_Style*), Fl_Style** pointer);</code></h4>

If you define your own widget class you may want to allow text-based
theme systems (such as fltk's built-in "conf" file reader) to modify
your widget's style. To do this it must be provided with a name and a
method to restore the style to it's default.

<p><i>name</i> is the name you want themes to use to look up the
style. If you don't care if the themes can see your widget class you
can just use null for the name (you must still provide the <i>pointer</i>, as
multiple themes have to be able make duplicates of your style with
different "parent" pointers).

<p><i>revert</i> is a function that initializes the style to it's
default value. The style is cleared to zero (meaning inherit from the
default style) before revert is called. If revert is NULL then
all-zeros is the default.

<p><i>pointer</i> is a pointer to the pointer to the
style. This allows multiple themes to exist at once, because instead
of the theme changing any already-used styles, it replaces the pointer
with a new style. This can be used by programs that let the user
design or test themes. If you don't plan to use your widget in such a
program you can make a static instance of your style (rather than
using new) and pass null as this pointer.

<p>Here is an example of a class that wants the box to default to
FL_ROUND_BOX:

<ul><pre><code>static void revert(Fl_Style* s) {
  s->box = FL_ROUND_BOX;
}
static Fl_Named_Style* style = new Fl_Named_Style("MyWidget", revert, &style);

MyWidget::MyWidget(int x, int y, int w, int h, const char *l)
  : Fl_Widget(x,y,w,h,l)
{
  style(::style);
}</code></pre></ul>

<h3>Setting a Theme</h3>

To implement "themes" the theme code needs to write a number of static
locations, primarily the default style of several classes.  If you
change the theme after windows are displayed, use Fl::redraw() to
cause everything to redraw.

<p>You ususally only need to change a few styles to implement a
theme.  All widgets inherit from the default style anything that they
don't set themselves.

<h4><code>Fl_Named_Style* Fl_Style::find(const char* name);</code></h4>

<p>To locate a style to modify by name, use this static Fl_Style
method.  By using this function for anything other than default_style
it allows you to test if a style is actually linked into the program,
so that you can make a theme plugin that changes any style.

<p>Case is ignored and spaces and underscores are considered equivalent.

<h4>Fl_Widget::default_style</h4>

Provides all the defaults described above.  This is the only style
that does not have a parent.  Highlighting is disabled by default, to
turn it on you should set highlight color.

<h4>Fl_Style::find("input")</h4>

This style is used by Fl_Input, but a few other widgets directly refer
to it to draw imbedded text editing fields.

<h4>Fl_Style::find("output")</h4>

This style is used by Fl_Output, but a few other widgets directly
refer to it to draw imbedded display fields.  Setting the color to
gray will simulate NeXTStep or other user interfaces where
interactivity is indicated by color.

<h4>Fl_Style::find("Check_Button")</h4>

Styles usually need to mess with the window color and glyph function
here to get check marks correct.

<h4>Fl_Style::find("menu")</h4>

This style is used for the pop-up menu windows.
<code>button_box</code> is drawn around each item, and
<code>selection_color</code> is used to color the current one.

<h4>Fl_Style::find("item")</h4>

Menu items.  If you use checkmarks in menus you will have to make
similar fixes to this as to check_button.  Notice that the box drawn
around each item is chosen by "menu", not by this.

<h4>Fl_Style::find("menu_title")</h4>

How to draw the titles in menu bars.  The <code>box</code> is drawn
around each of them.

<h4>Fl_Style::find("Scrollbar")</h4>

Styles usually need to mess with the window color and glyph function
to get these to appear correctly.

<h4>Fl_Tooltip::default_style</h4>

The box and color of this controls the appearance of the tooltips.
This is always linked in, so you don't need find().  Tooltips also
have some other static fields to set the timeout and position, see the
Fl_Tooltip documentation.

<a name=fl_background>
<h4>void fl_background(<a href=Fl_Color.html>Fl_Color</a>)</h4>

This global function changes the "gray ramp" in the fltk color map so
that the color <code>FL_GRAY</code> is set the the rgb values of the
passed color.  This is the best way to change the overall color of
your application, because it sets all the shaded borders.

</body></html>

