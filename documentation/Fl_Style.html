<head><title>Fl_Style</title></head><body bgcolor=white>

<h2>struct Fl_Style</h2>

<p>Each widget has a pointer to an instance of Fl_Style.  Usually many
widgets share pointers to the same Fl_Style.  All the Fl_Styles are
linked into a hierarchy of parents & child styles, so that it is
possible to change an item in a parent style and propagate all the
changes to the children.

<p>When a widget looks up a value from a style, it looks at that style
and each parent up until it finds a non-zero value to return, or until
there are no more parents, in which case zero is used.  Thus changing
a parent style can make global changes as long as widgets do not have
local values set.

<p>In normal usage "set" methods like Fl_Widget::box(n) will create a
"unique" style for that widget, which is a child of the original
style, and set the box in that style.  This "unique" style is reused
for any other changes to that widget and it is deleted when the widget
is deleted.

<h3>Member variables</h3>

<h4><a href=Fl_Boxtype.html>Fl_Boxtype</a> box;</h4>

The type of box to draw around the outer edge of the widget (for the
majority of widgets, some classes ignore this or use it to draw only
text fields inside the widget). The default is <code>FL_DOWN_BOX</code>.

<h4><a href=Fl_Boxtype.html>Fl_Boxtype</a> button_box;</h4>

The type of box to draw buttons internal the widget (notice that <a
href="Fl_Button.html">Fl_Button</a> uses <tt>box</tt>, however). The
default is <code>FL_UP_BOX</code>.

<h4>void (*glyph)(const <a href="Fl_Widget.html">Fl_Widget</a>*, int glyph, int x, int y, int w, int h, Fl_Flags);</h4>

Draw part of a widget, called a "glyph". Examples are the up and down
arrows on sliders, the slider itself, and check boxes. The base class
draws arrow buttons (because they are so commonly used), but most
widgets that use this define their own function to call. A theme can
make these functions point at it's own code and thus customize the
appearance of widgets quite a bit.

<p>The default glyph function can draw these values for <i>glyph</i>:

<p><ul>

<li>Zero is reserved to draw an empty box
<li><code>FL_GLYPH_UP</code> - draw an up arrow
<li><code>FL_GLYPH_UP_BUTTON</code> - draw an up arrow in a box
<li><code>FL_GLYPH_DOWN</code> - draw a down arrow
<li><code>FL_GLYPH_DOWN_BUTTON</code> - draw a down arrow in a box
<li><code>FL_GLYPH_LEFT</code> - draw a left arrow
<li><code>FL_GLYPH_LEFT_BUTTON</code> - draw a left arrow in a box
<li><code>FL_GLYPH_RIGHT</code> - draw a right arrow
<li><code>FL_GLYPH_RIGHT_BUTTON</code> - draw a right arrow in a box
scrollbar
<li>All other values draw an empty box.

</ul>

<p>If you wish to write your own glyph function you should examine the
ones in the fltk source code and in the sample theme plugins to see
how the arguments are interpreted.

<h4><a href=Fl_Font.html>Fl_Font</a> label_font;</h4>

The font used to draw the label.  Default is <code>FL_HELVETICA</code>.

<h4>unsigned int label_size;</h4>

Size of <code>label_font</code>.  Default is 12.

<h4><a href=Fl_Font.html>Fl_Font</a> text_font;</h4>

Provides a font for text displays.  Default is <code>FL_HELVETICA</code>.

<h4>unsigned int text_size;</h4>

Size of <code>text_font</code>.  Checkboxes and some other widgets use
this to control the size of the glyph. Default is 12.

<h4>unsigned int leading;</h4>

Extra spacing added between text lines or other things that are
stacked vertically.  The default is 0 (menus have a default of 4).

<h4><a href=Fl_Labeltype.html>Fl_Labeltype</a> label_type;</h4>

How to draw the label.  This provides things like inset, shadow, and
the symbols.  <code>FL_NORMAL_LABEL</code>.

<h4><a href=Fl_Color.html>Fl_Color</a> color;</h4>

Color of the widgets. The default is <code>FL_WHITE</code>. This color
is inherited by text displays and browsers, most of the "gray" you see
is due to widgets like Fl_Group that default the color to gray, and
the fact that many parts of the interface are drawn with the
button_color described below.

<p>If you want to change the overall color of all the gray parts of
the interface you want to call <a
href=Fl_Color#fl_background><code>fl_background(color)</code></a>
instead, as this will set the entry for <code>FL_GRAY</code> and also
set the "gray ramp" so that the edges of buttons are the same color.

<h4><a href=Fl_Color.html>Fl_Color</a> label_color;</h4>

Color used to draw labels and glyphs.  Default
<code>FL_NO_COLOR</code>.

<h4><a href=Fl_Color.html>Fl_Color</a> highlight_color;</h4>

The color to draw the widget when the mouse is over it (for scrollbars
and sliders this is used to color the buttons).  The default of
zero disables highlighting.

<h4><a href=Fl_Color.html>Fl_Color</a> highlight_label_color;</h4>

Color to draw labels atop the <code>highlight_color</code>.  The
default of zero leaves the <code>label_color</code> unchanged.

<h4><a href=Fl_Color.html>Fl_Color</a> button_color;</h4>

Color used when drawing internal buttons. Default is <code>FL_GRAY</code>.
Check and radio buttons use this to color in the glyph.

<h4><a href=Fl_Color.html>Fl_Color</a> text_color;</h4>

Color to draw text inside the widget.  Default is black. Check and
radio buttons use this to control the color of the checkmark.

<h4><a href=Fl_Color.html>Fl_Color</a> selection_color;</h4>

Color drawn behind selected text in inputs, or selected browser or
menu items, or lit light buttons.  The default is Windows 95 blue.

<h4><a href=Fl_Color.html>Fl_Color</a> selection_text_color;</h4>

The color to draw text atop the <code>selection_color</code>.  The
default is <code>FL_WHITE</code>.

<h4>Fl_Named_Style* Fl_Style::find(const char* name);</h4>

<p>This is a <i>static</i> method on Fl_Style. It returns the first
style found that matches the name.  Case is ignored and spaces and
underscores are considered equivalent. If nothing matches
<tt>NULL</tt> is returned.

<p>Theme-setting code uses this to locate the styles it has to
modify. Using a string to locate the styles serves several
purposes:

<ul>

<li>It allows a theme plugin to locate and modify styles that are in
your program as well as in the fltk library.

<li>It allows a theme plugin to read a text database and not have to
implement a translation from names to styles.

<li>If you static-link your fltk program and include a theme function,
it won't link in all the classes that you are not using but it tries
to modify.

<li>On machines that allow a plugin to be loaded into a static-linked
program (some Unix systems, Linux if you use -shared) it means the
plugin can work even if it wants to modify some fltk classes that were
not linked in.

</ul>

<h2>class Fl_Named_Style</h2>

<h4>Fl_Named_Style(const char* name, void (*revert)(Fl_Style*), Fl_Style** pointer);</h4>

This subclass creates a style that can be returned by <a
href="#find">Fl_Style::find()</a>. It also provides a "revert" method
that is used to restore the initial state so that themes can be switched.

<p><i>name</i> is the name you want themes to use to look up the
style. If you don't care if themes can modify your class you can just
use <tt>NULL</tt> for the name.

<p><i>revert</i> is a function that initializes the style to it's
default value. The style is cleared to zero (meaning inherit from the
default style) before revert is called. If revert is NULL then
all-zeros is the default.

<p><i>pointer</i> is a back-pointer to the pointer to the
style. This allows multiple themes to exist at once, if an application
wants it (for instance a theme-editor application would like
this). The application can change this pointer to point at different
style structures and then all widgets that are constructed after that
get the new style. If you don't plan to use your widget in such a
program you can make a static instance of your style (rather than
using new) and pass null as this pointer.

<p>Here is an example of a class that wants the box to default to
FL_ROUND_BOX:

<ul><pre><code>static void revert(Fl_Style* s) {
  s->box = FL_ROUND_BOX;
}
static Fl_Named_Style* style = new Fl_Named_Style("MyWidget", revert, &style);

MyWidget::MyWidget(int x, int y, int w, int h, const char *l)
  : Fl_Widget(x,y,w,h,l)
{
  style(::style);
}</code></pre></ul>

<h2>Themes</h2>

Just before the first window is shown, fltk calls the "theme"
function, which is used to initialize the styles to the user's and
programmer's preferences.

<p>There are several ways to change the "theme" function:

<p>If fltk is dynamically linked (or statically linked on some Unix
systems, including Linux if -shared was given to the linker) a "theme
plugin" can be loaded. This is a plugin that defines a function called
fltk_theme(). If nothing is done fltk will automatically look for a
plugin in <tt>~/.fltk/default.theme</tt> and
<tt>/usr/local/lib/fltk/default.theme</tt> (<tt>%SystemDrive%</tt> is
added on Windows).

<p>If fltk is statically linked (or in all cases on some Unix systems
such as Irix), your program can replace fltk_theme with it's own
definition by linking a object file that defines fltk_theme().

<p>You can call Fl_Style::theme(function) to set the function
directly.

<p>If fltk is dynamically linked and <a
href="Fl.html@args">Fl::args()</a> is used, the theme may be loaded by
name by the -theme switch. This calls
Fl_Style::theme(Fl_Style::load_theme(name)).

<p>Theme functions are actually of the form
<tt>extern&nbsp;"C"&nbsp;bool&nbsp;fltk_theme()</tt> (future versions
of fltk are likely to add arguments to provide the plugin filename to
this function prototype). A typedef of <tt>Fl_Theme</tt> is
provided. They are expected to return true on success and false if
there is any problem (currently fltk ignores this return value), and
should print to stderr or call Fl::warning() with any explanation of
problems.

<a name=theme><h4>static Fl_Theme Fl_Style::theme();
<br>static void theme(Fl_Theme f);</h4></a>

Get or set the function that will be called when the theme is loaded.

<a name=scheme><h4>static const char* Fl_Style::scheme();
<br>static void Fl_Style::scheme(const char* f);</h4></a>

Fltk also keeps track of a single string pointer that can be used as
an "argument" to the theme function, perhaps to identify a file it
should read. The default value is null. If you use <a
href="Fl.html@args">Fl::args()</a> then the "-scheme" switch sets
this.

<a name=load_theme><h4>static Fl_Theme Fl_Style::load_theme(const char* name);</h4></a>

Locate a theme plugin by name, load it into memory, and return the
fltk_theme() function. Returns null if the plugin is not found or
there is a problem loading it or locating the fltk_theme() function,
and prints information about what went wrong to stderr.

<p>".theme" is added to the end of the name if not already there and
<a href=#fl_find_config_file>fl_find_config_file()</a> is called to
locate the plugin (this means you can provide a full pathname for the
plugin). If the plugin is found it is loaded with <a
href=#fl_load_plugin>fl_load_plugin()</a>.

<p>If the name is null, the empty string, or if it "default" and there
is no plugin named "default", then the built-in fltk_theme() function
is returned. This built-in calls <a
href=#fl_get_system_colors>fl_get_system_colors()</a>.

<p>If fltk is statically linked then null, the empty string, and
"default" return the built-in fltk_theme(), otherwise an error is
printed and null is returned.

<a name=load_theme2><h4>static void Fl_Style::load_theme();</h4></a>

If this <i>has not</i> been called before, it loads the current theme
by running the Fl_Style::theme() function. If that has not been set it
sets it to <a href=#load_theme>Fl_Style::load_theme("default")</a>.
Progams can call this before showing the first window to force the
theme to be loaded, otherwise fltk waits until the first window is
shown to call this.

<a name=reload_theme><h4>static void Fl_Style::reload_theme();</h4></a>

If <a href=#load_theme2>Fl_Style::load_theme(void)</a> <i>has</i> been
called before, this calls <a href=#revert>Fl_Style::revert()</a> and
then re-runs the theme function. This will allow the theme to respond
to changes in any system configuration or files. This does nothing if
themes have not been started yet to avoid wasting time before it matters.

<p>On Windows this is automatically called in response to a
<tt>WM_SYSCOLORCHANGE</tt>. On X the theme itself needs to set up some
event handler to call this, see the KDE theme source code for an example.

<p>A program should call this if it changes the <a
href=#theme>Fl_Style::theme()</a> or <a
href=#scheme>Fl_Style::scheme()</a>.

<a name=revert><h4>static void Fl_Style::revert();</h4></a>

Return all the styles to their default settings (by calling the
revert() function on each of them) and also undo some global settings
such as <a href=Fl_Color.html#fl_background>fl_background</a>. This is
done by <a href=#reload_theme>reload_theme()</a> before loading the
theme again.

<h3>Setting a Theme</h3>

To implement "themes" the theme code needs to write a number of static
locations, primarily the default style of several classes. You
ususally only need to change a few styles to implement a theme.  All
widgets inherit from the default style anything that they don't set
themselves.

<p>The following functions are useful when writing a theme.

<a name=fl_get_system_colors><h4>bool fl_get_system_colors();</h4></a>

Read system configuration (GetSysColor() and similar functions on
Win32, on X it reads a <i>few</i> entries from the xrdb database) and
retrieve information such as colors and fonts and put them into the
styles. This is what the default theme does, many other themes will
find this useful.

<a name=fl_find_config_file><h4>const char* fl_find_config_file(char* out, int size, const char* name);</h4></a>

Search for a file in fltk's configuration directories, and return the
found filename. If necessary the <i>out</i> buffer is used to printf
the filename and a pointer to that is returned, <i>size</i> is the
length of this buffer. Returns null if the filename is not found.

<p>If the name starts with '/' or '.' (or on Windows if it starts with
'\\' or the second character is a ':') then it is returned unchanged
(note that this does not check for existence of the file).

<p>Otherwise the following locations are searched in order and the
first one found is returned:

<ul>

<li><tt>~/.fltk/</tt><i>name</i></li>

<li><tt>%HOMEPATH%/fltk/</tt><i>name</i></li> (Windows only)

<li><tt>%USERPROFILE%/fltk/</tt><i>name</i></li> (Windows only)

<li><tt>/usr/local/lib/fltk/</tt><i>name</i></li> (this may be changed
by a configuration option when fltk is compiled)

</ul>

<h4>Fl_Widget::default_style</h4>

Provides all the defaults described above.  This is the only style
that does not have a parent.  Highlighting is disabled by default, to
turn it on you should set highlight color.

<h4>Fl_Style::find("input")</h4>

This style is used by Fl_Input, but a few other widgets directly refer
to it to draw imbedded text editing fields.

<h4>Fl_Style::find("output")</h4>

This style is used by Fl_Output, but a few other widgets directly
refer to it to draw imbedded display fields.  Setting the color to
gray will simulate NeXTStep or other user interfaces where
interactivity is indicated by color.

<h4>Fl_Style::find("Check_Button")</h4>

Styles usually need to mess with the button_color and glyph function
here to get check marks correct.

<h4>Fl_Style::find("menu")</h4>

This style is used for the pop-up menu windows.
<code>button_box</code> is drawn around each item, and
<code>selection_color</code> is used to color the current one.

<h4>Fl_Style::find("item")</h4>

Menu items.  If you use checkmarks in menus you will have to make
similar fixes to this as to check_button.  Notice that the box drawn
around each item is chosen by "menu", not by this.

<h4>Fl_Style::find("Scrollbar")</h4>

Styles usually need to mess with the box, button_box, button_color,
and glyph function to get these to appear correctly.

<h4>Fl_Tooltip::default_style</h4>

The box and color of this controls the appearance of the tooltips.
This is always linked in, so you don't need find().  Tooltips also
have some other static fields to set the timeout and position, see the
<a href="Fl_Tooltip.html">Fl_Tooltip</a> documentation.

<h2>class Fl_Style_Set</h2>

Fltk can manage "sets" of styles. This is useful for making a program
that compares or edits themes, so that the "test" widgets can have a
different theme than the main ones.  The "set" the widget belongs to
is assigned when the widget is constructed.

<p>The actual implementation is to change the pointers such as
Fl_Widget::default_style for every widget class to point to a new
copy, so when the constructors for each widget are run they assign the
new copy. The previous copies are saved and restored if the older set
name is used.

<p>There are some problems. Many widgets are dynamically created (for
instance pop-up menus) and may not inherit the expected theme unless
you are careful. Also some global things such as the background color
cannot be seperated into sets.

<a name=Fl_Style_Set><h4>Fl_Style_Set::Fl_Style_Set()</h4></a>

The <i>first</i> Fl_Style_Set you create is made into the current one
and is made equal to the current settings of the styles. All other
style sets you create are set to a <a href=#revert>revert</a> form of
all the styles and  you must call <a
href=#make_current>make_current</a> on them to make them useful.

<a name=~Fl_Style_Set><h4>Fl_Style_Set::~Fl_Style_Set()</h4></a>

Currently this does nothing.

<a name=make_current><h4>void Fl_Style_Set::make_current();</h4></a>

<p>Make this set be current. All widgets created after this use this
set, and calling <a href=#reload_theme>Fl_Style::reload_theme()</a>
will change the styles belonging to tis set.

</body></html>

