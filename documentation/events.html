<html><head><title>FLTK Events</title></head><body bgcolor = white>

<h1 align=right><a name=events>E - Handling Events</a></h1>

FLTK Events are identified by the integer argument passed to the <A
href="subclassing.html#handle"><tt>Fl_Widget::handle()</tt></A> virtual
method.

<p>All other information about the most recent event is stored in
static locations and acquired by calling these functions.  This static
information remains valid until the next event is read from window
system (i.e. it is ok to look at it outside of the <tt>handle()</tt>
method). This allows the data to be accessed by callbacks and other
functions without having to pass an event argument to them, and allows
more fields to be added to events without breaking binary compatability.
These are all trivial inline functions and thus very fast and small:

<UL>
<LI><A href=functions.html#event><tt>Fl::event</tt></A></LI>
<LI><A href=functions.html#event_button><tt>Fl::event_button</tt></A></LI>
<LI><A href=functions.html#event_clicks><tt>Fl::event_clicks</tt></A></LI>
<LI><A href=functions.html#event_inside><tt>Fl::event_inside</tt></A></LI>
<LI><A href=functions.html#event_is_click><tt>Fl::event_is_click</tt></A></LI>
<LI><A href=functions.html#event_key><tt>Fl::event_key</tt></A></LI>
<LI><A href=functions.html#event_length><tt>Fl::event_length</tt></A></LI>
<LI><A href=functions.html#event_state><tt>Fl::event_state</tt></A></LI>
<LI><A href=functions.html#event_text><tt>Fl::event_text</tt></A></LI>
<LI><A href=functions.html#event_x><tt>Fl::event_x</tt></A></LI>
<LI><A href=functions.html#event_x_root><tt>Fl::event_x_root</tt></A></LI>
<LI><A href=functions.html#event_dx><tt>Fl::event_dx</tt></A></LI>
<LI><A href=functions.html#event_y><tt>Fl::event_y</tt></A></LI>
<LI><A href=functions.html#event_y_root><tt>Fl::event_y_root</tt></A></LI>
<LI><A href=functions.html#event_dy><tt>Fl::event_dy</tt></A></LI>
</UL>

<p>The following functions do not return current event state, but are
often used when processing events as well:

<ul>
<LI><A href=functions.html#get_key><tt>Fl::get_key</tt></A></LI>
<LI><A href=functions.html#get_mouse><tt>Fl::get_mouse</tt></A></LI>
<LI><A href=functions.html#test_shortcut><tt>Fl::test_shortcut</tt></A></LI>
</ul>

FLTK follows very simple and unchangeable rules for sending events.
The major innovation is that widgets can indicate (by returning 0 from
the <tt>handle()</tt> method) that they are not interested in an
event, and FLTK can then send that event elsewhere.  This eliminates
the need for "interests" (event masks or tables), and this is probably
the main reason FLTK is much smaller than other toolkits.

<p>Some events are sent directly to widgets by fltk, but others are
always sent to the outermost <tt>Fl_Window</tt> and fltk relies on the
widgets correctly sending the events on to their children. This is to
allow composite widgets to implement more efficient code for finding
the correct child than the simple linear search fltk uses. The
following functions control where events are sent:

<UL>
<LI><A href=functions.html#add_handler><tt>Fl::add_handler</tt></A></LI>
<LI><A href=functions.html#belowmouse><tt>Fl::belowmouse</tt></A></LI>
<LI><A href=functions.html#focus><tt>Fl::focus</tt></A></LI>
<LI><A href=functions.html#modal><tt>Fl::modal</tt></A></LI>
<LI><A href=functions.html#pushed><tt>Fl::pushed</tt></A></LI>
<LI><A href=Fl_Widget.html#take_focus><tt>Fl_Widget::take_focus</tt></A></LI>
</UL>

<p>This is a list of all the events currently defined.

<H2>Mouse Events</H2>

<a name="FL_PUSH"><H3>FL_PUSH</H3>

A mouse button has gone down with the mouse pointing at this widget.
You can find out what button by calling <A
href=fl_functions.html#event_button><tt>Fl::event_button()</tt></A>.
You find out the mouse position by calling <A
href=fl_functions.html#event_x><tt>Fl::event_x()</tt></A> and <A
href=functions.html#event_y><tt>Fl::event_y()</tt></A>.

<P>A widget indicates that it &quot;wants&quot; the mouse click by
returning non-zero from its <A
href=functions.html#handle><tt>handle()</tt></A> method. It will then
become the <A href=functions.html#pushed><tt> Fl::pushed()</tt></A>
widget and will get <tt>FL_DRAG</tt> and the matching
<tt>FL_RELEASE</tt> events.  If <tt>handle()</tt> returns zero then
FLTK will try sending the <tt>FL_PUSH</tt> to another widget. </P>

<a name="FL_DRAG"><H3>FL_DRAG</H3>

The mouse has moved with a button held down. The current button state
is in <a
href="functions.html#event_state"><tt>Fl::event_state()</tt></a>. The
mouse position is in <a
href="functions.html#event_x"><tt>Fl::event_x()</tt></a> and <a
href="functions.html#event_y"><tt>Fl::event_y()</tt></a>.

<P>To receive <tt>FL_DRAG</tt> events you must return 1 when passed a
<tt>FL_PUSH</tt> event.

<a name="FL_RELEASE"><H3>FL_RELEASE</H3>

A mouse button has been released.  You can find out what button by 
calling <A href="functions.html#event_button"><tt>Fl::event_button()</tt></A>. 

<P>To receive <tt>FL_RELEASE</tt> events you must return 1 when passed a
<tt>FL_PUSH</tt> event.

<a name="FL_MOVE"><H3>FL_MOVE</H3>

The mouse has moved without any mouse buttons held down.  This event
is sent to the <A
href="functions.html#belowmouse"><tt>Fl::belowmouse()</tt></A> widget.

<a name="FL_MOUSEWHEEL"><H3>FL_MOUSEWHEEL</H3>

The wheel was moved on the mouse. <a
href="functions.html#event_dy"><tt>Fl::event_dy()</tt></a> contains
how many clicks the wheel moved, positive for up and negative for
down.  There is also a <a
href="functions.html#event_dx"><tt>Fl::event_dx()</tt></a> for any
kind of horizontal scrolling device but nothing produces that yet.

<p>On X you may want to write stuff to the xrdb database to control
how fltk interprets the wheel. On Windows the normal Windows settings
are used for this.

<H2>Focus Events</H2>

<a name="FL_ENTER"><H3>FL_ENTER</H3>

The mouse has been moved to point at this widget.  This can be used
for highlighting feedback.  If a widget wants to highlight or
otherwise track the mouse, it indicates this by returning non-zero
from its <A href="functions.html#handle"> <tt>handle()</tt></A>
method. It then becomes the <A href="functions.html#belowmouse">
<tt>Fl::belowmouse()</tt></A> widget and will receive <tt>FL_MOVE</tt>
and <tt>FL_LEAVE</tt> events.

<a name="FL_LEAVE"><H3>FL_LEAVE</H3>

The mouse has moved out of the widget. To get this event you must
return 1 in response to a <tt>FL_ENTER</tt> event.

<H2>Keyboard Events</H2>

<a name="FL_FOCUS"><H3>FL_FOCUS</H3>

This indicates an <I>attempt</I> to give a widget the keyboard focus.
<P>If a widget wants the focus, it should change itself to display the
fact that it has the focus, and return non-zero from its <A
href=functions.html#handle> <tt>handle()</tt></A> method.  It then
becomes the <A href=functions.html#focus><tt>Fl::focus()</tt></A>
widget and gets <tt>FL_KEY</tt>, <tt>FL_KEYUP</tt> and <tt>FL_UNFOCUS</tt>
events.

<P>The focus will change either because the window manager changed
which window gets the focus, or because the user tried to navigate
using tab, arrows, or other keys.  You can check <A
href=functions.html#event_key> <tt>Fl::event_key()</tt></A> to figure
out why it moved.  For navigation it will be the key pressed and for
instructions from the window manager it will be zero.

<a name="FL_UNFOCUS"><H3>FL_UNFOCUS</H3>

Sent to the previous <A href=functions.html#focus><tt>Fl::focus()</tt></A>
widget when another widget gets the focus. 

<a name="FL_KEY"><H3>FL_KEY</H3>

A key press event. Fltk sends these directly to the
<A href=functions.html#focus><tt>Fl::focus()</tt></A> widget. If it
does not return 1 then fltk will change the event into a
<tt>FL_SHORTCUT</tt> event and try the widgets under the mouse.

<p>The key pressed can be found in <A
href=functions.html#event_key><tt>Fl::event_key()</tt></A>. The text
that the key should insert can be found with <A
href=functions.html#event_text><tt>Fl::event_text()</tt> </A> and its
length is in <A
href=functions.html#event_length><tt>Fl::event_length()</tt></A>.

<P>To receive <tt>FL_KEYBOARD</tt> events you must return 1 in
response to a <tt>FL_FOCUS</tt> event.

<a name="FL_KEYUP"><H3>FL_KEYUP</H3>

Sent to the <A href=functions.html#focus><tt>Fl::focus()</tt></A>
widget. The key that was released can be found in <A
href=functions.html#event_key><tt>Fl::event_key()</tt></A>. Don't rely
on anything being in <A
href=functions.html#event_text><tt>Fl::event_text()</tt></A>.

<a name="FL_SHORTCUT"><H3>FL_SHORTCUT</H3>

If the <A href=functions.html#focus><tt>Fl::focus()</tt></A> widget is
zero or ignores an <tt>FL_KEY</tt> event then FLTK tries sending this
event to every widget it can, until one of them returns
non-zero. <tt>FL_SHORTCUT</tt> is first sent to the
<tt>belowmouse()</tt> widget, then its parents and siblings, and
eventually to every widget in the window, trying to find an object
that returns non-zero.  FLTK tries really hard to not to ignore any
keystrokes!

<P>You can also make "global" shortcuts by using <A
href=functions.html#add_handler><tt>Fl::add_handler()</tt></A>.  A
global shortcut will work no matter what windows are displayed or
which one has the focus.

<H2>Widget Events</H2>

<a name="FL_DEACTIVATE"><H3>FL_DEACTIVATE</H3>

This widget is no longer active, due to <A
href=Fl_Widget.html#deactivate> <tt>deactivate()</tt></A> being called
on it or one of its parents. <tt> active()</tt> may still be true
after this, the widget is only active if <tt>active()</tt> is true on
it and all its parents (use <tt> active_r()</tt> to check this).

<a name="FL_ACTIVATE"><H3>FL_ACTIVATE</H3>

This widget is now active, due to <A href=Fl_Widget.html#activate>
<tt>activate()</tt></A> being called on it or one of its parents.

<a name="FL_HIDE"><H3>FL_HIDE</H3>

This widget is no longer visible, due to <A
href=Fl_Widget.html#hide><tt>hide()</tt></a> being called on it or one
of its parents, or due to a parent window being minimized.
<tt>visible()</tt> may still be true after this, but the widget is
visible only if <tt>visible()</tt> is true for it and all its parents
(use <tt>visible_r()</tt> to check this).

<a name="FL_SHOW"><h3>FL_SHOW</h3>

This widget is visible again, due to <a href=Fl_Widget.html#show>
<tt>show()</tt></A> being called on it or one of its parents, or due to 
a parent window being restored. <I>Child <tt>Fl_Window</tt>s respond to 
this by actually creating the window if not done already, so if you 
subclass a window, be sure to pass <tt>FL_SHOW</tt> to the base class <tt>
handle()</tt> method!</I>

<H2>Clipboard Events</H2>

<a name="FL_PASTE"><H3>FL_PASTE</H3>

You should get this event some time after you call <A
href=functions.html#paste><tt>Fl::paste()</tt></A> or you return true
for <tt>FL_DND_RELEASE</tt>.  The contents of
<A href=functions.html#event_text> <tt>Fl::event_text()</tt></A> is
the text to insert and the number of characters is in <A
href=functions.html#event_length><tt> Fl::event_length()</tt></A>.

<a name="FL_DND_ENTER"><H3>FL_DND_ENTER</h3>

The user is dragging something over your widget. Return 1 if you are
intersted in getting <tt>FL_DND_DRAG</tt> and <tt>FL_DND_RELEASE</tt>
events.

<a name="FL_DND_DRAG"><h3>FL_DND_DRAG</h3>

The user moved the mouse some more while dragging something. You might
use this to move around a cursor indicating where the insertion will go.

<a name="FL_DND_LEAVE"><h3>FL_DND_LEAVE</h3>

The user moved out of the widget without releasing the dragged object.

<a name="FL_DND_RELEASE"><h3>FL_DND_RELEASE</h3>

The user let go of the mouse and dropped something on your
widget. Return 1 if you are interested in getting this data. In this
case you will get an <tt>FL_PASTE</tt> event with the text of
object. This may be characters or it may be the URL of some larger
object.

<H2><A name=compose>FLTK Compose-Character Sequences</A></H2>

The foreign-letter compose processing done by the <A
href=Fl_Input.html#compose><tt>Fl_Input</tt></a> widget is provided in
a function that you can call if you are writing your own text editor
widget.

<p>Fltk uses it's own compose processing to allow "preview" of the
partially composed sequence, which is impossible with the usual
"dead key" processing.

<p>Although currently only characters in the ISO-8859-1 character set are
handled, you should call this in case any enhancements to the
processing are done in the future.  The interface has been designed to
handle arbitrary UTF-8 encoded text.

<h4><tt>int Fl::compose(int&amp; del)</tt></h4>

<p>Use of this function is very simple.  Any text editing widget should
call this for each <tt>FL_KEYBOARD</tt> event.

<p>If <tt>true</tt> is returned, then it has modified the <a
href=functions.html#event_text><tt>Fl::event_text()</tt></a> and <a
href=functions.html#event_length><tt>Fl::event_length()</tt></a> to a
set of <i>bytes</i> to insert (it may be of zero length!).  It will
also set the <i>del</i> parameter to the number of <i>bytes</i> to the
left of the cursor to delete, this is used to delete the results of
the previous call to Fl::compose().

<p>If <tt>false</tt> is returned, the keys should be treated as
function keys.  You could insert the text anyways, if you don't know
what else to do, <i>del</i> is set to zero and the <a
href=functions.html#event_text><tt>Fl::event_text()</tt></a> and <a
href=functions.html#event_length><tt>Fl::event_length()</tt></a> are
left unchanged, length is zero for any function keys.

<p>Though the current implementation returns immediately, future
versions may take quite awhile, as they may pop up a window or do
other user-interface things to allow characters to be selected.

<h4><tt>int Fl::compose_reset()</tt></h4>

<p>If the user moves the cursor, be sure to call Fl::compose_reset().
The next call to Fl::compose() will start out in an initial state.  In
particular it will not set "del" to non-zero.  This call is very fast
so it is ok to call it many times and in many places.

</body></html>
