<html>
<body>

<hr break>

<h2><a name="Fl_Input_">class Fl_Input_</a></h2>

<hr>

<h3>Class Hierarchy</h3>

<ul><pre>
<a href="#Fl_Widget">Fl_Widget</a>
   |
   +----<b>Fl_Input_</b>
           |
           +----<a href="#Fl_Input">Fl_Input</a>
</pre></ul>

<h3>Include Files</h3>

<ul><pre>
#include &lt;FL/Fl_Input_.H>
</pre></ul>

<h3>Description</h3>

This is a virtual base class below
<a href="#Fl_Input"><tt>Fl_Input</tt></a>. It has all the same interfaces,
but lacks the <tt>handle()</tt> and <tt>draw()</tt> method.  You may
want to subclass it if you are one of those people who likes to change
how the editing keys work.

<p>This can act like any of the subclasses of Fl_Input, by setting
<tt>type()</tt> to one of the following values:

<ul><pre>
#define FL_NORMAL_INPUT		0
#define FL_FLOAT_INPUT		1
#define FL_INT_INPUT		2
#define FL_MULTILINE_INPUT	4
#define FL_SECRET_INPUT		5
</pre></ul>

<h3>Methods</h3>

<center>
<table width=90%>
<tr>
<td align=left valign=top>
<ul>
	<li><a href="#Fl_Input_.Fl_Input_">Fl_Input_</a>
	<li><a href="#Fl_Input_.~Fl_Input_">~Fl_Input_</a>
	<li><a href="#Fl_Input_.copy">copy</a>
	<li><a href="#Fl_Input_.copy_cuts">copy_cuts</a>
</ul>
</td>
<td align=left valign=top>
<ul>
	<li><a href="#Fl_Input_.cut">cut</a>
	<li><a href="#Fl_Input_.drawtext">drawtext</a>
	<li><a href="#Fl_Input_.handletext">handletext</a>
</ul>
</td>
<td align=left valign=top>
<ul>
	<li><a href="#Fl_Input_.insert">insert</a>
	<li><a href="#Fl_Input_.lineboundary">lineboundary</a>
	<li><a href="#Fl_Input_.mark">mark</a>
</ul>
</td>
<td align=left valign=top>
<ul>
	<li><a href="#Fl_Input_.maybe_do_callback">maybe_do_callback</a>
	<li><a href="#Fl_Input_.position">position</a>
	<li><a href="#Fl_Input_.replace">replace</a>
</ul>
</td>
<td align=left valign=top>
<ul>
	<li><a href="#Fl_Input_.undo">undo</a>
	<li><a href="#Fl_Input_.up_down_position">up_down_position</a>
	<li><a href="#Fl_Input_.wordboundary">wordboundary</a>
</ul>
</td>
</tr>
</table>
</center>

<h4><a name="Fl_Input_.Fl_Input_">Fl_Input_::Fl_Input_(int x, int y, int w, int h, const char *label = 0)</a></h4>

Creates a new <tt>Fl_Input_</tt> widget using the given position, size, and
label string. The default boxtype is <tt>FL_DOWN_BOX</tt>.

<h4><a name="Fl_Input_.~Fl_Input_">virtual Fl_Input_::~Fl_Input_()</a></h4>

The destructor removes the widget and any value associated with it.

<h4><a name="Fl_Input_.wordboundary">int Fl_Input_::wordboundary(int i) const</a></h4>

Returns true if position <tt>i</tt> is at the start or end of a word.

<h4><a name="Fl_Input_.lineboundary">int Fl_Input_::lineboundary(int i) const</a></h4>

Returns true if position <tt>i</tt> is at the start or end of a line.

<h4><a name="Fl_Input_.drawtext">void Fl_Input_::drawtext(int,int,int,int)</a></h4>

Draw the text in the passed bounding box.  If <tt>damage() &
FL_DAMAGE_ALL</tt> is true, this assummes the area has already been
erased to <tt>color()</tt>.  Otherwise it does minimal update and
erases the area itself.

<h4><a name="Fl_Input_.handletext">void Fl_Input_::handletext(int e,int,int,int,int)</a></h4>

Default handler for all event types.  Your <tt>handle()</tt> method
should call this for all events that it does not handle completely. 
You must pass it the same bounding box as passed to <tt>draw()</tt>. 
Handles <tt>FL_PUSH</tt>, <tt>FL_DRAG</tt>, <tt>FL_RELEASE</tt> to
select text, handles <tt>FL_FOCUS</tt> and <tt>FL_UNFOCUS</tt> to show
and hide the cursor.

<h4><a name="Fl_Input_.up_down_position">int Fl_Input_::up_down_position(int i, int keepmark=0)</a></h4>

Do the correct thing for arrow keys.  Sets the position (and mark if
<i>keepmark</i> is zero) to somewhere in the same line as
<i>i</i>, such that pressing the arrows repeatedly will cause the
point to move up and down.

<h4><a name="Fl_Input_.maybe_do_callback">void Fl_Input_::maybe_do_callback()</a></h4>

Does the callback if <tt>changed()</tt> is true or if <tt>when() &
FL_WHEN_NOT_CHANGED</tt> is non-zero.  You should call this at any
point you think you should generate a callback.

<h4><a name="Fl_Input_.position">int Fl_Input_::position() const<br>
int Fl_Input_::position(int new_position, int new_mark)<br>
int Fl_Input_::position(int new_position_and_new_mark)</a></h4>

The input widget maintains two pointers into the string.  The "position" is
where the cursor is.  The "mark" is the other end of the selected
text.  If they are equal then there is no selection.  Changing this
does not affect the clipboard (use <tt>copy()</tt> to do that).

<p>Changing these values causes a <tt>redraw()</tt>.  The new values
are bounds checked.  The return value is non-zero if the new position
is different than the old one.  <tt>position(n)</tt> is the same as
<tt>position(n,n)</tt>.  <tt>mark(n)</tt> is the same as
<tt>position(position(),n)</tt>.

<h4><a name="Fl_Input_.mark">int Fl_Input_::mark() const<br>
int Fl_Input_::mark(int new_mark)</a></h4>

Gets or sets the current selection mark. <tt>mark(n)</tt> is the same
as <tt>position(position(),n)</tt>.

<h4><a name="Fl_Input_.replace">int Fl_Input_::replace(int a, int b, const char *insert, int length=0)</a></h4>

This call does all editing of the text.  It deletes the region between
<tt>a</tt> and <tt>b</tt> (either one may be less or equal to the
other), and then inserts the string <tt>insert</tt> at that point and
leaves the <tt>mark()</tt> and <tt>position()</tt> after the
insertion.  Does the callback if <tt>when() & FL_WHEN_CHANGED</tt> and
there is a change.

<p>Set <tt>start</tt> and <tt>end</tt> equal to not delete anything.  Set
<tt>insert</tt> to <tt>NULL</tt> to not insert anything.

<p><tt>length</tt> must be zero or <tt>strlen(insert)</tt>, this saves
a tiny bit of time if you happen to already know the length of the
insertion, or can be used to insert a portion of a string or a string
containing nul's.

<p><tt>a</tt> and <tt>b</tt> are clamped to the 0..<tt>size()</tt>
range, so it is safe to pass any values.

<p><tt>cut()</tt> and <tt>insert()</tt> are just inline functions that
call <tt>replace()</tt>.

<h4><a name="Fl_Input_.cut">int Fl_Input_::cut()<br>
int Fl_Input_::cut(int n)<br>
int Fl_Input_::cut(int a, int b);</a></h4>

<tt>Fl_Input_::cut()</tt> deletes the current selection. 
<tt>cut(n)</tt> deletes <tt>n</tt> characters after the
<tt>position()</tt>.  <tt>cut(-n)</tt> deletes <tt>n</tt> characters
before the <tt>position()</tt>.  <tt>cut(a,b)</tt> deletes the
characters between offsets <tt>a</tt> and <tt>b</tt>. <tt>A</tt>,
<tt>b</tt>, and <tt>n</tt> are all clamped to the size of the string. 
The mark and point are left where the deleted text was.

<p>If you want the data to go into the clipboard, do
<tt>Fl_Input_::copy()</tt> before calling <tt>Fl_Input_::cut()</tt>, or
do <tt>Fl_Input_::copy_cuts()</tt> afterwards.

<h4><a name="Fl_Input_.insert">int Fl_Input_::insert(const char *t,int l=0)</a></h4>

Insert the string <tt>t</tt> at the current position, and leave the
mark and position after it.  If <tt>l</tt> is not zero then it is
assummed to be <tt>strlen(t)</tt>.

<h4><a name="Fl_Input_.copy">int Fl_Input_::copy()</a></h4>

Put the current selection between <tt>mark()</tt> and
<tt>position()</tt> into the clipboard.  Does not replace the old
clipboard contents if <tt>position()</tt> and <tt>mark()</tt> are
equal.

<h4><a name="Fl_Input_.undo">int Fl_Input_::undo()</a></h4>

Does undo of several previous calls to <tt>replace()</tt>.  Returns
non-zero if any change was made.

<h4><a name="Fl_Input_.copy_cuts">int Fl_Input_::copy_cuts()</a></h4>

Copy all the previous contiguous cuts from the undo information to the
clipboard.  This is used to make ^K work.

</body>
</html>
