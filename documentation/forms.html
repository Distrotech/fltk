<html><head><link href="fltk.css" rel="stylesheet" type="text/css">
<title>FLTK Forms Compatability</title></head><body>

<h1>Forms Compatibility</h1>

This appendix describes the Forms compatibility included with
FLTK. This documentation is old and may be inaccurate. All the
necessary code to emulate Forms has been moved to it's own source
files.

<p>Forms was a popular GUI library on SGI machines before they
switched to using X (they used to be GL only, actually a lot more
powerful and useful that X or Win32 is today...). It was created by
Mark Overmars at ???. X-Forms is a rewrite to work atop X, but unlike
Forms it was not distributed as Open Source. Much of FLTK's
terminology and widget design is based on and directly descended from
Forms.

<a name=fimport><h2>Importing Forms Layout Files</h2></a>

<a href=fluid.html>Fluid</A> can read the .fd files put out by 
all versions of Forms and XForms fdesign.  However, it will mangle them 
a bit, but it prints a warning message about anything it does not 
understand.  FLUID cannot write fdesign files, so you should save to a 
new name so you don't write over the old one. 

<p>You will need to edit your main code considerably to get it to link 
with the output from FLUID.  If you are not interested in this you may 
have more immediate luck with the forms compatibility header, <tt>
&lt;fltk/forms.h&gt;</tt>. </P>

<a name=fheader><h2>Using the Compatibility Header File</h2></a>

You should be able to compile existing Forms or XForms source code by 
changing the include directory switch to your compiler so that the <tt>
forms.h</tt> file supplied with FLTK is included.  Take a look at <tt>
forms.h</tt> to see how it works, but the basic trick is lots of inline 
functions. Most of the XForms demo programs work without changes. 

<p>You will also have to compile your Forms or XForms program using a 
C++ compiler.  The FLTK library does not provide C bindings or header 
files. </P>

<p>Although FLTK was designed to be compatable with the GL Forms 
library (version 0.3 or so), XForms has bloated severely and it's 
interface is X-specific.  Therefore, XForms compatibility is no longer 
a goal of FLTK.  Compatibility was limited to things that were free, or 
that would add code that would not be linked in if the feature is 
unused, or that was not X-specific. </P>

<p>To use any new features of FLTK, you should rewrite your code to
not use the inline functions and instead use &quot;pure&quot; FLTK.
This will make it a lot cleaner and make it easier to figure out how
to call the FLTK functions.  Unfortunately this conversion is harder
than expected and even Digital Domain's inhouse code still uses
<tt>forms.H</tt> a lot. </P>

<a name=fwidgets><h2>Forms-specific Widget classes</h2></a>

The following widget classes are provided to allow direct porting of
Forms programs. They should not be used in normal FLTK programs.

<ul>
<li><a href=Fl_FormsBitmap.html>Fl_FormsBitmap</a></li>
<li><a href=Fl_FormsPixmap.html>Fl_FormsPixmap</a></li>
<li><a href=Fl_Free.html>Fl_Free</a></li>
<li><a href=Fl_Timer.html>Fl_Timer</a></li>
</ul>

<a name=fbugs><h2>Problems You Will Encounter</h2></a>

<p>Many parts of XForms use X-specific structures like <tt>XEvent</tt>
 in their interface.  I did not emulate these!  Unfortunately these 
features (such as the &quot;canvas&quot; widget) are needed by most large 
programs.  You will need to rewrite these to use FLTK subclasses. </P>

<p><A href=Fl_Free.html#Fl_Free><tt>Fl_Free</tt></A> widgets emulate 
the <I>old</I> Forms &quot;free&quot; widget.  It may be useful for porting 
programs that change the <tt>handle()</tt> function on widgets, but you 
will still need to rewrite things. </P>

<p><A href=Fl_Timer.html#Fl_Timer><tt>Fl_Timer</tt></A> widgets are 
provided to emulate the XForms timer.  These work, but are quite 
inefficient and inaccurate compared to using <A href=Fl.html#add_timeout>
<tt>Fl::add_timeout()</tt></A>. </P>

<p><I>All instance variables are hidden.</I> If you directly refer to
the x, y, w, h, label, or other fields of your Forms widgets you will
have to add empty parenthesis after each reference.  The easiest way
to do this is to globally replace &quot;-&gt;x&quot; with
&quot;-&gt;x()&quot;, etc.  Replace &quot;boxtype&quot; with
&quot;box()&quot;. </P>

<p><tt>const char *</tt> arguments to most FLTK methods are simply 
stored, while Forms would <tt>strdup()</tt> the passed string.  This is 
most noticable with the label of widgets.  Your program must always 
pass static data such as a string constant or malloc'd buffer to <tt>
label()</tt>.  If you are using labels to display program output you 
may want to try the <A href=Fl_Output.html#Fl_Output><tt>Fl_Output</tt></A>
 widget. </P>

<p>The default fonts and sizes are matched to the older GL version of 
Forms, so all labels will draw somewhat larger than an XForms program 
does. </P>

<p>fdesign outputs a setting of a &quot;fdui&quot; instance variable to the main 
window.  I did not emulate this because I wanted all instance variables 
to be hidden.  You can store the same information in the <tt>user_data()</tt>
 field of a window.  To do this,  search through the fdesign output for 
all occurances of &quot;-&gt;fdui&quot; and edit to use &quot;-&gt;user_data()&quot; instead. 
 This will require casts and is not trivial. </P>

<p>The prototype for the functions passed to <tt>fl_add_timeout()</tt>
 and <tt>fl_set_idle_callback()</tt> callback are different. </P>

<p><B>All the following XForms calls are missing:</B></P>

<p>
<UL>
<LI><tt>FL_REVISION</tt>, <tt>fl_library_version()</tt></LI>
<LI><tt>FL_RETURN_DBLCLICK</tt> (use <tt>Fl::event_clicks()</tt>) </LI>
<LI><tt>fl_add_signal_callback()</tt></LI>
<LI><tt>fl_set_form_atactivate()</tt> <tt>fl_set_form_atdeactivate()</tt>
</LI>
<LI><tt>fl_set_form_property()</tt></LI>
<LI><tt>fl_set_app_mainform()</tt>, <tt>fl_get_app_mainform()</tt></LI>
<LI><tt>fl_set_form_minsize()</tt>, <tt>fl_set_form_maxsize()</tt></LI>
<LI><tt>fl_set_form_event_cmask()</tt>, <tt>fl_get_form_event_cmask()</tt>
</LI>
<LI><tt>fl_set_form_dblbuffer()</tt>, <tt>fl_set_object_dblbuffer()</tt>
 (use an <tt>Fl_Double_Window</tt> instead) </LI>
<LI><tt>fl_adjust_form_size()</tt></LI>
<LI><tt>fl_register_raw_callback()</tt></LI>
<LI><tt>fl_set_object_bw()</tt>, <tt>fl_set_border_width()</tt></LI>
<LI><tt>fl_set_object_resize()</tt>, <tt>fl_set_object_gravity()</tt></LI>
<LI><tt>fl_set_object_shortcutkey()</tt></LI>
<LI><tt>fl_set_object_automatic()</tt></LI>
<LI><tt>fl_get_object_bbox()</tt> (maybe FLTK should do this) </LI>
<LI><tt>fl_set_object_prehandler()</tt>, <tt>fl_set_object_posthandler()</tt>
</LI>
<LI><tt>fl_enumerate_fonts()</tt></LI>
<LI>Most drawing functions </LI>
<LI><tt>fl_set_coordunit()</tt> (FLTK uses pixels all the time) </LI>
<LI><tt>fl_ringbell()</tt></LI>
<LI><tt>fl_gettime()</tt></LI>
<LI><tt>fl_win*()</tt> (all these functions) </LI>
<LI><tt>fl_initialize(argc,argv,x,y,z)</tt> ignores last 3 arguments </LI>
<LI><tt>fl_read_bitmapfile()</tt>, <tt>fl_read_pixmapfile()</tt></LI>
<LI><tt>fl_addto_browser_chars()</tt></LI>
<LI><tt>FL_MENU_BUTTON</tt> just draws normally </LI>
<LI><tt>fl_set_bitmapbutton_file()</tt>, <tt>fl_set_pixmapbutton_file()</tt>
</LI>
<LI><tt>FL_CANVAS</tt> objects </LI>
<LI><tt>FL_DIGITAL_CLOCK</tt> (comes out analog) </LI>
<LI><tt>fl_create_bitmap_cursor()</tt>, <tt>fl_set_cursor_color()</tt></LI>
<LI><tt>fl_set_dial_angles()</tt></LI>
<LI><tt>fl_show_oneliner()</tt></LI>
<LI><tt>fl_set_choice_shortcut(a,b,c) </tt></LI>
<LI>command log </LI>
<LI>Only some of file selector is emulated </LI>
<LI><tt>FL_DATE_INPUT</tt></LI>
<LI><tt>fl_pup*()</tt> (all these functions) </LI>
<LI>textbox object (should be easy but I had no sample programs) </LI>
<LI>xyplot object </LI>
</UL>

<a name=fnotes><h2>Additional Notes</h2></a>

These notes were written for porting programs written with the older 
IRISGL version of Forms.  Most of these problems are the same ones 
encountered when going from old Forms to XForms: 

<h3>Does Not Run In Background</h3>

The IRISGL library always forked when you created the first window, 
unless &quot;foreground()&quot; was called.  FLTK acts like &quot;foreground()&quot; is 
called all the time.  If you really want the fork behavior do &quot;if 
(fork()) exit(0)&quot; right at the start of your program. 

<h3>You Cannot Use IRISGL Windows or fl_queue</h3>

If a Forms (not XForms) program if you wanted your own window for 
displaying things you would create a IRISGL window and draw in it, 
periodically calling Forms to check if the user hit buttons on the 
panels.  If the user did things to the IRISGL window, you would find 
this out by having the value FL_EVENT returned from the call to Forms. 

<p>None of this works with FLTK.  Nor will it compile, the necessary 
calls are not in the interface. </P>

<p>You have to make a subclass of <A href=Fl_Gl_Window.html#Fl_Gl_Window>
<tt>Fl_Gl_Window</tt></A> and write a <tt>draw()</tt> method and <tt>
handle()</tt> method.  This may require anywhere from a trivial to a 
major rewrite. </P>

<p>If you draw into the overlay planes you will have to also write a <tt>
draw_overlay()</tt> method and call <tt>redraw_overlay()</tt> on the 
OpenGL window. </P>

<p>One easy way to hack your program so it works is to make the <tt>
draw()</tt> and <tt>handle()</tt> methods on your window set some 
static variables, storing what event happened.  Then in the main loop 
of your program, call <tt>Fl::wait()</tt> and then check these 
variables, acting on them as though they are events read from <tt>
fl_queue</tt>. </P>

<h3>You Must Use OpenGL to Draw Everything</h3>

<p>The file <tt>&lt;FL/gl.h&gt;</tt> defines replacements for a lot of IRISGL 
calls, translating them to OpenGL.  There are much better translators 
available that you might want to investigate. </P>

<h3>You Cannot Make Forms Subclasses</h3>

Programs that call <tt>fl_make_object</tt> or directly setting the 
handle routine will not compile.  You have to rewrite them to use a 
subclass of <tt>Fl_Widget</tt>.  It is important to note that the <tt>
handle()</tt> method is not exactly the same as the <tt>handle()</tt>
function of Forms.  Where a Forms <tt>handle()</tt> returned non-zero, 
your <tt>handle()</tt> must call <tt>do_callback()</tt>. And your <tt>
handle()</tt> must return non-zero if it &quot;understood&quot; the event. 

<p>An attempt has been made to emulate the &quot;free&quot; widget.
This appears to work quite well.  It may be quicker to modify your
subclass into a &quot;free&quot; widget, since the &quot;handle&quot;
functions match. </P>

<p>If your subclass draws into the overlay you are in trouble and will 
have to rewrite things a lot. </P>

<h3>You Cannot Use &lt;device.h&gt;</h3>

If you have written your own &quot;free&quot; widgets you will probably get a 
lot of errors about &quot;getvaluator&quot;.  You should substitute: 

<center><table border=1 width=90%>
<TR><TH align=center>Forms</TH><TH align=center>FLTK</TH></TR>
<TR><TD>MOUSE_X</TD><TD>Fl::event_x_root()</TD></TR>
<TR><TD>MOUSE_Y</TD><TD>Fl::event_y_root()</TD></TR>
<TR><TD>LEFTSHIFTKEY,RIGHTSHIFTKEY</TD><TD>Fl::event_shift()</TD></TR>
<TR><TD>CAPSLOCKKEY</TD><TD>Fl::event_capslock()</TD></TR>
<TR><TD>LEFTCTRLKEY,RIGHTCTRLKEY</TD><TD>Fl::event_ctrl()</TD></TR>
<TR><TD>LEFTALTKEY,RIGHTALTKEY</TD><TD>Fl::event_alt()</TD></TR>
<TR><TD>MOUSE1,RIGHTMOUSE</TD><TD>Fl::event_state()</TD></TR>
<TR><TD>MOUSE2,MIDDLEMOUSE</TD><TD>Fl::event_state()</TD></TR>
<TR><TD>MOUSE3,LEFTMOUSE</TD><TD>Fl::event_state()</TD></TR>
</table></center>

Anything else in <tt>getvaluator</tt> and you are on your own... 

<h3>Font Numbers Are Different</h3>

The &quot;style&quot; numbers have been changed because I wanted to insert 
bold-italic versions of the normal fonts.  If you use Times, Courier, 
or Bookman to display any text you will get a different font out of 
FLTK. Add one to the index for these.

</body></html>
