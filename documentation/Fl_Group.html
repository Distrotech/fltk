<html>
<body>

<hr break>

<h2><a name="Fl_Group">class Fl_Group</a></h2>

<hr>

<h3>Class Hierarchy</h3>

<ul><pre>
<a href="#Fl_Widget">Fl_Widget</a>
   |
   +----<b>Fl_Group</b>
           |
           +----<a href="#Fl_Pack">Fl_Pack</a>, <a href="#Fl_Scroll">Fl_Scroll</a>, <a href="#Fl_Tabs">Fl_Tabs</a>, <a href="#Fl_Tile">Fl_Tile</a>, <a href="#Fl_Window">Fl_Window</a>
</pre></ul>

<h3>Include Files</h3>

<ul><pre>
#include &lt;FL/Fl_Group.H>
</pre></ul>

<h3>Description</h3>

The <tt>Fl_Group</tt> class is the FLTK container widget. It maintains
an array of child widgets. These children can themselves be any widget
including <tt>Fl_Group</tt>. The most important subclass of <tt>Fl_Group</tt>
is <a href="#Fl_Window"><tt>Fl_Window</tt></a>, however groups can also
be used to control radio buttons or to enforce resize behavior.

<h3>Methods</h3>

<center>
<table width=90%>
<tr>
<td align=left valign=top>
<ul>
	<li><a href="#Fl_Group.Fl_Group">Fl_Group</a>
	<li><a href="#Fl_Group.~Fl_Group">~Fl_Group</a>
	<li><a href="#Fl_Group.add">add</a>
</ul>
</td>
<td align=left valign=top>
<ul>
	<li><a href="#Fl_Group.add_resizable">add_resizable</a>
	<li><a href="#Fl_Group.array">array</a>
	<li><a href="#Fl_Group.begin">begin</a>
</ul>
</td>
<td align=left valign=top>
<ul>
	<li><a href="#Fl_Group.child">child</a>
	<li><a href="#Fl_Group.children">children</a>
	<li><a href="#Fl_Group.current">current</a>
</ul>
</td>
<td align=left valign=top>
<ul>
	<li><a href="#Fl_Group.end">end</a>
	<li><a href="#Fl_Group.find">find</a>
	<li><a href="#Fl_Group.insert">insert</a>
</ul>
</td>
<td align=left valign=top>
<ul>
	<li><a href="#Fl_Group.remove">remove</a>
	<li><a href="#Fl_Group.resizeable">resizable</a>
</ul>
</td>
</tr>
</table>
</center>

<h4><a name="Fl_Group.Fl_Group">Fl_Group::Fl_Group(int x, int y, int w, int h, const char *label = 0)</a></h4>

Creates a new <tt>Fl_Group</tt> widget using the given position, size, and
label string. The default boxtype is <tt>FL_NO_BOX</tt>.

<h4><a name="Fl_Group.~Fl_Group">virtual Fl_Group::~Fl_Group()</a></h4>

The destructor <i>also deletes all the children</i>. This allows a
whole tree to be deleted at once, without having to keep a pointer to all
the children in the user code. A kludge has been done so the
<tt>Fl_Group</tt> and all of it's children can be automatic (local)
variables, but you must declare the <tt>Fl_Group</tt> <i>first</i>, so
that it is destroyed last.

<h4><a name="Fl_Group.add">void Fl_Group::add(Fl_Widget &amp;w)<BR>
void Fl_Group::add(Fl_Widget *w)</a></h4>

Adds a widget to the group at the end of the child array.

<h4><a name="Fl_Group.add_resizable">Fl_Group &amp;Fl_Group::add_resizable(Fl_Widget &amp;box)</a></h4>

Adds a widget to the group and makes it the resizable widget.

<h4><a name="Fl_Group.array">const Fl_Widget **Fl_Group::array() const</a></h4>

Returns a pointer to the array of children. <i>This pointer can change
when children are added or removed!</i>

<h4><a name="Fl_Group.begin">void Fl_Group::begin()</a></h4>

<tt>begin()</tt> sets the current group so you can build the widget tree
by just constructing the widgets. <tt>begin()</tt> is automatically called by
the constructor for Fl_Group (and thus for Fl_Window as well).
<tt>begin()</tt> does <tt>current(this)</tt>.

<p><i>Don't forget to <tt>end()</tt> the group or window!</i>

<h4><a name="Fl_Group.child">Fl_Widget *Fl_Group::child(int n) const</a></h4>

Returns child <tt>n</tt>, where <tt>0 <= n < children()</tt>.

<h4><a name="Fl_Group.children">int Fl_Group::children() const</a></h4>

Returns how many child widgets the group has.

<h4><a name="Fl_Group.current">static Fl_Group *Fl_Group::current()<BR>
static void Fl_Group::current(Fl_Group *w)</a></h4>

<tt>current()</tt> returns the currently active group in the widget tree.
To prevent widgets from being added to a group, call <tt>current()</tt>
with a <tt>NULL</tt> group.

<h4><a name="Fl_Group.end">void Fl_Group::end()</a></h4>

<tt>end()</tt> does <tt>current(this->parent())</tt>. Any new widgets added
to the widget tree will be added to the parent of the group.

<h4><a name="Fl_Group.find">int Fl_Group::find(const Fl_Widget *w) const<BR>
int Fl_Group::find(const Fl_Widget &amp;w) const</a></h4>

Searches the child array for the widget and returns the index. Returns
<a href="#Fl_Group.children"><tt>children()</tt></a> if the widget is
<tt>NULL</tt> or not found.

<h4><a name="Fl_Group.insert">void Fl_Group::insert(Fl_Widget &amp;w, int n)<BR>
void Fl_Group::insert(Fl_Widget &amp;w, Fl_Widget *beforethis)</a></h4>

Inserts a widget into the child array. It is put at index <tt>n</tt> which
must be less or equal to children(). The second version does a
<tt>find(beforethis)</tt> and inserts using that index.

<h4><a name="Fl_Group.remove">void Fl_Group::remove(Fl_Widget &amp;w)</a></h4>

Removes a widget from the group. This does nothing if the widget
is not currently a child of this group.

<h4><a name="Fl_Group.resizeable">void Fl_Group::resizable(Fl_Widget *box)<BR>
void Fl_Group::resizable(Fl_Widget &amp;box)<BR>
Fl_Widget *Fl_Group::resizable() const</a></h4>

The resizable widget defines the resizing box for the group. When the
group is resized it calculates a new size and position for all of its
children. Widgets that are horizontally or vertically inside the dimensions
of the box are scaled to the new size. Widgets outside the box are moved.

<p>In these examples the gray area is the resizable:<br>

<p align=center><img SRC="resizebox1.gif" align=TOP height=240>&nbsp;&nbsp;
<img SRC="resizebox2.gif" align=TOP height=240>

<p>The resizable may be set to the group itself (this is the default value
for an <tt>Fl_Group</tt>, although <tt>NULL</tt> is the default for an
<tt>Fl_Window</tt>), in which case all the contents are resized. If the
resizable is <tt>NULL</tt> then all widgets remain a fixed size and
distance from the top-left corner.

<p>It is possible to achieve any type of resize behavior by using an
invisible <tt>Fl_Box</tt> as the resizable and/or by using a hierarchy of
child <tt>Fl_Group</tt>'s.

</body>
</html>
