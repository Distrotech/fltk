<html>
<body>

<hr break>

<h2><a name="Fl_Menu_Button">class Fl_Menu_Button</a></h2>

<hr>

<h3>Class Hierarchy</h3>

<ul><pre>
<a href="#Fl_Menu_">Fl_Menu_</a>
   |
   +----<b>Fl_Menu_Button</b>
</pre></ul>

<h3>Include Files</h3>

<ul><pre>
#include &lt;FL/Fl_Menu_Button.H>
</pre></ul>

<h3>Description</h3>

This is a button that when pushed pops up a menu (or hierarchy of
menus) defined by an array of <a href="#Fl_Menu_Item"><tt>Fl_Menu_Item</tt></a>
objects.

<P><img src=menu_button.gif>

<p>Normally any mouse button will pop up a menu and it is lined up
below the button as shown in the picture.  However an <tt>Fl_Menu_Button</tt>
may also control a pop-up menu.  This is done by setting the
<tt>type()</tt>,
see below.

<p>The menu will also pop up in response to shortcuts indicated by
putting a '&' character in the <tt>label()</tt>.

<p>Typing the <tt>shortcut()</tt> of any of the menu items will cause
callbacks exactly the same as when you pick the item with the mouse. 
The '&' character in menu item names are only looked at when the menu
is popped up, however.

<P>When the user picks an item off the menu, the item's callback is
done with the menu_button as the <tt>Fl_Widget*</tt> argument.  If the item
does not have a callback the menu_button's callback is done instead.

<h3>Methods</h3>

<ul>
	<li><a href="#Fl_Menu_Button.Fl_Menu_Button">Fl_Menu_Button</a>
	<li><a href="#Fl_Menu_Button.~Fl_Menu_Button">~Fl_Menu_Button</a>
	<li><a href="#Fl_Menu_Button.popup">popup</a>
	<li><a href="#Fl_Menu_Button.type">type</a>
</ul>

<h4><a name="Fl_Menu_Button.Fl_Menu_Button">Fl_Menu_Button::Fl_Menu_Button(int x, int y, int w, int h, const char *label = 0)</a></h4>

Creates a new <tt>Fl_Menu_Button</tt> widget using the given position, size, and
label string. The default boxtype is <tt>FL_UP_BOX</tt>.

<p>The constructor sets <tt>menu()</tt> to <tt>NULL</tt>.  See <a
href="#Fl_Menu_"><tt>Fl_Menu_</tt></a> for the methods to set or change
the menu.

<h4><a name="Fl_Menu_Button.~Fl_Menu_Button">virtual Fl_Menu_Button::~Fl_Menu_Button()</a></h4>

The destructor removes the <tt>Fl_Menu_Button</tt> widget and all of its menu items.

<h4><a name="Fl_Menu_Button.popup">const Fl_Menu* Fl_Menu_Button::popup()</a></h4>

Act exactly as though the user clicked the button or typed the shortcut
key.  The menu appears, it waits for the user to pick an item, and if
they pick one it sets <tt>value()</tt> and does the callback or sets
<tt>changed()</tt> as described above.  The menu item is returned or
<tt>NULL<tt> if the user dismisses the menu.

<h4><a name="Fl_Menu_Button.type">void Fl_Widget::type(uchar)</a></h4>

If <tt>type()</tt> is zero a normal menu button is produced.  If it is
nonzero then this is a pop-up menu.  The bits in <tt>type()</tt>
indicate what mouse buttons pop up the menu.  For convienece the
constants <tt>Fl_Menu_Button::POPUP1, POPUP2, POPUP3, POPUP12, POPUP13,
POPUP23</tt>, and <tt>POPUP123</tt> are defined.
<tt>Fl_Menu_Button::POPUP3</tt> is usually what you want.

<p>A popup menu button is invisible and does not interfere with any
events other than the mouse button specified (and any shortcuts).  The
widget can be stretched to cover all your other widgets by putting it last
in the hierarchy so it is "on top".  You can also make several widgets
covering different areas for context-sensitive popup menus.

<p>The popup menus appear with the cursor pointing at the previously
selected item.  This is a <i>feature</i>.  If you don't like it, do
<tt>value(0)</tt> after the menu items are picked to forget the current
item.

</body>
</html>
