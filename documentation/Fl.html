<html><head><title>Fl::functions</title></head><body bgcolor = white>

<a name="functions"><h1 align=right>B - The Fl:: Functions</h1></a>

This appendix describes all of the <b><tt>Fl::foo()</tt></b>
functions.  These functions mostly are concerned with event handling
and waiting for events. <b><tt>Fl::</tt></b> should be considered a
C++ "namespace". However it is implemented as a class with no
instance variables and only static methods, in order to work with
older C++ compilers that do not handle namespaces.

<h3>Methods</h3>

<center>
<table width=90%>
<tr><td align=left valign=top>
<ul>
<li><a href="#add_check">add_check</a></li>
<li><a href="#add_fd">add_fd</a></li>
<li><a href="#add_handler">add_handler</a></li>
<li><a href="#add_idle">add_idle</a></li>
<li><a href="#add_timeout">add_timeout</a></li>
<li><a href="#arg">arg</a></li>
<li><a href="#args">args</a></li>
<li><a href="#awake">awake</a></li>
<li><a href="#belowmouse">belowmouse</a></li>
<li><a href="#check">check</a></li>
<li><a href="#compose">compose</a></li>
<li><a href="#compose_reset">compose_reset</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#damage">damage</a></li>
</ul>
</td><td align=left valign=top>
<ul>
<li><a href="#display">display</a></li>
<li><a href="#error">error</a></li>
<li><a href="#event">event</a></li>
<li><a href="#event_button">event_button</a></li>
<li><a href="#event_clicks">event_clicks</a></li>
<li><a href="#event_dx">event_dx</a></li>
<li><a href="#event_dy">event_dy</a></li>
<li><a href="#event_inside">event_inside</a></li>
<li><a href="#event_is_click">event_is_click</a></li>
<li><a href="#event_key">event_key</a></li>
<li><a href="#event_length">event_length</a></li>
<li><a href="#event_state">event_state</a></li>
<li><a href="#event_text">event_text</a></li>
<li><a href="#event_x">event_x</a></li>
</ul>
</td><td align=left valign=top>
<ul>
<li><a href="#event_x_root">event_x_root</a></li>
<li><a href="#event_y">event_y</a></li>
<li><a href="#event_y_root">event_y_root</a></li>
<li><a href="#fatal">fatal</a></li>
<li><a href="#first_window">first_window</a></li>
<li><a href="#first_window_a">first_window_a</a></li>
<li><a href="#flush">flush</a></li>
<li><a href="#focus">focus</a></li>
<li><a href="#get_key">get_key</a></li>
<li><a href="#get_mouse">get_mouse</a></li>
<li><a href="#gl_visual">gl_visual</a></li>
<li><a href="#has_check">has_check</a></li>
<li><a href="#has_idle">has_idle</a></li>
<li><a href="#has_timeout">has_timeout</a></li>
</ul>
</td><td align=left valign=top>
<ul>
<li><a href="#help">help</a></li>
<li><a href="#info">info</a></li>
<li><a href="#key_name">key_name</a></li>
<li><a href="#lock">lock</a></li>
<li><a href="#modal">modal</a></li>
<li><a href="#next_window">next_window</a></li>
<li><a href="#own_colormap">own_colormap</a></li>
<li><a href="#paste">paste</a></li>
<li><a href="#pushed">pushed</a></li>
<li><a href="#ready">ready</a></li>
<li><a href="#redraw">redraw</a></li>
<li><a href="#reload_scheme">reload_scheme</a></li>
<li><a href="#remove_check">remove_check</a></li>
<li><a href="#remove_fd">remove_fd</a></li>
</ul>
</td><td align=left valign=top>
<ul>
<li><a href="#remove_idle">remove_idle</a></li>
<li><a href="#remove_timeout">remove_timeout</a></li>
<li><a href="#repeat_timeout">repeat_timeout</a></li>
<li><a href="#run">run</a></li>
<li><a href="#scheme">scheme</a></li>
<li><a href="#startup">startup</a></li>
<li><a href="#test_shortcut">test_shortcut</a></li>
<li><a href="#theme">theme</a></li>
<li><a href="#thread_message">thread_message</a></li>
<li><a href="#unlock">unlock</a></li>
<li><a href="#version">version</a></li>
<li><a href="#visual">visual</a></li>
<li><a href="#wait">wait</a></li>
<li><a href="#warning">warning</a></li>
</ul>
</td></tr>
</table>
</center>

<p>FLTK also provides a number of global functions with
<tt>fl_xyz</tt> names. The majority of these are concerned with
drawing or graphics state, and are described in the <a
href="drawing.html">Drawing</a> appendix. The others are a set of modal
popup utility functions for asking questions described in 
the <a href="utility.html">Utility</a> appendix.

<a name="version"><h4>double Fl::version()</h4></a>

Returns the version number of fltk. This can be compared to the value
of the <tt>FL_VERSION</tt> macro to see if the shared library of fltk your
program linked with is up to date. The current version is 2.0001 and
is of the form M.mmpp where M is the major number (2), mm is the minor
number, and pp is the patch number.

<a name="arg"><h4>int Fl::arg(int argc, char **argv, int &amp;i)</h4></a>

Consume a single switch from <tt>argv</tt>, starting at word i. 
Returns the number of words eaten (1 or 2, or 0 if it is not 
recognized) and adds the same value to <tt>i</tt>.  You can use this 
function if you prefer to control the incrementing through the 
arguments yourself. 

<a name="args"><h4>int Fl::args(int argc, char **argv, int &amp;i, int 
(*callback)(int, char**,int &amp;)=0)
<br>void Fl::args(int argc, char **argv)</h4></a>

FLTK provides an <I>entirely optional</I> command-line switch parser. 
You don't have to call it if you don't like them! Everything it can do 
can be done with other calls to FLTK. 

<p>To use the switch parser, call <a
href="#args"><tt>Fl::args(...)</tt></a> near the start of your program.
This does <I>not</I> open the display, instead switches that need the
display open are stashed into static variables.  Then you <I>must</I>
display your first window by calling <a href="Fl_Window.html#show">
window-&gt;show(argc,argv)</a>, which will do anything stored in the
static variables.</p>

<p><tt>callback</tt> lets you define your own switches.  It is called 
with the same <tt>argc</tt> and <tt>argv</tt>, and with <tt>i</tt> the 
index of each word. The callback should return zero if the switch is 
unrecognized, and not change <tt>i</tt>.  It should return non-zero if 
the switch is recognized, and add at least 1 to <tt>i</tt> (it can add 
more to consume words after the switch).  This function is called 
<i>before</i> any other tests, so <i>you can override any FLTK
switch</i> (this is why fltk can use very short switches instead of
the long ones all other toolkits force you to use).</p>
<p>On return <tt>i</tt> is set to the index of the first non-switch. 
This is either:</p>

<ul>
<li>The first word that does not start with '-'.</li>
<li>The word '-' (used by many programs to name stdin as a file)</li>
<li>The first unrecognized switch (return value is 0).</li>
<li><tt>argc</tt></li>
</ul>

The return value is <tt>i</tt> unless an unrecognized switch is found, 
in which case it is zero.  If your program takes no arguments other 
than switches you should produce an error if the return value is less 
than <tt>argc</tt>. 

<p>All switches except -bg2 may be abbreviated one letter and case is
ignored:

<ul>
<li><tt>-display host:n.n</tt> The X display to use (ignored  under 
WIN32).</li>
<li><tt>-geometry WxH+X+Y</tt> The window position and size  will be 
modified according the the standard X geometry string.</li>
<li><tt>-name string</tt> Fl_Window::xclass(string) will be  done to 
the window, possibly changing its icon.</li>
<li><tt>-title string</tt> Fl_Window::label(string) will be  done to 
the window, changing both its title and the icontitle.</li>
<li><tt>-iconic</tt> Fl_Window::iconize() will be done to  the window.</li>
<li><tt>-bg color</tt> XParseColor is used to lookup the  passed color 
and then Fl::background() is done.  Under WIN32  only color names of 
the form &quot;#xxxxxx&quot; are understood.</li>
</ul>

The second form of <tt>Fl::args()</tt> is useful if your program does 
not have command line switches of its own.  It parses all the switches, 
and if any are not recognized it calls <a href="#abort"><tt>Fl::abort(Fl::help)</tt></a>. 

<a name="help"><h4>const char* const Fl::help;</h4></a>

This is the usage string that is displayed if <a
href="#args"><tt>Fl::args()</tt></a> detects an invalid argument on
the command-line. It's value is:

<pre>
" -d[isplay] host:n.n\n"
" -g[eometry] WxH+X+Y\n"
" -s[cheme] scheme\n"
" -t[heme] theme\n"
" -n[ame] windowname\n"
" -i[conic]\n"
" -bg color";
</pre>

<h4><a name="theme">bool Fl::theme(const char*)</a>
<br><a name="scheme">bool Fl::scheme(const char*)</a>
<br><a name="reload_scheme">void Fl::reload_scheme()</a>
<br><a name="startup">void startup();</h4>

These are not documented yet and will probably be changed considerably.

<a name="display"><h4>void Fl::display(const char *)</h4></a>

Sets the X display to use for all windows.  Actually this just sets
the environment variable $DISPLAY to the passed string, so this only
works before you show() the first window or otherwise open the display,
and does nothing useful under WIN32. 

<a name="visual"><h4>int Fl::visual(int)</h4></a>

This call may be useful on multi-visual X servers to change from the
default to a more useful color mode. You must call this before you
show() any windows. The integer argument is an 'or' of the following:

<ul>

<li><tt>FL_INDEX</tt> indicates that a colormapped visual is ok. This
call will normally fail if a TrueColor visual cannot be found.

<li><tt>FL_RGB</tt> this value is zero and may be passed to indicate
that <tt>FL_INDEX</tt> is not wanted.

<li><tt>FL_RGB8</tt> indicates that the TrueColor visual must have at
least 8 bits of red, green, and blue (Windows calls this "millions of
colors").

<li><tt>FL_DOUBLE</tt> indicates that hardware accelerated double
buffering is wanted. This will make <a
href="Fl_Double_Window.html">Fl_Double_Window</a> work better.

</ul>

This returns true if the system has the capabilities by default or 
FLTK suceeded in turing them on.  Your program will still work even if 
this returns false (it just won't look as good). On non-X systems
this just returns true or false indicating if the system supports the
passed values.

<a name="gl_visual"><h4>int Fl::gl_visual(int)</h4></a>

This does the same thing as <a
href="#visual"><tt>Fl::visual(int)</tt></a> but also requires OpenGL
drawing to work. Doing this on X will reduce colormap flashing at the
edges of <a href="Fl_Gl_Window.html"><tt>Fl_Gl_Window</tt></a>s when
they are inside regular windows.

<p>See <a href="Fl_Gl_Window.html#Fl_Gl_Window.mode"><tt>Fl_Gl_Window</tt></a>
for a list of additional values for the argument.</p>

<p><i>This function seems to have been renamed</i> <tt>fl_gl_visual(int)</tt>.

<a name="own_colormap"><h4>void Fl::own_colormap()</h4></a>

Makes FLTK use its own colormap.  This may make FLTK display better 
and will reduce conflicts with other programs that want lots of colors. 
However the colors may flash as you move the cursor between windows. 

<p>This does nothing if the current visual is not colormapped.</p>

<a name="wait"><h4>int Fl::wait()</h4></a>

Same as <a href="#wait"><tt>Fl::wait(infinity)</tt></a>.  Call this repeatedly to "run"
your program.  You can also check what happened each time after this
returns, which is quite useful for managing program state.

<h4>int Fl::wait(double time)</h4>

Waits until "something happens", or the given time interval passes.
<i>It can return much sooner than the time if something happens.</i>

<P>What this really does is call all idle callbacks, all elapsed
timeouts, call <a href="#flush"><tt>Fl::flush()</tt></a> to get the screen to update, and
then wait some time (zero if there are idle callbacks, the shortest of
all pending timeouts, or the given time), for any events from the user
or any <a href="#add"><tt>Fl::add_fd()</tt></a> callbacks.  It then handles the events
and calls the callbacks and then returns.

<P>The return value is non-zero if there are any visible windows (this
may change in future versions of fltk).

<P>The return value is whatever the select() system call returned.
This will be negative if there was an error (this will happen on Unix
if a signal happens), zero if the timeout occurred, and positive if
any events or fd's came in.

<p>On Win32 the return value is zero if nothing happened and
<i>time</i> is 0.0.  Otherwise 1 is returned.

<a name="check"><h4>int Fl::check()</h4></a>

Same as <a href="#wait"><tt>Fl::wait(0)</tt></a>.  Calling this during a big calculation
will keep the screen up to date and the interface responsive:

<ul><pre>while (!calculation_done()) {
 calculate();
 Fl::check();
 if (user_hit_abort_button()) break;
}</pre></ul>

<a name="ready"><h4>int Fl::ready()</h4></a>

This is similar to <a href="#check"><tt>Fl::check()</tt></a> except this does <I>not</I>
call <a href="#flush"><tt>Fl::flush()</tt></a> and thus does not draw anything, and does
not read any events or call any callbacks.  This returns true if <a
href="#check"><tt>Fl::check()</tt></a> would do anything (it will
continue to return true until you call <a href="#check"><tt>Fl::check()</tt></a> or
<a href="#wait"><tt>Fl::wait()</tt></a>).

<p>This is useful if your program is in a state where such callbacks
are illegal, or because the expense of redrawing the screen is much
greater than the expense of your calculation.

<ul><pre>while (!calculation_done()) {
 calculate();
 if (Fl::ready()) {
   do_expensive_cleanup();
   Fl::check();
   if (user_hit_abort_button()) break;
 }
}</pre></ul>

<a name="run"><h4>int Fl::run()</h4></a>

Calls <a href="#wait"><tt>Fl::wait()</tt></a> as long as any windows are
not closed. When all the windows are hidden by <a
href="Fl_Window.html#hide"><tt>Fl_Window::hide()</tt></a> (which is
normally called by the user closing them with the close box) this will
return with zero. A program can also exit by having a callback call
<tt>exit()</tt> or <tt>abort()</tt>.

<p>Most fltk programs will end
<tt>main()</tt> with <tt>return Fl::run();</tt>.

<a name="modal"><h4>void Fl::modal(Fl_Widget*, bool grab=false);
<br>Fl_Widget* Fl::modal();
<br>bool Fl::grab();
<br>void Fl::exit_modal();
<br>bool Fl::exit_modal_flag();
</h4></a>

First thing: much of the time <a
href="Fl_Window.html#exec"><tt>Fl_Window::exec()</tt></a> will do what
you want, so try using that.

<p>This function sets the passed widget as the "modal widget". All
user events are directed to it or a child of it, preventing the user
from messing with other widgets. The modal widget does not have to be
visible or even a child of an Fl_Window for this to work (but if it
not visible, Fl::event_x() and Fl::event_y() are meaningless, use
Fl::event_x_root() and Fl::event_y_root()).

<p><tt>Fl::exit_modal()</tt> sets the
<tt>Fl::exit_modal_flag()</tt>. This may be used by user callbacks to
cancel modal state. The flag is also set by the destruction or hiding
of the modal widget, and on Windows by other applications taking the
focus when <i>grab</i> is on.

<p>The calling code then loops calling <a
href="#wait"><tt>Fl::wait()</tt></a> until Fl::exit_modal_flag() is set
or you otherwise decide to get out of the modal state. It is the
calling code's responsibility to monitor this flag and restore the
modal widget to it's previous value when it turns on.

<p><tt>Fl::modal()</tt> returns the current modal widget, or null if
there isn't one, and <tt>Fl::grab()</tt> returns the current value of
grab (this is always false if the modal widget is null). It is useful
to test these in timeouts and file descriptor callbacks in order to
block actions that should not happen while the modal window is up. You
also need these in order to save and restore the modal state.

<p><i>grab</i> indicates that the modal widget should get events from
anywhere on the screen. This is done by messing with the window
system.  If <tt>Fl::exit_modal()</tt> is called in response to an
FL_PUSH event (rather than waiting for the drag or release event) fltk
will "repost" the event so that it is handled after modal state is
exited. This may also be done for keystrokes in the future.
On both X and WIN32 <i>grab</i> will not work unless you have some
visible window because the system interface needs a visible window id.
On X be careful that your program does not enter an infinite loop 
while <tt>grab()</tt> is on, it will lock up your screen!</i>

<a name="add_timeout"><h4>void Fl::add_timeout(float t, void (*cb)(void*),void*v=0)</h4></a>

Add a one-shot timeout callback.  The function will be called by
<a href="#wait"><tt>Fl::wait()</tt></a> at <i>t</i> seconds after this function is called.
The optional <tt>void*</tt> argument is passed to the callback.

<a name="repeat_timeout"><h4>void Fl::repeat_timeout(float t, void (*cb)(void*),void*v=0)</h4></a>

Inside a timeout callback you can call this to add another timeout.
Rather than the time being measured from "now", it is measured from
when the system call elapsed that caused this timeout to be called.  This
will result in far more accurate spacing of the timeout callbacks, it
also has slightly less system call overhead.  (It will also use all
your machine time if your timeout code and fltk's overhead take more
than <i>t</i> seconds, as the real timeout will be reduced to zero).

<p>It is undefined what this does if called from outside a timeout
callback.

<P>This code will print &quot;TICK&quot; each second on stdout, with a
fair degree of accuracy:

<ul><PRE>void callback(void*) {
  printf(&quot;TICK\n&quot;);
  Fl::repeat_timeout(1.0,callback);
}

main() {
  Fl::add_timeout(1.0,callback);
  for (;;) Fl::wait();
}</PRE></ul>

<a name="has_timeout"><h4>int Fl::has_timeout(void (*cb)(void*), void* = 0)</h4></a>

Returns true if the timeout exists and has not been called yet.

<a name="remove_timeout"><h4>void Fl::remove_timeout(void (*cb)(void*), void* = 0)</h4></a>

Removes a timeout callback. It is harmless to remove a timeout
callback that no longer exists.

<a name="add_check"><h4>void Fl::add_check(void (*cb)(void*),void*v=0)</h4></a>

Fltk will call this callback just before it flushes the display and
waits for events.  This is different than an idle callback because it
is only called once, then fltk calls the system and tells it not to
return until an event happens.

<p>This can be used by code that wants to monitor the
application's state, such as to keep a display up to date. The
advantage of using a check callback is that it is called only when no
events are pending. If events are coming in quickly, whole blocks of
them will be processed before this is called once. This can save
significant time and avoid the application falling behind the events.

<p>Sample code:

<ul><pre>bool state_changed; // anything that changes the display turns this on

void callback(void*) {
  if (!state_changed) return;
  state_changed = false;
  do_expensive_calculation();
  widget->redraw();
}

main() {
  Fl::add_check(1.0,callback);
  return Fl::run();
}</pre></ul>

<a name="has_check"><h4>int Fl::has_check(void (*cb)(void*), void* = 0)</h4></a>

Returns true if the check exists and has not been called yet.

<a name="remove_check"><h4>void Fl::remove_check(void (*cb)(void*), void* = 0)</h4></a>

Removes a check callback. It is harmless to remove a check
callback that does not exist.

<a name="add_fd"><h4>void Fl::add_fd(int fd, void (*cb)(int, void*), void* = 0)
<br>void Fl::add_fd(int fd, int when, void (*cb)(int, void*), void* = 0)</h4></a>

Add file descriptor <tt>fd</tt> to listen to.  When the <tt>fd</tt>
becomes ready for reading <a href="#wait"><tt>Fl::wait()</tt></a> will call the callback
and then return.  The callback is
passed the <tt>fd</tt> and the arbitrary <tt>void*</tt> argument.

<P>The second version takes a <tt>when</tt> bitfield, with the bits
<tt>FL_READ</tt>, <tt>FL_WRITE</tt>, and <tt>FL_EXCEPT</tt> defined,
to indicate when the callback should be done. Using this you can
register a different callback for each event. What happens if you make
multiple callbacks for the same <i>fd</i> that share <i>when</i> bits
is undefined.

<P>Under UNIX <I>any</I> file descriptor can be monitored (files,
devices, pipes, sockets, etc.) Due to limitations in Microsoft
Windows, WIN32 applications can only monitor sockets (? and the
<i>when</i> value is ignored?)

<a name="remove_fd"><h4>void Fl::remove_fd(int fd, int when = -1)</h4></a>

Remove <i>all</i> the callbacks (ie for all different <i>when</i>
values) for the given file descriptor. It is harmless to call this if
there are no callbacks for the file descriptor. If <i>when</i> is
given then those bits are removed from each callback for the file
descriptor, and the callback removed only if all of the bits turn off.

<a name="add_idle"><h4>Fl::add_idle(void (*cb)(void*), void*)</h4></a>

Adds a callback function that is called every time by
<a href="#wait"><tt>Fl::wait()</tt></a> and also makes it act as though the timeout is
zero (this makes <a href="#wait"><tt>Fl::wait()</tt></a> return immediately, so if it is
in a loop it is called repeatedly, and thus the idle fucntion is
called repeatedly).  The idle function can be used to get background
processing done.

<P>You can have multiple idle callbacks. To remove an idle callback use <a
href="#remove_idle"><tt>Fl::remove_idle()</tt></a>.

<P><a href="#wait"><tt>Fl::wait()</tt></a> and <a
href="#check"><tt>Fl::check()</tt></a> call idle callbacks, but
<a href="#ready"><tt>Fl::ready()</tt></a> does not.

<P>The idle callback can call any FLTK functions, including <a
href="#wait"><tt>Fl::wait()</tt></a>, <a
href="#check"><tt>Fl::check()</tt></a>, and <a
href="#ready"><tt>Fl::ready()</tt></a>.  Fltk will not recursively call
the idle callback.

<a name="has_idle"><h4>int Fl::has_idle(void (*cb)(void*), void* = 0)</h4></a>

Returns true if the specified idle callback is currently installed.

<a name="remove_idle"><h4>void Fl::remove_idle(void (*cb)(void*), void* = 0)</h4></a>

Removes the specified idle callback, if it is installed.

<a name="damage"><h4>int Fl::damage()</h4></a>

True if any <a
href="Fl_Widget.html#redraw"><tt>Fl_Widget::redraw()</tt></a> calls have
been done since the last <a href="#flush"><tt>flush()</tt></a>.

<a name="redraw"><h4>void Fl::redraw()</h4></a>

Redraws all widgets. This is a good idea if you have made global
changes to the styles.

<a name="flush"><h4>void Fl::flush()</h4></a>

Causes all the windows that need it to be redrawn and graphics forced 
out through the pipes.  This is what <tt>wait()</tt> does before 
looking for events. 

<h4><a name="warning">void (*Fl::warning)(const char *, ...)</a>
<br><a name="error">void (*Fl::error)(const char *, ...)</a>
<br><a name="fatal">void (*Fl::fatal)(const char *, ...)</a></h4>

FLTK will call these to print messages when unexpected conditions 
occur.

<p><tt>Fl::warning</tt> means that there was a recoverable problem,
the display may be messed up but the user can probably keep working.
(all X protocol errors call this).

<p><tt>Fl::error</tt> means there is a recoverable error, but the
display is so messed up it is unlikely the user can continue (very
little calls this now).

<p><tt>Fl::fatal</tt> must not return, as FLTK is in an unusable
state, however your version may be able to use <tt>longjmp</tt> or an
exception to continue, as long as it does not call FLTK again.</p>

<p>The default versions on Unix print messages to stderr, while on
Windows they use <tt>MessageBox()</tt>. <tt>Fl::error</tt> and
<tt>Fl::fatal</tt> call <tt>abort()</tt>. You can override the
behavior by setting the function pointers to your own routines.

<a name="first_window"><h4>Fl_Window *Fl::first_window()</h4></a>

Returns the id of some visible() window. If there is more than one,
the last one to receive an event is returned. This is useful for
setting the <a href="Fl_Window.html#child_of">Fl_Window::child_of()</a>
for dialog boxes that are used in multiple places in your program, and
is used by <a href="Fl_Window.html#exec">Fl_Window::exec()</a> if no
other parent is specified.

<a name="first_window_a"><h4>void Fl::first_window(Fl_Window*)</h4></a>

If this window is visible, this removes it from wherever it is in the
list and inserts it at the top, as though it received an event. This
can be used to change the parent of dialog boxes run by <a
href="Fl_Window.html#exec">Fl_Window::exec()</a> or <a
href="utility.html#fl_ask">fl_ask()</a>.

<a name="next_window"><h4>Fl_Window *Fl::next_window(Fl_Window *)</h4></a>

Returns the next visible() top-level window, returns NULL after the
last one.  You can use this and first_window() to iterate through all
the visible windows.

<a name="event"><h4>int Fl::event()</h4></a>

Returns the most recent event handled, such as <tt>FL_PUSH</tt> or
<tt>FL_KEYBOARD</tt>. This is useful so callbacks can find out why
they were called.

<h4><a name="event_x">int Fl::event_x()</a>
<br><a name="event_y">int Fl::event_y()</a></h4>

Returns the mouse position of the event relative to the <tt>Fl_Window</tt>
it was passed to. 

<h4><a name="event_dx">int Fl::event_dx()</a>
<br><a name="event_dy">int Fl::event_dy()</a></h4>

For <tt>FL_MOUSEWHEEL</tt> events this is how many clicks the user
moved in the x and y directions (currently dx is always zero).

<h4><a name="event_x_root">int Fl::event_x_root()
<br><a name="event_y_root">int Fl::event_y_root()</a></a></h4>

Returns the mouse position on the screen of the event.  To find the 
absolute position of an <tt>Fl_Window</tt> on the screen, use the 
difference between <tt>event_x_root(),event_y_root()</tt> and <tt>
event_x(),event_y()</tt>. 

<a name="event_clicks"><h4>int Fl::event_clicks()
<br>void Fl::event_clicks(int)</h4></a>

The first form returns non-zero if the most recent <tt>FL_PUSH</tt>
was a "double click", or if the most recent <tt>FL_KEYBOARD</tt> was
caused by a repeating key being held down. Returns N-1 for N repeats
of the key.

<p>The second form directly sets the number returned by <tt>
Fl::event_clicks()</tt>.  This can be used to set it to zero so that 
later code does not think an item was double-clicked.</p>

<a name="event_is_click"><h4>int Fl::event_is_click()
<br>void Fl::event_is_click(0)</h4></a>

This is non-zero if the mouse has not moved far enough and not enough
time has passed since the last <tt>FL_PUSH</tt> event for it to be
considered a "drag" rather than a "click".  You can test this on
<tt>FL_DRAG</tt>, <tt>FL_RELEASE</tt>, and <tt>FL_MOVE</tt> events.

<p>The second form clears the value returned by
<a href="#event_is_click"><tt>Fl::event_is_click()</tt></a>. This can be used to fool code that
treats click and drag differently, such as the popup menus. On X
turning this off will also prevent the next click from being
understood as a double click. Only a value of zero is allowed as an
argument.

<a name="event_button"><h4>int Fl::event_button()</h4></a>

Returns which mouse button was pressed.  This returns garbage if the 
most recent event was not a <tt>FL_PUSH</tt> or <tt>FL_RELEASE</tt>
event. 

<a name="event_state"><h4>ulong Fl::event_state()
<br>unsigned int Fl::event_state(ulong)</h4></a>

This is a bitfield of what shift states were on and what mouse buttons 
were held down during the most recent event.  The second version 
returns non-zero if any of the passed bits are turned on.  The legal 
bits are: 

<ul>
<li><tt>FL_SHIFT</tt></li>
<li><tt>FL_CAPS_LOCK</tt></li>
<li><tt>FL_CTRL</tt></li>
<li><tt>FL_ALT</tt></li>
<li><tt>FL_NUM_LOCK</tt></li>
<li><tt>FL_WIN</tt></li>
<li><tt>FL_SCROLL_LOCK</tt></li>
<li><tt>FL_BUTTON1</tt></li>
<li><tt>FL_BUTTON2</tt></li>
<li><tt>FL_BUTTON3</tt></li>
</ul>

X servers do not agree on shift states, so FL_NUM_LOCK, FL_WIN, and
FL_SCROLL_LOCK may not work.  The values were selected to match the
XFree86 server on Linux.  In addition there is a bug in the way X
works so that the shift state is not correctly reported until the
first event <I>after</I> the shift key is pressed or released.

<a name="event_key"><h4>int Fl::event_key()</h4></a>

Returns which key on the keyboard was last pushed. <tt>FL_FOCUS</tt>
events produced by the system, and mouse button events, set this to
values that cannot be confused with keys, to allow a widget to
determine if the focus is being changed due to a keystroke and what
keystroke that was.

<p>Keys are identified by the <I>unshifted</I> values. FLTK defines a 
set of symbols that should work on most modern machines for every key 
on the keyboard:</p>

<ul>

<li>All keys on the main keyboard producing a printable ASCII
character use the value of that ASCII character (as though shift,
ctrl, and caps lock were not on). The A key is <tt>'a'</tt>, the space
bar is 32.</li>

<li>All keys on the numeric keypad producing a printable ASCII
character produce <tt>FL_KP(c)</tt> where c is the character. This is
the same as <tt>FL_KP(0)+c</tt> so you can retrieve the ascii
character by subtracting <tt>FL_KP(0)</tt>. To see if a key is on the
keypad check <tt>key&gt;=FL_KP(0) &amp;&amp; key
&lt;;FL_KP_Last</tt>.

<li>All numbered function keys produce <tt>FL_F(n)</tt> where n is the
number of the key. This is the same as <tt>FL_F(0)+n</tt> so you can
get the function key number by subtracting <tt>FL_F(0)</tt>. To see if
a key is a function key, check <tt>key&gt;=FL_F(0) &amp;&amp; key
&lt;;FL_F_Last</tt>.

<li>All other keys on a US 101-keyboard have a symbol.  Be
careful not to confuse these with the very similar, but all-caps, 
symbols used by <a href="#event_state"><tt>Fl::event_state()</tt></a>

<ul><tt>FL_Escape<br> FL_BackSpace<br>FL_Tab<br> FL_Enter<br>
FL_Print<br> FL_Scroll_Lock<br> FL_Pause<br> FL_Insert<br> FL_Home<br>
FL_Page_Up<br> FL_Delete<br> FL_End<br> FL_Page_Down<br> FL_Left<br>
FL_Up<br> FL_Right<br> FL_Down<br> FL_Shift_L<br> FL_Shift_R<br>
FL_Control_L<br> FL_Control_R<br> FL_Caps_Lock<br> FL_Alt_L<br>
FL_Alt_R<br> FL_Win_L<br> FL_Win_R<br> FL_Menu<br> FL_Num_Lock<br>
FL_KP_Enter</tt></ul>

<li>On X systems any unrecognized keys are reported as their X keysym
value.

</ul>

<a name="event_key2"><h4>int Fl::event_key(int key)</h4></a>

<p><tt>Fl::event_key(int)</tt> returns true if the given key was held 
down (or pressed) <I>during</I> the last event.  This is constant until 
the next event is read from the server. The possible values for the
key are listed above.

<p>On Win32 <tt>Fl::event_key(FL_KP_Enter)</tt> does not work.

<a name="event_text"><h4>char *Fl::event_text()</h4></a>

Returns the ASCII text (in the future this may be UTF-8) produced by 
the last <tt>FL_KEYBOARD</tt> or <tt>FL_PASTE</tt> or possibly other 
event.  A zero-length string is returned for any keyboard function keys 
that do not produce text. This pointer points at a static buffer and is 
only valid until the next event is processed. 

<p>Under X this is the result of calling <tt>XLookupString()</tt>.</p>

<a name="event_length"><h4>char *Fl::event_length()</h4></a>

Returns the length of the text in <a
href="#event_text"><tt>Fl::event_text()</tt></a>.  There will always be
a nul at this position in the text.  However there may be a nul before
that if the keystroke translates to a nul character or you paste a nul
character.

<a name="event_inside"><h4>int Fl::event_inside(int x, int y, int w, int h)</h4></a>

Returns non-zero if the current <a
href="#event_x"><tt>Fl::event_x()</tt></a>
and <a href="#event_y"><tt>Fl::event_y()</tt></a>
put it inside the passed box.  You should always call this rather than
doing your own comparison so you are consistent about edge effects.

<a name="test_shortcut"><h4>int Fl::test_shortcut(int shortcut)</h4></a>

Test the current event, which must be an <tt>FL_KEYBOARD</tt> or <tt>
FL_SHORTCUT</tt>, against a shortcut value (described in <a
href="Fl_Button.html#shortcut"><tt>Fl_Button</tt></a>).
Returns non-zero if there is a match.  Not to be confused with <a
href="Fl_Widget.html#test_shortcut"><tt>Fl_Widget::test_shortcut()</tt></a>.

<a name="key_name"><h4>const char* Fl::key_name(int shortcut)</h4></a>

Unparse a key name (as returned by <a
href="#event_key"><tt>Fl::event_key()</tt></a>) or a shortcut value (as
used by <a href="Fl_Button.html#shortcut">
<TT>Fl_Button</TT></a> or <a href="Fl_Menu_Item.html#Fl_Menu_Item"><TT>
Fl_Menu_Item</TT></a>) into a human-readable string like "Alt+N".  If
the shortcut is zero an empty string is returned. <i>The return value
points at a static buffer that is overwritten with each call.</i>

<a name="compose"><h4>int Fl::compose(int&amp; del)</h4></a>

<p>Use of this function is very simple.  Any text editing widget should
call this for each <tt>FL_KEYBOARD</tt> event.

<p>If <tt>true</tt> is returned, then it has modified the <a
href="#event_text"><tt>Fl::event_text()</tt></a> and <a
href="#event_length"><tt>Fl::event_length()</tt></a> to a set of
<i>bytes</i> to insert (it may be of zero length!).  It will also set
the <i>del</i> parameter to the number of <i>bytes</i> to the left of
the cursor to delete, this is used to delete the results of the
previous call to Fl::compose().

<p>If <tt>false</tt> is returned, the keys should be treated as
function keys.  You could insert the text anyways, if you don't know
what else to do, <i>del</i> is set to zero and the <a
href="#event_text"><tt>Fl::event_text()</tt></a> and <a
href="#event_length"><tt>Fl::event_length()</tt></a> are left unchanged,
length is zero for any function keys.

<p>Though the current implementation returns immediately, future
versions may take quite awhile, as they may pop up a window or do
other user-interface things to allow characters to be selected.

<a name="compose_reset"><h4>int Fl::compose_reset()</h4></a>

<p>If the user moves the cursor, be sure to call Fl::compose_reset().
The next call to Fl::compose() will start out in an initial state.  In
particular it will not set "del" to non-zero.  This call is very fast
so it is ok to call it many times and in many places.

<a name="get_key"><h4>int Fl::get_key(int)</h4></a>

<p>Returns true if the given key is held down <I> now</I>.  Under X
this requires a round-trip to the server and is <I> much</I> slower
than <a href="#event_key2"><tt>Fl::event_key(int)</tt></a>.</p>

<p>On Win32 <tt>Fl::get_key(FL_KP_Enter)</tt> does not work.

<a name="get_mouse"><h4>void Fl::get_mouse(int &amp;x, int &amp;y)</h4></a>

Return where the mouse is on the screen by doing a round-trip query to
the server.  You should use <a
href="#event_x_root"><tt>Fl::event_x_root()</tt></a> and <a
href="#event_y_root"><tt>Fl::event_y_root()</tt></a> if possible, but
this is necessary if you are not sure if a mouse event has been
processed recently (such as to position your first window).  If the
display is not open, this will open it.

<a name="add_handler"><h4>void Fl::add_handler(int (*f)(int))</h4></a>

Install a function to parse unrecognized events.  If FLTK cannot 
figure out what to do with an event, it calls each of these functions 
(most recent first) until one of them returns non-zero.  If none of 
them returns non zero then the event is ignored.

<p>Currently there are only two uses for this:

<p>1. If there is a keystroke that no widgets are interested in, this
is called with <tt>FL_SHORTCUT</tt>. You can use this to implement
global shortcut keys.

<p>2. On X, if FLTK does not recognize an X event or the window id the
event is sent to, this is called with zero. You can then use <a
href="x.html#fl_xevent">system specific code</a> to access the event
data and figure out what to do. (this is not done on Win32 due to the
<i>enormous</i> number of bogus events sent, it was much to slow to
search the handler list for every one).

<p>Ignore any other values this is called with. We have not figured
out what the rules for these are yet.

<a name="belowmouse"><h4>Fl_Widget* Fl::belowmouse() const</h4></a>

Get the widget that is below the mouse. This is the last widget to
respond to an <tt>FL_ENTER</tt> event as long as the mouse is still
pointing at it. This is for highlighting buttons and bringing up
tooltips. It is not used to send <tt>FL_PUSH</tt> or <tt> FL_MOVE</tt>
directly, for several obscure reasons, but those events typically go
to this widget.

<h4>void Fl::belowmouse(Fl_Widget*)</a></h4>

<p>Change the <a href="#belowmouse"><tt>Fl::belowmouse()</tt></a>
widget, the previous one and all parents (that don't contain the new
widget) are sent <tt>FL_LEAVE</tt> events.  Changing this does
<I>not</I> send <tt>FL_ENTER</tt> to this or any widget, because
sending <tt>FL_ENTER</tt> is supposed to <I>test</I> if the widget
wants the mouse (by it returning non-zero from <tt>handle()</tt>).</p>

<a name="pushed"><h4>Fl_Widget* Fl::pushed() const;</h4></a>

Get the widget that is being pushed. <tt>FL_DRAG</tt> or <tt>
FL_RELEASE</tt> (and any more <tt>FL_PUSH</tt>) events will be sent to 
this widget. This is null if no mouse button is being held down, or if
no widget responded to the <tt>FL_PUSH</tt> event.

<h4>void Fl::pushed(Fl_Widget*)</a></h4>

<p>Change the <a href="#pushed"><tt>Fl::pushed()</tt></a> widget, the
previous one and all parents (that don't contain the new widget) are
sent <tt>FL_RELEASE</tt> events.  Changing this does <I>not</I> send
<tt>FL_PUSH</tt> to this or any widget, because sending
<tt>FL_PUSH</tt> is supposed to <I>test</I> if the widget wants the
mouse (by it returning non-zero from <tt> handle()</tt>).</p>

<a name="focus"><h4>Fl_Widget* Fl::focus() const;</h4></a>

Returns the widgets that will receive <tt>FL_KEYBOARD</tt>
events. This is NULL if the application does not have focus now, or if
no widgets accepted focus.

<h4>void Fl::focus(Fl_Widget *)</a></h4>

Change <a href="#focus"><tt>Fl::focus()</tt></a> to the given widget,
the previous widget and all parents (that don't contain the new
widget) are sent <tt>FL_UNFOCUS</tt> events, the new widget and all
parents that don't contain the old widget are sent <tt>FL_FOCUS</tt>
events. <tt>Fl::focus()</tt> is set whether or not the applicaton has the
focus or if the widgets accept the focus. You may want to use <a
href="Fl_Widget.html#take_focus">Fl_Widget::take_focus()</a> instead, it
will test first.

<a name="copy"><h4>void Fl::copy(const char *stuff, int len, bool clipboard=false)</h4></a>

Change the current selection.  The block of text is 
copied to an internal buffer by FLTK (be careful if doing this in 
response to an <tt>FL_PASTE</tt> as this <I>may</I> be the same buffer 
returned by <tt>event_text()</tt>).

<p>The block of text may be retrieved (from this program or whatever
program last set it) with <a href="#paste"><tt>Fl::paste()</tt></a>.

<p>There are actually two buffers. If <i>clipboard</i> is true then
the text goes into the user-visible selection that is moved around
with cut/copy/paste commands (on X this is the CLIPBOARD
selection). If <i>clipboard</i> is false then the text goes into a
less-visible buffer used for temporarily selecting text with the mouse
and for drag & drop (on X this is the XA_PRIMARY selection).

<p><I>Copying the buffer every time the selection is changed is 
obviously wasteful, especially for large selections.  An interface will 
probably be added in a future version to allow the selection to be made 
by a callback function.  The current interface will be emulated on top 
of this.</I>

<a name="paste"><h4>void Fl::paste(Fl_Widget *receiver, bool clipboard = false)</h4></a>

Cause an <a href="events.html#FL_PASTE"><tt>FL_PASTE</tt></a> event to be
sent to the <i>receiver</i> with the contents of the current selection
in the <a href="#event_text"><tt>Fl::event_text()</tt></a>. The
selection can be set by <a href="#copy"><tt>Fl::copy()</tt></a>.

<p>There are actually two buffers. If <i>clipboard</i> is true then
the text is from the user-visible selection that is moved around
with cut/copy/paste commands (on X this is the CLIPBOARD
selection). If <i>clipboard</i> is false then the text goes into a
less-visible buffer used for temporarily selecting text with the mouse
and for drag & drop (on X this is the XA_PRIMARY selection).

<p>The reciever should be prepared to be called <I>directly</I> by
this, or for it to happen <I>later</I>, or possibly <I>not at all</I>.
This allows the window system to take as long as necessary to retrieve
the paste buffer (or even to screw up completely) without complex and
error-prone synchronization code most toolkits require.

<a name="info"><h4>const Fl_Screen_Info& Fl::info()</h4></a>

Return a structure of information describing the current state of the
screen. Currently this structure contains the following (this may be
added to in the future):

<ul>
<li><tt>int x</tt> left edge of work area
<li><tt>int y</tt> top edge of work area
<li><tt>int w</tt> width of work area
<li><tt>int h</tt> height of work area
<li><tt>int width</tt> full screen width in pixels
<li><tt>int height</tt> full screen height in pixels
<li><tt>int depth</tt> bits per pixel
<li><tt>int width_mm</tt> screen width in millimeters
<li><tt>int height_mm</tt> screen height in millimeters
</ul>

<a name="lock"><h4>void Fl::lock();</h4></a>

Blocks the current thread until it can safely access FLTK widgets and
data. Child threads should call this method prior to updating any
widgets or accessing data. The main thread must call
<tt>Fl::lock()</tt> to initialize the threading support in FLTK before
calling <a href="#wait"><tt>Fl::wait()</tt></a> or <a
href="#run"><tt>Fl::run()</tt></a>.

<p>Child threads must call <a href="#unlock"><tt>Fl::unlock()</tt></a>
when they are done accessing FLTK. They may want to call <a
href="#awake"><tt>Fl::awake()</tt></a> first if the display needs to
change.

<p>This is a "recursive lock". If you call <tt>Fl::lock()</tt> more
than once, the subsequent calls return immediately. But you must call
<tt>Fl::unlock()</tt> the same number of times as you called
<tt>Fl::lock()</tt> before the lock is released.

<p>When the <a href="#wait"><tt>wait()</tt></a> method is waiting for
input or timeouts, child threads are given access to FLTK. Similarly,
when the main thread receives events and needs to do processing, it
will wait until all child threads have called <a
href=#unlock><tt>unlock()</tt></a> before processing the events and
doing callbacks.

<p>See the file <tt>&lt;fltk/Fl_Threads.h&gt;</tt> for a simple
portable recursive lock object you can use in your own code for
locking other objects. However there is no requirement that you use
this, you can use pthreads or any other library that is compatable
with your system.

<a name="unlock"><h4>void Fl::unlock();</h4></a>

Releases the lock that was set using the <a
href="#lock"><tt>Fl::lock()</tt></a> method. Child threads should call
this method as soon as they are finished accessing FLTK. If some other
thread is waiting for <tt>Fl::lock()</tt> to return, it will get
control.

<a name="awake"><h4>void Fl::awake(void* message = 0);</h4></a>

A parallel thread calling this will cause the thread that is calling
<a href="#wait"><tt>Fl::wait()</tt></a> to return (with the lock locked)
even if there are no events ready.  Like all other FLTK calls you must
aquire the lock with <a href="#lock"><tt>Fl::lock()</tt></a> before
calling this, then call <a href="#unlock"><tt>Fl::unlock()</tt></a>
afterwards.

<p>The <i>message</i> argument can be retrieved by the other thread
using <a href="#thread_message"><tt>Fl::thread_message()</tt></a>.

<a name="thread_message"><h4>void* thread_message();</h4></a>

Returns an argument sent to an <a href="#awake"><tt>Fl::awake()</tt></a>
call, or returns null if none. <i>The current implementation
only has a one-entry queue and only returns the most recent value!</i>

</body></html>
