<html>
<body>

<hr break>

<h2><a name="Fl_Scroll">class Fl_Scroll</a></h2>

<hr>

<h3>Class Hierarchy</h3>

<ul><pre>
<a href="#Fl_Group">Fl_Group</a>
   |
   +----<b>Fl_Scroll</b>
</pre></ul>

<h3>Include Files</h3>

<ul><pre>
#include &lt;FL/Fl_Scroll.H>
</pre></ul>

<h3>Description</h3>

This container widget lets you maneuver around a set of widgets
much larger than your window.  If the child widgets are larger than
the size of this object then scrollbars will appear so that you can
scroll over to them:

<p><img src=Fl_Scroll.gif>

<p>If all of the child widgets are packed together into a solid
rectangle then you want to set <tt>box()</tt> to <tt>FL_NO_BOX</tt> or
one of the <tt>_FRAME</tt> types. This will result in the best output. 
However, if the child widgets are a sparse arrangment you must set
<tt>box()</tt> to a real <tt>_BOX</tt> type.  This can result in some
blinking during redrawing, but that can be solved by using a
<tt>Fl_Double_Window</tt>.

<p>This widget can also be used to pan around a single child widget
"canvas".  This child widget should be of your own class, with a
<tt>draw()</tt> method that draws the contents.  The scrolling is done
by changing the <tt>x()</tt> and <tt>y()</tt> of the widget, so this
child must use the <tt>x()</tt> and <tt>y()</tt> to position it's
drawing.  To speed up drawing it should test <a
href=fl_clip><tt>fl_clip()</tt></a>.

<p>Another very useful child is a single <a
href="#Fl_Pack"><tt>Fl_Pack</tt></a>, which is itself a group that
packs it's children together and changes size to surround them. 
Filling the <tt>Fl_Pack</tt> with <a href="#Fl_Tab"><tt>Fl_Tab</tt></a>
groups (and then putting normal widgets inside those) gives you a very
powerful scrolling list of individually-openable panels.

<p>Fluid lets you create these, but you can only lay out objects that
fit inside the <tt>Fl_Scroll</tt> without scrolling.  Be sure to leave
space for the scrollbars, as Fluid won't show these either.

<p><i>You cannot use <tt>Fl_Window</tt> as a child of this since the
clipping is not conveyed to it when drawn, and it will draw over the
scrollbars and neighboring objects.</i>

<h3>Methods</h3>

<ul>
	<li><a href="#Fl_Scroll.Fl_Scroll">Fl_Scroll</a>
	<li><a href="#Fl_Scroll.~Fl_Scroll">~Fl_Scroll</a>
	<li><a href="#Fl_Scroll.align">align</a>
	<li><a href="#Fl_Scroll.position">position</a>
	<li><a href="#Fl_Scroll.type">type</a>
	<li><a href="#Fl_Scroll.xposition">xposition</a>
	<li><a href="#Fl_Scroll.yposition">yposition</a>
</ul>

<h4><a name="Fl_Scroll.Fl_Scroll">Fl_Scroll::Fl_Scroll(int x, int y, int w, int h, const char *label = 0)</a></h4>

Creates a new <tt>Fl_Scroll</tt> widget using the given position, size, and
label string. The default boxtype is <tt>FL_NO_BOX</tt>.

<h4><a name="Fl_Scroll.~Fl_Scroll">virtual Fl_Scroll::~Fl_Scroll()</a></h4>

The destructor <i>also deletes all the children</i>. This allows a
whole tree to be deleted at once, without having to keep a pointer to all
the children in the user code. A kludge has been done so the
<tt>Fl_Scroll</tt> and all of it's children can be automatic (local)
variables, but you must declare the <tt>Fl_Scroll</tt> <i>first</i>, so
that it is destroyed last.

<h4><a name="Fl_Scroll.type">void Fl_Widget::type(int)</a></h4>

By default you can scroll in both directions, and the scrollbars
disappear if the data will fit in the area of the scroll.  <tt>type()</tt>
can change this:

<ul>
	<li><tt>0</tt> - No scrollbars

	<li><tt>Fl_Scroll::HORIZONTAL</tt> - Only a horizontal scrollbar.

	<li><tt>Fl_Scroll::VERTICAL</tt> - Only a vertical scrollbar.

	<li><tt>Fl_Scroll::BOTH</tt> - The default is both scrollbars.

	<li><tt>Fl_Scroll::HORIZONTAL_ALWAYS</tt> - Horizontal scrollbar
	always on, vertical always off.

	<li><tt>Fl_Scroll::VERTICAL_ALWAYS</tt> - Vertical scrollbar always on,
	horizontal always off.

	<li><tt>Fl_Scroll::BOTH_ALWAYS</tt> - Both always on.
</ul>

<h4><a name="Fl_Scroll.align">void Fl_Scroll::scrollbar.align(int)<br>
void Fl_Scroll::hscrollbar.align(int)</a></h4>

This is used to change what side the scrollbars are drawn on.  If the
<tt>FL_ALIGN_LEFT</tt> bit is on, the vertical scrollbar is on the
left.  If the <tt>FL_ALIGN_TOP</tt> bit is on, the horizontal scrollbar
is on the top.

<h4><a name="Fl_Scroll.xposition">int Fl_Scroll::xposition() const</a></h4>

Gets the current horizontal scrolling position.

<h4><a name="Fl_Scroll.yposition">int Fl_Scroll::yposition() const</a></h4>

Gets the current vertical scrolling position.

<h4><a name="Fl_Scroll.position">void Fl_Scroll::position(int w, int h)</a></h4>

Sets the upper-lefthand corner of the scrolling region.

</body>
</html>
